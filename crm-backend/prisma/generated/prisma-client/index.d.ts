
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Deal
 * 
 */
export type Deal = $Result.DefaultSelection<Prisma.$DealPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model EmailAccount
 * 
 */
export type EmailAccount = $Result.DefaultSelection<Prisma.$EmailAccountPayload>
/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>
/**
 * Model EmailMessage
 * 
 */
export type EmailMessage = $Result.DefaultSelection<Prisma.$EmailMessagePayload>
/**
 * Model EmailInboxMessage
 * 
 */
export type EmailInboxMessage = $Result.DefaultSelection<Prisma.$EmailInboxMessagePayload>
/**
 * Model EmailContact
 * 
 */
export type EmailContact = $Result.DefaultSelection<Prisma.$EmailContactPayload>
/**
 * Model DocumentTemplate
 * 
 */
export type DocumentTemplate = $Result.DefaultSelection<Prisma.$DocumentTemplatePayload>
/**
 * Model GeneratedDocument
 * 
 */
export type GeneratedDocument = $Result.DefaultSelection<Prisma.$GeneratedDocumentPayload>
/**
 * Model FileFolder
 * 
 */
export type FileFolder = $Result.DefaultSelection<Prisma.$FileFolderPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model SettingOption
 * 
 */
export type SettingOption = $Result.DefaultSelection<Prisma.$SettingOptionPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model DealTag
 * 
 */
export type DealTag = $Result.DefaultSelection<Prisma.$DealTagPayload>
/**
 * Model ContactTag
 * 
 */
export type ContactTag = $Result.DefaultSelection<Prisma.$ContactTagPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model Webhook
 * 
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>
/**
 * Model SharedAccess
 * 
 */
export type SharedAccess = $Result.DefaultSelection<Prisma.$SharedAccessPayload>
/**
 * Model AutomationRule
 * 
 */
export type AutomationRule = $Result.DefaultSelection<Prisma.$AutomationRulePayload>
/**
 * Model CustomField
 * 
 */
export type CustomField = $Result.DefaultSelection<Prisma.$CustomFieldPayload>
/**
 * Model CustomFieldValue
 * 
 */
export type CustomFieldValue = $Result.DefaultSelection<Prisma.$CustomFieldValuePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deal`: Exposes CRUD operations for the **Deal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deals
    * const deals = await prisma.deal.findMany()
    * ```
    */
  get deal(): Prisma.DealDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailAccount`: Exposes CRUD operations for the **EmailAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailAccounts
    * const emailAccounts = await prisma.emailAccount.findMany()
    * ```
    */
  get emailAccount(): Prisma.EmailAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailMessage`: Exposes CRUD operations for the **EmailMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailMessages
    * const emailMessages = await prisma.emailMessage.findMany()
    * ```
    */
  get emailMessage(): Prisma.EmailMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailInboxMessage`: Exposes CRUD operations for the **EmailInboxMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailInboxMessages
    * const emailInboxMessages = await prisma.emailInboxMessage.findMany()
    * ```
    */
  get emailInboxMessage(): Prisma.EmailInboxMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailContact`: Exposes CRUD operations for the **EmailContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailContacts
    * const emailContacts = await prisma.emailContact.findMany()
    * ```
    */
  get emailContact(): Prisma.EmailContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentTemplate`: Exposes CRUD operations for the **DocumentTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentTemplates
    * const documentTemplates = await prisma.documentTemplate.findMany()
    * ```
    */
  get documentTemplate(): Prisma.DocumentTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.generatedDocument`: Exposes CRUD operations for the **GeneratedDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeneratedDocuments
    * const generatedDocuments = await prisma.generatedDocument.findMany()
    * ```
    */
  get generatedDocument(): Prisma.GeneratedDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileFolder`: Exposes CRUD operations for the **FileFolder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileFolders
    * const fileFolders = await prisma.fileFolder.findMany()
    * ```
    */
  get fileFolder(): Prisma.FileFolderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settingOption`: Exposes CRUD operations for the **SettingOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SettingOptions
    * const settingOptions = await prisma.settingOption.findMany()
    * ```
    */
  get settingOption(): Prisma.SettingOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dealTag`: Exposes CRUD operations for the **DealTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DealTags
    * const dealTags = await prisma.dealTag.findMany()
    * ```
    */
  get dealTag(): Prisma.DealTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactTag`: Exposes CRUD operations for the **ContactTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactTags
    * const contactTags = await prisma.contactTag.findMany()
    * ```
    */
  get contactTag(): Prisma.ContactTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhook.findMany()
    * ```
    */
  get webhook(): Prisma.WebhookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sharedAccess`: Exposes CRUD operations for the **SharedAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharedAccesses
    * const sharedAccesses = await prisma.sharedAccess.findMany()
    * ```
    */
  get sharedAccess(): Prisma.SharedAccessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.automationRule`: Exposes CRUD operations for the **AutomationRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationRules
    * const automationRules = await prisma.automationRule.findMany()
    * ```
    */
  get automationRule(): Prisma.AutomationRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customField`: Exposes CRUD operations for the **CustomField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomFields
    * const customFields = await prisma.customField.findMany()
    * ```
    */
  get customField(): Prisma.CustomFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customFieldValue`: Exposes CRUD operations for the **CustomFieldValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomFieldValues
    * const customFieldValues = await prisma.customFieldValue.findMany()
    * ```
    */
  get customFieldValue(): Prisma.CustomFieldValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    Team: 'Team',
    Account: 'Account',
    Contact: 'Contact',
    Deal: 'Deal',
    Activity: 'Activity',
    EmailAccount: 'EmailAccount',
    EmailTemplate: 'EmailTemplate',
    EmailMessage: 'EmailMessage',
    EmailInboxMessage: 'EmailInboxMessage',
    EmailContact: 'EmailContact',
    DocumentTemplate: 'DocumentTemplate',
    GeneratedDocument: 'GeneratedDocument',
    FileFolder: 'FileFolder',
    File: 'File',
    SettingOption: 'SettingOption',
    SystemSetting: 'SystemSetting',
    DealTag: 'DealTag',
    ContactTag: 'ContactTag',
    Tag: 'Tag',
    Webhook: 'Webhook',
    SharedAccess: 'SharedAccess',
    AutomationRule: 'AutomationRule',
    CustomField: 'CustomField',
    CustomFieldValue: 'CustomFieldValue',
    AuditLog: 'AuditLog',
    Comment: 'Comment',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "role" | "team" | "account" | "contact" | "deal" | "activity" | "emailAccount" | "emailTemplate" | "emailMessage" | "emailInboxMessage" | "emailContact" | "documentTemplate" | "generatedDocument" | "fileFolder" | "file" | "settingOption" | "systemSetting" | "dealTag" | "contactTag" | "tag" | "webhook" | "sharedAccess" | "automationRule" | "customField" | "customFieldValue" | "auditLog" | "comment" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Deal: {
        payload: Prisma.$DealPayload<ExtArgs>
        fields: Prisma.DealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findFirst: {
            args: Prisma.DealFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findMany: {
            args: Prisma.DealFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          create: {
            args: Prisma.DealCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          createMany: {
            args: Prisma.DealCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DealCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          delete: {
            args: Prisma.DealDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          update: {
            args: Prisma.DealUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          deleteMany: {
            args: Prisma.DealDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DealUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DealUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          upsert: {
            args: Prisma.DealUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          aggregate: {
            args: Prisma.DealAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeal>
          }
          groupBy: {
            args: Prisma.DealGroupByArgs<ExtArgs>
            result: $Utils.Optional<DealGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealCountArgs<ExtArgs>
            result: $Utils.Optional<DealCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      EmailAccount: {
        payload: Prisma.$EmailAccountPayload<ExtArgs>
        fields: Prisma.EmailAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          findFirst: {
            args: Prisma.EmailAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          findMany: {
            args: Prisma.EmailAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>[]
          }
          create: {
            args: Prisma.EmailAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          createMany: {
            args: Prisma.EmailAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>[]
          }
          delete: {
            args: Prisma.EmailAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          update: {
            args: Prisma.EmailAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          deleteMany: {
            args: Prisma.EmailAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>[]
          }
          upsert: {
            args: Prisma.EmailAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          aggregate: {
            args: Prisma.EmailAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailAccount>
          }
          groupBy: {
            args: Prisma.EmailAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailAccountCountArgs<ExtArgs>
            result: $Utils.Optional<EmailAccountCountAggregateOutputType> | number
          }
        }
      }
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
      EmailMessage: {
        payload: Prisma.$EmailMessagePayload<ExtArgs>
        fields: Prisma.EmailMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          findFirst: {
            args: Prisma.EmailMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          findMany: {
            args: Prisma.EmailMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>[]
          }
          create: {
            args: Prisma.EmailMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          createMany: {
            args: Prisma.EmailMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>[]
          }
          delete: {
            args: Prisma.EmailMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          update: {
            args: Prisma.EmailMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          deleteMany: {
            args: Prisma.EmailMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>[]
          }
          upsert: {
            args: Prisma.EmailMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          aggregate: {
            args: Prisma.EmailMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailMessage>
          }
          groupBy: {
            args: Prisma.EmailMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailMessageCountArgs<ExtArgs>
            result: $Utils.Optional<EmailMessageCountAggregateOutputType> | number
          }
        }
      }
      EmailInboxMessage: {
        payload: Prisma.$EmailInboxMessagePayload<ExtArgs>
        fields: Prisma.EmailInboxMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailInboxMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailInboxMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailInboxMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailInboxMessagePayload>
          }
          findFirst: {
            args: Prisma.EmailInboxMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailInboxMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailInboxMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailInboxMessagePayload>
          }
          findMany: {
            args: Prisma.EmailInboxMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailInboxMessagePayload>[]
          }
          create: {
            args: Prisma.EmailInboxMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailInboxMessagePayload>
          }
          createMany: {
            args: Prisma.EmailInboxMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailInboxMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailInboxMessagePayload>[]
          }
          delete: {
            args: Prisma.EmailInboxMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailInboxMessagePayload>
          }
          update: {
            args: Prisma.EmailInboxMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailInboxMessagePayload>
          }
          deleteMany: {
            args: Prisma.EmailInboxMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailInboxMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailInboxMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailInboxMessagePayload>[]
          }
          upsert: {
            args: Prisma.EmailInboxMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailInboxMessagePayload>
          }
          aggregate: {
            args: Prisma.EmailInboxMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailInboxMessage>
          }
          groupBy: {
            args: Prisma.EmailInboxMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailInboxMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailInboxMessageCountArgs<ExtArgs>
            result: $Utils.Optional<EmailInboxMessageCountAggregateOutputType> | number
          }
        }
      }
      EmailContact: {
        payload: Prisma.$EmailContactPayload<ExtArgs>
        fields: Prisma.EmailContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>
          }
          findFirst: {
            args: Prisma.EmailContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>
          }
          findMany: {
            args: Prisma.EmailContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>[]
          }
          create: {
            args: Prisma.EmailContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>
          }
          createMany: {
            args: Prisma.EmailContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>[]
          }
          delete: {
            args: Prisma.EmailContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>
          }
          update: {
            args: Prisma.EmailContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>
          }
          deleteMany: {
            args: Prisma.EmailContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>[]
          }
          upsert: {
            args: Prisma.EmailContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>
          }
          aggregate: {
            args: Prisma.EmailContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailContact>
          }
          groupBy: {
            args: Prisma.EmailContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailContactCountArgs<ExtArgs>
            result: $Utils.Optional<EmailContactCountAggregateOutputType> | number
          }
        }
      }
      DocumentTemplate: {
        payload: Prisma.$DocumentTemplatePayload<ExtArgs>
        fields: Prisma.DocumentTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
          }
          findFirst: {
            args: Prisma.DocumentTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
          }
          findMany: {
            args: Prisma.DocumentTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>[]
          }
          create: {
            args: Prisma.DocumentTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
          }
          createMany: {
            args: Prisma.DocumentTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>[]
          }
          delete: {
            args: Prisma.DocumentTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
          }
          update: {
            args: Prisma.DocumentTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
          }
          deleteMany: {
            args: Prisma.DocumentTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>[]
          }
          upsert: {
            args: Prisma.DocumentTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
          }
          aggregate: {
            args: Prisma.DocumentTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentTemplate>
          }
          groupBy: {
            args: Prisma.DocumentTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentTemplateCountAggregateOutputType> | number
          }
        }
      }
      GeneratedDocument: {
        payload: Prisma.$GeneratedDocumentPayload<ExtArgs>
        fields: Prisma.GeneratedDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeneratedDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeneratedDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>
          }
          findFirst: {
            args: Prisma.GeneratedDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeneratedDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>
          }
          findMany: {
            args: Prisma.GeneratedDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>[]
          }
          create: {
            args: Prisma.GeneratedDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>
          }
          createMany: {
            args: Prisma.GeneratedDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeneratedDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>[]
          }
          delete: {
            args: Prisma.GeneratedDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>
          }
          update: {
            args: Prisma.GeneratedDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>
          }
          deleteMany: {
            args: Prisma.GeneratedDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeneratedDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GeneratedDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>[]
          }
          upsert: {
            args: Prisma.GeneratedDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>
          }
          aggregate: {
            args: Prisma.GeneratedDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeneratedDocument>
          }
          groupBy: {
            args: Prisma.GeneratedDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeneratedDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeneratedDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<GeneratedDocumentCountAggregateOutputType> | number
          }
        }
      }
      FileFolder: {
        payload: Prisma.$FileFolderPayload<ExtArgs>
        fields: Prisma.FileFolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          findFirst: {
            args: Prisma.FileFolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          findMany: {
            args: Prisma.FileFolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>[]
          }
          create: {
            args: Prisma.FileFolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          createMany: {
            args: Prisma.FileFolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileFolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>[]
          }
          delete: {
            args: Prisma.FileFolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          update: {
            args: Prisma.FileFolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          deleteMany: {
            args: Prisma.FileFolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileFolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileFolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>[]
          }
          upsert: {
            args: Prisma.FileFolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          aggregate: {
            args: Prisma.FileFolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileFolder>
          }
          groupBy: {
            args: Prisma.FileFolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileFolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileFolderCountArgs<ExtArgs>
            result: $Utils.Optional<FileFolderCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      SettingOption: {
        payload: Prisma.$SettingOptionPayload<ExtArgs>
        fields: Prisma.SettingOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingOptionPayload>
          }
          findFirst: {
            args: Prisma.SettingOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingOptionPayload>
          }
          findMany: {
            args: Prisma.SettingOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingOptionPayload>[]
          }
          create: {
            args: Prisma.SettingOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingOptionPayload>
          }
          createMany: {
            args: Prisma.SettingOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingOptionPayload>[]
          }
          delete: {
            args: Prisma.SettingOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingOptionPayload>
          }
          update: {
            args: Prisma.SettingOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingOptionPayload>
          }
          deleteMany: {
            args: Prisma.SettingOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingOptionPayload>[]
          }
          upsert: {
            args: Prisma.SettingOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingOptionPayload>
          }
          aggregate: {
            args: Prisma.SettingOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettingOption>
          }
          groupBy: {
            args: Prisma.SettingOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingOptionCountArgs<ExtArgs>
            result: $Utils.Optional<SettingOptionCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      DealTag: {
        payload: Prisma.$DealTagPayload<ExtArgs>
        fields: Prisma.DealTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealTagPayload>
          }
          findFirst: {
            args: Prisma.DealTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealTagPayload>
          }
          findMany: {
            args: Prisma.DealTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealTagPayload>[]
          }
          create: {
            args: Prisma.DealTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealTagPayload>
          }
          createMany: {
            args: Prisma.DealTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DealTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealTagPayload>[]
          }
          delete: {
            args: Prisma.DealTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealTagPayload>
          }
          update: {
            args: Prisma.DealTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealTagPayload>
          }
          deleteMany: {
            args: Prisma.DealTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DealTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DealTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealTagPayload>[]
          }
          upsert: {
            args: Prisma.DealTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealTagPayload>
          }
          aggregate: {
            args: Prisma.DealTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDealTag>
          }
          groupBy: {
            args: Prisma.DealTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<DealTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealTagCountArgs<ExtArgs>
            result: $Utils.Optional<DealTagCountAggregateOutputType> | number
          }
        }
      }
      ContactTag: {
        payload: Prisma.$ContactTagPayload<ExtArgs>
        fields: Prisma.ContactTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          findFirst: {
            args: Prisma.ContactTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          findMany: {
            args: Prisma.ContactTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>[]
          }
          create: {
            args: Prisma.ContactTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          createMany: {
            args: Prisma.ContactTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>[]
          }
          delete: {
            args: Prisma.ContactTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          update: {
            args: Prisma.ContactTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          deleteMany: {
            args: Prisma.ContactTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>[]
          }
          upsert: {
            args: Prisma.ContactTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          aggregate: {
            args: Prisma.ContactTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactTag>
          }
          groupBy: {
            args: Prisma.ContactTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactTagCountArgs<ExtArgs>
            result: $Utils.Optional<ContactTagCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>
        fields: Prisma.WebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook>
          }
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number
          }
        }
      }
      SharedAccess: {
        payload: Prisma.$SharedAccessPayload<ExtArgs>
        fields: Prisma.SharedAccessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SharedAccessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SharedAccessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccessPayload>
          }
          findFirst: {
            args: Prisma.SharedAccessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SharedAccessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccessPayload>
          }
          findMany: {
            args: Prisma.SharedAccessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccessPayload>[]
          }
          create: {
            args: Prisma.SharedAccessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccessPayload>
          }
          createMany: {
            args: Prisma.SharedAccessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SharedAccessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccessPayload>[]
          }
          delete: {
            args: Prisma.SharedAccessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccessPayload>
          }
          update: {
            args: Prisma.SharedAccessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccessPayload>
          }
          deleteMany: {
            args: Prisma.SharedAccessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SharedAccessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SharedAccessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccessPayload>[]
          }
          upsert: {
            args: Prisma.SharedAccessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccessPayload>
          }
          aggregate: {
            args: Prisma.SharedAccessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSharedAccess>
          }
          groupBy: {
            args: Prisma.SharedAccessGroupByArgs<ExtArgs>
            result: $Utils.Optional<SharedAccessGroupByOutputType>[]
          }
          count: {
            args: Prisma.SharedAccessCountArgs<ExtArgs>
            result: $Utils.Optional<SharedAccessCountAggregateOutputType> | number
          }
        }
      }
      AutomationRule: {
        payload: Prisma.$AutomationRulePayload<ExtArgs>
        fields: Prisma.AutomationRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          findFirst: {
            args: Prisma.AutomationRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          findMany: {
            args: Prisma.AutomationRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>[]
          }
          create: {
            args: Prisma.AutomationRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          createMany: {
            args: Prisma.AutomationRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>[]
          }
          delete: {
            args: Prisma.AutomationRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          update: {
            args: Prisma.AutomationRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          deleteMany: {
            args: Prisma.AutomationRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutomationRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>[]
          }
          upsert: {
            args: Prisma.AutomationRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          aggregate: {
            args: Prisma.AutomationRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationRule>
          }
          groupBy: {
            args: Prisma.AutomationRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationRuleCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationRuleCountAggregateOutputType> | number
          }
        }
      }
      CustomField: {
        payload: Prisma.$CustomFieldPayload<ExtArgs>
        fields: Prisma.CustomFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          findFirst: {
            args: Prisma.CustomFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          findMany: {
            args: Prisma.CustomFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>[]
          }
          create: {
            args: Prisma.CustomFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          createMany: {
            args: Prisma.CustomFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>[]
          }
          delete: {
            args: Prisma.CustomFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          update: {
            args: Prisma.CustomFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          deleteMany: {
            args: Prisma.CustomFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomFieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>[]
          }
          upsert: {
            args: Prisma.CustomFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          aggregate: {
            args: Prisma.CustomFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomField>
          }
          groupBy: {
            args: Prisma.CustomFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomFieldCountArgs<ExtArgs>
            result: $Utils.Optional<CustomFieldCountAggregateOutputType> | number
          }
        }
      }
      CustomFieldValue: {
        payload: Prisma.$CustomFieldValuePayload<ExtArgs>
        fields: Prisma.CustomFieldValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomFieldValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomFieldValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          findFirst: {
            args: Prisma.CustomFieldValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomFieldValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          findMany: {
            args: Prisma.CustomFieldValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>[]
          }
          create: {
            args: Prisma.CustomFieldValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          createMany: {
            args: Prisma.CustomFieldValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomFieldValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>[]
          }
          delete: {
            args: Prisma.CustomFieldValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          update: {
            args: Prisma.CustomFieldValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          deleteMany: {
            args: Prisma.CustomFieldValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomFieldValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomFieldValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>[]
          }
          upsert: {
            args: Prisma.CustomFieldValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          aggregate: {
            args: Prisma.CustomFieldValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomFieldValue>
          }
          groupBy: {
            args: Prisma.CustomFieldValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomFieldValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomFieldValueCountArgs<ExtArgs>
            result: $Utils.Optional<CustomFieldValueCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    team?: TeamOmit
    account?: AccountOmit
    contact?: ContactOmit
    deal?: DealOmit
    activity?: ActivityOmit
    emailAccount?: EmailAccountOmit
    emailTemplate?: EmailTemplateOmit
    emailMessage?: EmailMessageOmit
    emailInboxMessage?: EmailInboxMessageOmit
    emailContact?: EmailContactOmit
    documentTemplate?: DocumentTemplateOmit
    generatedDocument?: GeneratedDocumentOmit
    fileFolder?: FileFolderOmit
    file?: FileOmit
    settingOption?: SettingOptionOmit
    systemSetting?: SystemSettingOmit
    dealTag?: DealTagOmit
    contactTag?: ContactTagOmit
    tag?: TagOmit
    webhook?: WebhookOmit
    sharedAccess?: SharedAccessOmit
    automationRule?: AutomationRuleOmit
    customField?: CustomFieldOmit
    customFieldValue?: CustomFieldValueOmit
    auditLog?: AuditLogOmit
    comment?: CommentOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Account: number
    Contact: number
    Deal: number
    Activity: number
    EmailAccount: number
    EmailTemplate: number
    EmailMessage: number
    EmailInboxMessage: number
    EmailContact: number
    DocumentTemplate: number
    GeneratedDocument: number
    FileFolder: number
    File: number
    SharedAccess: number
    AuditLog: number
    Comment: number
    Notification: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | UserCountOutputTypeCountAccountArgs
    Contact?: boolean | UserCountOutputTypeCountContactArgs
    Deal?: boolean | UserCountOutputTypeCountDealArgs
    Activity?: boolean | UserCountOutputTypeCountActivityArgs
    EmailAccount?: boolean | UserCountOutputTypeCountEmailAccountArgs
    EmailTemplate?: boolean | UserCountOutputTypeCountEmailTemplateArgs
    EmailMessage?: boolean | UserCountOutputTypeCountEmailMessageArgs
    EmailInboxMessage?: boolean | UserCountOutputTypeCountEmailInboxMessageArgs
    EmailContact?: boolean | UserCountOutputTypeCountEmailContactArgs
    DocumentTemplate?: boolean | UserCountOutputTypeCountDocumentTemplateArgs
    GeneratedDocument?: boolean | UserCountOutputTypeCountGeneratedDocumentArgs
    FileFolder?: boolean | UserCountOutputTypeCountFileFolderArgs
    File?: boolean | UserCountOutputTypeCountFileArgs
    SharedAccess?: boolean | UserCountOutputTypeCountSharedAccessArgs
    AuditLog?: boolean | UserCountOutputTypeCountAuditLogArgs
    Comment?: boolean | UserCountOutputTypeCountCommentArgs
    Notification?: boolean | UserCountOutputTypeCountNotificationArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailInboxMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailInboxMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGeneratedDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFileFolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileFolderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedAccessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    users: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TeamCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    Contact: number
    Deal: number
    Activity: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Contact?: boolean | AccountCountOutputTypeCountContactArgs
    Deal?: boolean | AccountCountOutputTypeCountDealArgs
    Activity?: boolean | AccountCountOutputTypeCountActivityArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountDealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    Deal: number
    Activity: number
    ContactTag: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Deal?: boolean | ContactCountOutputTypeCountDealArgs
    Activity?: boolean | ContactCountOutputTypeCountActivityArgs
    ContactTag?: boolean | ContactCountOutputTypeCountContactTagArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountDealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountContactTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTagWhereInput
  }


  /**
   * Count Type DealCountOutputType
   */

  export type DealCountOutputType = {
    Activity: number
    DealTag: number
  }

  export type DealCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Activity?: boolean | DealCountOutputTypeCountActivityArgs
    DealTag?: boolean | DealCountOutputTypeCountDealTagArgs
  }

  // Custom InputTypes
  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealCountOutputType
     */
    select?: DealCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountDealTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealTagWhereInput
  }


  /**
   * Count Type ActivityCountOutputType
   */

  export type ActivityCountOutputType = {
    subtasks: number
    tags: number
  }

  export type ActivityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtasks?: boolean | ActivityCountOutputTypeCountSubtasksArgs
    tags?: boolean | ActivityCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCountOutputType
     */
    select?: ActivityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * Count Type EmailTemplateCountOutputType
   */

  export type EmailTemplateCountOutputType = {
    EmailMessage: number
  }

  export type EmailTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmailMessage?: boolean | EmailTemplateCountOutputTypeCountEmailMessageArgs
  }

  // Custom InputTypes
  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplateCountOutputType
     */
    select?: EmailTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountEmailMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailMessageWhereInput
  }


  /**
   * Count Type DocumentTemplateCountOutputType
   */

  export type DocumentTemplateCountOutputType = {
    GeneratedDocument: number
  }

  export type DocumentTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    GeneratedDocument?: boolean | DocumentTemplateCountOutputTypeCountGeneratedDocumentArgs
  }

  // Custom InputTypes
  /**
   * DocumentTemplateCountOutputType without action
   */
  export type DocumentTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTemplateCountOutputType
     */
    select?: DocumentTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentTemplateCountOutputType without action
   */
  export type DocumentTemplateCountOutputTypeCountGeneratedDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedDocumentWhereInput
  }


  /**
   * Count Type FileFolderCountOutputType
   */

  export type FileFolderCountOutputType = {
    files: number
  }

  export type FileFolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | FileFolderCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * FileFolderCountOutputType without action
   */
  export type FileFolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolderCountOutputType
     */
    select?: FileFolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileFolderCountOutputType without action
   */
  export type FileFolderCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    DealTags: number
    ContactTags: number
    activities: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DealTags?: boolean | TagCountOutputTypeCountDealTagsArgs
    ContactTags?: boolean | TagCountOutputTypeCountContactTagsArgs
    activities?: boolean | TagCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountDealTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountContactTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }


  /**
   * Count Type CustomFieldCountOutputType
   */

  export type CustomFieldCountOutputType = {
    values: number
  }

  export type CustomFieldCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | CustomFieldCountOutputTypeCountValuesArgs
  }

  // Custom InputTypes
  /**
   * CustomFieldCountOutputType without action
   */
  export type CustomFieldCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldCountOutputType
     */
    select?: CustomFieldCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomFieldCountOutputType without action
   */
  export type CustomFieldCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldValueWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    files: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | CommentCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    telegramId: string | null
    notificationsEnabled: boolean | null
    roleId: string | null
    createdAt: Date | null
    teamId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    telegramId: string | null
    notificationsEnabled: boolean | null
    roleId: string | null
    createdAt: Date | null
    teamId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    telegramId: number
    notificationsEnabled: number
    roleId: number
    createdAt: number
    teamId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    telegramId?: true
    notificationsEnabled?: true
    roleId?: true
    createdAt?: true
    teamId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    telegramId?: true
    notificationsEnabled?: true
    roleId?: true
    createdAt?: true
    teamId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    telegramId?: true
    notificationsEnabled?: true
    roleId?: true
    createdAt?: true
    teamId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    telegramId: string | null
    notificationsEnabled: boolean
    roleId: string
    createdAt: Date
    teamId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    telegramId?: boolean
    notificationsEnabled?: boolean
    roleId?: boolean
    createdAt?: boolean
    teamId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    team?: boolean | User$teamArgs<ExtArgs>
    Account?: boolean | User$AccountArgs<ExtArgs>
    Contact?: boolean | User$ContactArgs<ExtArgs>
    Deal?: boolean | User$DealArgs<ExtArgs>
    Activity?: boolean | User$ActivityArgs<ExtArgs>
    EmailAccount?: boolean | User$EmailAccountArgs<ExtArgs>
    EmailTemplate?: boolean | User$EmailTemplateArgs<ExtArgs>
    EmailMessage?: boolean | User$EmailMessageArgs<ExtArgs>
    EmailInboxMessage?: boolean | User$EmailInboxMessageArgs<ExtArgs>
    EmailContact?: boolean | User$EmailContactArgs<ExtArgs>
    DocumentTemplate?: boolean | User$DocumentTemplateArgs<ExtArgs>
    GeneratedDocument?: boolean | User$GeneratedDocumentArgs<ExtArgs>
    FileFolder?: boolean | User$FileFolderArgs<ExtArgs>
    File?: boolean | User$FileArgs<ExtArgs>
    SharedAccess?: boolean | User$SharedAccessArgs<ExtArgs>
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    telegramId?: boolean
    notificationsEnabled?: boolean
    roleId?: boolean
    createdAt?: boolean
    teamId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    team?: boolean | User$teamArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    telegramId?: boolean
    notificationsEnabled?: boolean
    roleId?: boolean
    createdAt?: boolean
    teamId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    team?: boolean | User$teamArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    telegramId?: boolean
    notificationsEnabled?: boolean
    roleId?: boolean
    createdAt?: boolean
    teamId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "telegramId" | "notificationsEnabled" | "roleId" | "createdAt" | "teamId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    team?: boolean | User$teamArgs<ExtArgs>
    Account?: boolean | User$AccountArgs<ExtArgs>
    Contact?: boolean | User$ContactArgs<ExtArgs>
    Deal?: boolean | User$DealArgs<ExtArgs>
    Activity?: boolean | User$ActivityArgs<ExtArgs>
    EmailAccount?: boolean | User$EmailAccountArgs<ExtArgs>
    EmailTemplate?: boolean | User$EmailTemplateArgs<ExtArgs>
    EmailMessage?: boolean | User$EmailMessageArgs<ExtArgs>
    EmailInboxMessage?: boolean | User$EmailInboxMessageArgs<ExtArgs>
    EmailContact?: boolean | User$EmailContactArgs<ExtArgs>
    DocumentTemplate?: boolean | User$DocumentTemplateArgs<ExtArgs>
    GeneratedDocument?: boolean | User$GeneratedDocumentArgs<ExtArgs>
    FileFolder?: boolean | User$FileFolderArgs<ExtArgs>
    File?: boolean | User$FileArgs<ExtArgs>
    SharedAccess?: boolean | User$SharedAccessArgs<ExtArgs>
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    team?: boolean | User$teamArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    team?: boolean | User$teamArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs> | null
      Account: Prisma.$AccountPayload<ExtArgs>[]
      Contact: Prisma.$ContactPayload<ExtArgs>[]
      Deal: Prisma.$DealPayload<ExtArgs>[]
      Activity: Prisma.$ActivityPayload<ExtArgs>[]
      EmailAccount: Prisma.$EmailAccountPayload<ExtArgs>[]
      EmailTemplate: Prisma.$EmailTemplatePayload<ExtArgs>[]
      EmailMessage: Prisma.$EmailMessagePayload<ExtArgs>[]
      EmailInboxMessage: Prisma.$EmailInboxMessagePayload<ExtArgs>[]
      EmailContact: Prisma.$EmailContactPayload<ExtArgs>[]
      DocumentTemplate: Prisma.$DocumentTemplatePayload<ExtArgs>[]
      GeneratedDocument: Prisma.$GeneratedDocumentPayload<ExtArgs>[]
      FileFolder: Prisma.$FileFolderPayload<ExtArgs>[]
      File: Prisma.$FilePayload<ExtArgs>[]
      SharedAccess: Prisma.$SharedAccessPayload<ExtArgs>[]
      AuditLog: Prisma.$AuditLogPayload<ExtArgs>[]
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      telegramId: string | null
      notificationsEnabled: boolean
      roleId: string
      createdAt: Date
      teamId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends User$teamArgs<ExtArgs> = {}>(args?: Subset<T, User$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Account<T extends User$AccountArgs<ExtArgs> = {}>(args?: Subset<T, User$AccountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Contact<T extends User$ContactArgs<ExtArgs> = {}>(args?: Subset<T, User$ContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Deal<T extends User$DealArgs<ExtArgs> = {}>(args?: Subset<T, User$DealArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Activity<T extends User$ActivityArgs<ExtArgs> = {}>(args?: Subset<T, User$ActivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    EmailAccount<T extends User$EmailAccountArgs<ExtArgs> = {}>(args?: Subset<T, User$EmailAccountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    EmailTemplate<T extends User$EmailTemplateArgs<ExtArgs> = {}>(args?: Subset<T, User$EmailTemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    EmailMessage<T extends User$EmailMessageArgs<ExtArgs> = {}>(args?: Subset<T, User$EmailMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    EmailInboxMessage<T extends User$EmailInboxMessageArgs<ExtArgs> = {}>(args?: Subset<T, User$EmailInboxMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailInboxMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    EmailContact<T extends User$EmailContactArgs<ExtArgs> = {}>(args?: Subset<T, User$EmailContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DocumentTemplate<T extends User$DocumentTemplateArgs<ExtArgs> = {}>(args?: Subset<T, User$DocumentTemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GeneratedDocument<T extends User$GeneratedDocumentArgs<ExtArgs> = {}>(args?: Subset<T, User$GeneratedDocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FileFolder<T extends User$FileFolderArgs<ExtArgs> = {}>(args?: Subset<T, User$FileFolderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    File<T extends User$FileArgs<ExtArgs> = {}>(args?: Subset<T, User$FileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SharedAccess<T extends User$SharedAccessArgs<ExtArgs> = {}>(args?: Subset<T, User$SharedAccessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AuditLog<T extends User$AuditLogArgs<ExtArgs> = {}>(args?: Subset<T, User$AuditLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Comment<T extends User$CommentArgs<ExtArgs> = {}>(args?: Subset<T, User$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notification<T extends User$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly telegramId: FieldRef<"User", 'String'>
    readonly notificationsEnabled: FieldRef<"User", 'Boolean'>
    readonly roleId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly teamId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.team
   */
  export type User$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * User.Account
   */
  export type User$AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.Contact
   */
  export type User$ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * User.Deal
   */
  export type User$DealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * User.Activity
   */
  export type User$ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.EmailAccount
   */
  export type User$EmailAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    where?: EmailAccountWhereInput
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    cursor?: EmailAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailAccountScalarFieldEnum | EmailAccountScalarFieldEnum[]
  }

  /**
   * User.EmailTemplate
   */
  export type User$EmailTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    cursor?: EmailTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * User.EmailMessage
   */
  export type User$EmailMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    where?: EmailMessageWhereInput
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    cursor?: EmailMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }

  /**
   * User.EmailInboxMessage
   */
  export type User$EmailInboxMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailInboxMessage
     */
    select?: EmailInboxMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailInboxMessage
     */
    omit?: EmailInboxMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInboxMessageInclude<ExtArgs> | null
    where?: EmailInboxMessageWhereInput
    orderBy?: EmailInboxMessageOrderByWithRelationInput | EmailInboxMessageOrderByWithRelationInput[]
    cursor?: EmailInboxMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailInboxMessageScalarFieldEnum | EmailInboxMessageScalarFieldEnum[]
  }

  /**
   * User.EmailContact
   */
  export type User$EmailContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    where?: EmailContactWhereInput
    orderBy?: EmailContactOrderByWithRelationInput | EmailContactOrderByWithRelationInput[]
    cursor?: EmailContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailContactScalarFieldEnum | EmailContactScalarFieldEnum[]
  }

  /**
   * User.DocumentTemplate
   */
  export type User$DocumentTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTemplate
     */
    select?: DocumentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTemplate
     */
    omit?: DocumentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTemplateInclude<ExtArgs> | null
    where?: DocumentTemplateWhereInput
    orderBy?: DocumentTemplateOrderByWithRelationInput | DocumentTemplateOrderByWithRelationInput[]
    cursor?: DocumentTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentTemplateScalarFieldEnum | DocumentTemplateScalarFieldEnum[]
  }

  /**
   * User.GeneratedDocument
   */
  export type User$GeneratedDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedDocument
     */
    select?: GeneratedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedDocument
     */
    omit?: GeneratedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedDocumentInclude<ExtArgs> | null
    where?: GeneratedDocumentWhereInput
    orderBy?: GeneratedDocumentOrderByWithRelationInput | GeneratedDocumentOrderByWithRelationInput[]
    cursor?: GeneratedDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedDocumentScalarFieldEnum | GeneratedDocumentScalarFieldEnum[]
  }

  /**
   * User.FileFolder
   */
  export type User$FileFolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileFolder
     */
    omit?: FileFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    where?: FileFolderWhereInput
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    cursor?: FileFolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileFolderScalarFieldEnum | FileFolderScalarFieldEnum[]
  }

  /**
   * User.File
   */
  export type User$FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * User.SharedAccess
   */
  export type User$SharedAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccess
     */
    select?: SharedAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccess
     */
    omit?: SharedAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccessInclude<ExtArgs> | null
    where?: SharedAccessWhereInput
    orderBy?: SharedAccessOrderByWithRelationInput | SharedAccessOrderByWithRelationInput[]
    cursor?: SharedAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharedAccessScalarFieldEnum | SharedAccessScalarFieldEnum[]
  }

  /**
   * User.AuditLog
   */
  export type User$AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.Comment
   */
  export type User$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.Notification
   */
  export type User$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean | Team$usersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Team$usersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Team$usersArgs<ExtArgs> = {}>(args?: Subset<T, Team$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.users
   */
  export type Team$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    name: string | null
    industry: string | null
    phone: string | null
    email: string | null
    website: string | null
    address: string | null
    ownerId: string | null
    createdAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    name: string | null
    industry: string | null
    phone: string | null
    email: string | null
    website: string | null
    address: string | null
    ownerId: string | null
    createdAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    name: number
    industry: number
    phone: number
    email: number
    website: number
    address: number
    ownerId: number
    createdAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    name?: true
    industry?: true
    phone?: true
    email?: true
    website?: true
    address?: true
    ownerId?: true
    createdAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    name?: true
    industry?: true
    phone?: true
    email?: true
    website?: true
    address?: true
    ownerId?: true
    createdAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    name?: true
    industry?: true
    phone?: true
    email?: true
    website?: true
    address?: true
    ownerId?: true
    createdAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    name: string
    industry: string | null
    phone: string | null
    email: string | null
    website: string | null
    address: string | null
    ownerId: string
    createdAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    industry?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    address?: boolean
    ownerId?: boolean
    createdAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    Contact?: boolean | Account$ContactArgs<ExtArgs>
    Deal?: boolean | Account$DealArgs<ExtArgs>
    Activity?: boolean | Account$ActivityArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    industry?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    address?: boolean
    ownerId?: boolean
    createdAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    industry?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    address?: boolean
    ownerId?: boolean
    createdAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    name?: boolean
    industry?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    address?: boolean
    ownerId?: boolean
    createdAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "industry" | "phone" | "email" | "website" | "address" | "ownerId" | "createdAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    Contact?: boolean | Account$ContactArgs<ExtArgs>
    Deal?: boolean | Account$DealArgs<ExtArgs>
    Activity?: boolean | Account$ActivityArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      Contact: Prisma.$ContactPayload<ExtArgs>[]
      Deal: Prisma.$DealPayload<ExtArgs>[]
      Activity: Prisma.$ActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      industry: string | null
      phone: string | null
      email: string | null
      website: string | null
      address: string | null
      ownerId: string
      createdAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Contact<T extends Account$ContactArgs<ExtArgs> = {}>(args?: Subset<T, Account$ContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Deal<T extends Account$DealArgs<ExtArgs> = {}>(args?: Subset<T, Account$DealArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Activity<T extends Account$ActivityArgs<ExtArgs> = {}>(args?: Subset<T, Account$ActivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly industry: FieldRef<"Account", 'String'>
    readonly phone: FieldRef<"Account", 'String'>
    readonly email: FieldRef<"Account", 'String'>
    readonly website: FieldRef<"Account", 'String'>
    readonly address: FieldRef<"Account", 'String'>
    readonly ownerId: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account.Contact
   */
  export type Account$ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Account.Deal
   */
  export type Account$DealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Account.Activity
   */
  export type Account$ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    position: string | null
    ownerId: string | null
    accountId: string | null
    createdAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    position: string | null
    ownerId: string | null
    accountId: string | null
    createdAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    position: number
    ownerId: number
    accountId: number
    createdAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    position?: true
    ownerId?: true
    accountId?: true
    createdAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    position?: true
    ownerId?: true
    accountId?: true
    createdAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    position?: true
    ownerId?: true
    accountId?: true
    createdAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string | null
    phone: string | null
    position: string | null
    ownerId: string
    accountId: string | null
    createdAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    ownerId?: boolean
    accountId?: boolean
    createdAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | Contact$accountArgs<ExtArgs>
    Deal?: boolean | Contact$DealArgs<ExtArgs>
    Activity?: boolean | Contact$ActivityArgs<ExtArgs>
    ContactTag?: boolean | Contact$ContactTagArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    ownerId?: boolean
    accountId?: boolean
    createdAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | Contact$accountArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    ownerId?: boolean
    accountId?: boolean
    createdAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | Contact$accountArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    ownerId?: boolean
    accountId?: boolean
    createdAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "email" | "phone" | "position" | "ownerId" | "accountId" | "createdAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | Contact$accountArgs<ExtArgs>
    Deal?: boolean | Contact$DealArgs<ExtArgs>
    Activity?: boolean | Contact$ActivityArgs<ExtArgs>
    ContactTag?: boolean | Contact$ContactTagArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | Contact$accountArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | Contact$accountArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs> | null
      Deal: Prisma.$DealPayload<ExtArgs>[]
      Activity: Prisma.$ActivityPayload<ExtArgs>[]
      ContactTag: Prisma.$ContactTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      email: string | null
      phone: string | null
      position: string | null
      ownerId: string
      accountId: string | null
      createdAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends Contact$accountArgs<ExtArgs> = {}>(args?: Subset<T, Contact$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Deal<T extends Contact$DealArgs<ExtArgs> = {}>(args?: Subset<T, Contact$DealArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Activity<T extends Contact$ActivityArgs<ExtArgs> = {}>(args?: Subset<T, Contact$ActivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ContactTag<T extends Contact$ContactTagArgs<ExtArgs> = {}>(args?: Subset<T, Contact$ContactTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly firstName: FieldRef<"Contact", 'String'>
    readonly lastName: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly position: FieldRef<"Contact", 'String'>
    readonly ownerId: FieldRef<"Contact", 'String'>
    readonly accountId: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.account
   */
  export type Contact$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Contact.Deal
   */
  export type Contact$DealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Contact.Activity
   */
  export type Contact$ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Contact.ContactTag
   */
  export type Contact$ContactTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    where?: ContactTagWhereInput
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    cursor?: ContactTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Deal
   */

  export type AggregateDeal = {
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  export type DealAvgAggregateOutputType = {
    amount: number | null
    probability: number | null
  }

  export type DealSumAggregateOutputType = {
    amount: number | null
    probability: number | null
  }

  export type DealMinAggregateOutputType = {
    id: string | null
    title: string | null
    amount: number | null
    stage: string | null
    probability: number | null
    closeDate: Date | null
    accountId: string | null
    contactId: string | null
    ownerId: string | null
    createdAt: Date | null
  }

  export type DealMaxAggregateOutputType = {
    id: string | null
    title: string | null
    amount: number | null
    stage: string | null
    probability: number | null
    closeDate: Date | null
    accountId: string | null
    contactId: string | null
    ownerId: string | null
    createdAt: Date | null
  }

  export type DealCountAggregateOutputType = {
    id: number
    title: number
    amount: number
    stage: number
    probability: number
    closeDate: number
    accountId: number
    contactId: number
    ownerId: number
    createdAt: number
    _all: number
  }


  export type DealAvgAggregateInputType = {
    amount?: true
    probability?: true
  }

  export type DealSumAggregateInputType = {
    amount?: true
    probability?: true
  }

  export type DealMinAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    stage?: true
    probability?: true
    closeDate?: true
    accountId?: true
    contactId?: true
    ownerId?: true
    createdAt?: true
  }

  export type DealMaxAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    stage?: true
    probability?: true
    closeDate?: true
    accountId?: true
    contactId?: true
    ownerId?: true
    createdAt?: true
  }

  export type DealCountAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    stage?: true
    probability?: true
    closeDate?: true
    accountId?: true
    contactId?: true
    ownerId?: true
    createdAt?: true
    _all?: true
  }

  export type DealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deal to aggregate.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deals
    **/
    _count?: true | DealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealMaxAggregateInputType
  }

  export type GetDealAggregateType<T extends DealAggregateArgs> = {
        [P in keyof T & keyof AggregateDeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeal[P]>
      : GetScalarType<T[P], AggregateDeal[P]>
  }




  export type DealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
    orderBy?: DealOrderByWithAggregationInput | DealOrderByWithAggregationInput[]
    by: DealScalarFieldEnum[] | DealScalarFieldEnum
    having?: DealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealCountAggregateInputType | true
    _avg?: DealAvgAggregateInputType
    _sum?: DealSumAggregateInputType
    _min?: DealMinAggregateInputType
    _max?: DealMaxAggregateInputType
  }

  export type DealGroupByOutputType = {
    id: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date
    accountId: string | null
    contactId: string | null
    ownerId: string
    createdAt: Date
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  type GetDealGroupByPayload<T extends DealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealGroupByOutputType[P]>
            : GetScalarType<T[P], DealGroupByOutputType[P]>
        }
      >
    >


  export type DealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    amount?: boolean
    stage?: boolean
    probability?: boolean
    closeDate?: boolean
    accountId?: boolean
    contactId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    account?: boolean | Deal$accountArgs<ExtArgs>
    contact?: boolean | Deal$contactArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    Activity?: boolean | Deal$ActivityArgs<ExtArgs>
    DealTag?: boolean | Deal$DealTagArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    amount?: boolean
    stage?: boolean
    probability?: boolean
    closeDate?: boolean
    accountId?: boolean
    contactId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    account?: boolean | Deal$accountArgs<ExtArgs>
    contact?: boolean | Deal$contactArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    amount?: boolean
    stage?: boolean
    probability?: boolean
    closeDate?: boolean
    accountId?: boolean
    contactId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    account?: boolean | Deal$accountArgs<ExtArgs>
    contact?: boolean | Deal$contactArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectScalar = {
    id?: boolean
    title?: boolean
    amount?: boolean
    stage?: boolean
    probability?: boolean
    closeDate?: boolean
    accountId?: boolean
    contactId?: boolean
    ownerId?: boolean
    createdAt?: boolean
  }

  export type DealOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "amount" | "stage" | "probability" | "closeDate" | "accountId" | "contactId" | "ownerId" | "createdAt", ExtArgs["result"]["deal"]>
  export type DealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Deal$accountArgs<ExtArgs>
    contact?: boolean | Deal$contactArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    Activity?: boolean | Deal$ActivityArgs<ExtArgs>
    DealTag?: boolean | Deal$DealTagArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DealIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Deal$accountArgs<ExtArgs>
    contact?: boolean | Deal$contactArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DealIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Deal$accountArgs<ExtArgs>
    contact?: boolean | Deal$contactArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deal"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
      owner: Prisma.$UserPayload<ExtArgs>
      Activity: Prisma.$ActivityPayload<ExtArgs>[]
      DealTag: Prisma.$DealTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      amount: number
      stage: string
      probability: number
      closeDate: Date
      accountId: string | null
      contactId: string | null
      ownerId: string
      createdAt: Date
    }, ExtArgs["result"]["deal"]>
    composites: {}
  }

  type DealGetPayload<S extends boolean | null | undefined | DealDefaultArgs> = $Result.GetResult<Prisma.$DealPayload, S>

  type DealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DealFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DealCountAggregateInputType | true
    }

  export interface DealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deal'], meta: { name: 'Deal' } }
    /**
     * Find zero or one Deal that matches the filter.
     * @param {DealFindUniqueArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DealFindUniqueArgs>(args: SelectSubset<T, DealFindUniqueArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DealFindUniqueOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DealFindUniqueOrThrowArgs>(args: SelectSubset<T, DealFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DealFindFirstArgs>(args?: SelectSubset<T, DealFindFirstArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DealFindFirstOrThrowArgs>(args?: SelectSubset<T, DealFindFirstOrThrowArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deals
     * const deals = await prisma.deal.findMany()
     * 
     * // Get first 10 Deals
     * const deals = await prisma.deal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealWithIdOnly = await prisma.deal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DealFindManyArgs>(args?: SelectSubset<T, DealFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deal.
     * @param {DealCreateArgs} args - Arguments to create a Deal.
     * @example
     * // Create one Deal
     * const Deal = await prisma.deal.create({
     *   data: {
     *     // ... data to create a Deal
     *   }
     * })
     * 
     */
    create<T extends DealCreateArgs>(args: SelectSubset<T, DealCreateArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deals.
     * @param {DealCreateManyArgs} args - Arguments to create many Deals.
     * @example
     * // Create many Deals
     * const deal = await prisma.deal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DealCreateManyArgs>(args?: SelectSubset<T, DealCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deals and returns the data saved in the database.
     * @param {DealCreateManyAndReturnArgs} args - Arguments to create many Deals.
     * @example
     * // Create many Deals
     * const deal = await prisma.deal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deals and only return the `id`
     * const dealWithIdOnly = await prisma.deal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DealCreateManyAndReturnArgs>(args?: SelectSubset<T, DealCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Deal.
     * @param {DealDeleteArgs} args - Arguments to delete one Deal.
     * @example
     * // Delete one Deal
     * const Deal = await prisma.deal.delete({
     *   where: {
     *     // ... filter to delete one Deal
     *   }
     * })
     * 
     */
    delete<T extends DealDeleteArgs>(args: SelectSubset<T, DealDeleteArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deal.
     * @param {DealUpdateArgs} args - Arguments to update one Deal.
     * @example
     * // Update one Deal
     * const deal = await prisma.deal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DealUpdateArgs>(args: SelectSubset<T, DealUpdateArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deals.
     * @param {DealDeleteManyArgs} args - Arguments to filter Deals to delete.
     * @example
     * // Delete a few Deals
     * const { count } = await prisma.deal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DealDeleteManyArgs>(args?: SelectSubset<T, DealDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deals
     * const deal = await prisma.deal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DealUpdateManyArgs>(args: SelectSubset<T, DealUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deals and returns the data updated in the database.
     * @param {DealUpdateManyAndReturnArgs} args - Arguments to update many Deals.
     * @example
     * // Update many Deals
     * const deal = await prisma.deal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deals and only return the `id`
     * const dealWithIdOnly = await prisma.deal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DealUpdateManyAndReturnArgs>(args: SelectSubset<T, DealUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Deal.
     * @param {DealUpsertArgs} args - Arguments to update or create a Deal.
     * @example
     * // Update or create a Deal
     * const deal = await prisma.deal.upsert({
     *   create: {
     *     // ... data to create a Deal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deal we want to update
     *   }
     * })
     */
    upsert<T extends DealUpsertArgs>(args: SelectSubset<T, DealUpsertArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealCountArgs} args - Arguments to filter Deals to count.
     * @example
     * // Count the number of Deals
     * const count = await prisma.deal.count({
     *   where: {
     *     // ... the filter for the Deals we want to count
     *   }
     * })
    **/
    count<T extends DealCountArgs>(
      args?: Subset<T, DealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealAggregateArgs>(args: Subset<T, DealAggregateArgs>): Prisma.PrismaPromise<GetDealAggregateType<T>>

    /**
     * Group by Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealGroupByArgs['orderBy'] }
        : { orderBy?: DealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deal model
   */
  readonly fields: DealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends Deal$accountArgs<ExtArgs> = {}>(args?: Subset<T, Deal$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contact<T extends Deal$contactArgs<ExtArgs> = {}>(args?: Subset<T, Deal$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Activity<T extends Deal$ActivityArgs<ExtArgs> = {}>(args?: Subset<T, Deal$ActivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DealTag<T extends Deal$DealTagArgs<ExtArgs> = {}>(args?: Subset<T, Deal$DealTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deal model
   */
  interface DealFieldRefs {
    readonly id: FieldRef<"Deal", 'String'>
    readonly title: FieldRef<"Deal", 'String'>
    readonly amount: FieldRef<"Deal", 'Float'>
    readonly stage: FieldRef<"Deal", 'String'>
    readonly probability: FieldRef<"Deal", 'Int'>
    readonly closeDate: FieldRef<"Deal", 'DateTime'>
    readonly accountId: FieldRef<"Deal", 'String'>
    readonly contactId: FieldRef<"Deal", 'String'>
    readonly ownerId: FieldRef<"Deal", 'String'>
    readonly createdAt: FieldRef<"Deal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Deal findUnique
   */
  export type DealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal findUniqueOrThrow
   */
  export type DealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal findFirst
   */
  export type DealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal findFirstOrThrow
   */
  export type DealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal findMany
   */
  export type DealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deals to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal create
   */
  export type DealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to create a Deal.
     */
    data: XOR<DealCreateInput, DealUncheckedCreateInput>
  }

  /**
   * Deal createMany
   */
  export type DealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deal createManyAndReturn
   */
  export type DealCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deal update
   */
  export type DealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to update a Deal.
     */
    data: XOR<DealUpdateInput, DealUncheckedUpdateInput>
    /**
     * Choose, which Deal to update.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal updateMany
   */
  export type DealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deals.
     */
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyInput>
    /**
     * Filter which Deals to update
     */
    where?: DealWhereInput
    /**
     * Limit how many Deals to update.
     */
    limit?: number
  }

  /**
   * Deal updateManyAndReturn
   */
  export type DealUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * The data used to update Deals.
     */
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyInput>
    /**
     * Filter which Deals to update
     */
    where?: DealWhereInput
    /**
     * Limit how many Deals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deal upsert
   */
  export type DealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The filter to search for the Deal to update in case it exists.
     */
    where: DealWhereUniqueInput
    /**
     * In case the Deal found by the `where` argument doesn't exist, create a new Deal with this data.
     */
    create: XOR<DealCreateInput, DealUncheckedCreateInput>
    /**
     * In case the Deal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealUpdateInput, DealUncheckedUpdateInput>
  }

  /**
   * Deal delete
   */
  export type DealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter which Deal to delete.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal deleteMany
   */
  export type DealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deals to delete
     */
    where?: DealWhereInput
    /**
     * Limit how many Deals to delete.
     */
    limit?: number
  }

  /**
   * Deal.account
   */
  export type Deal$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Deal.contact
   */
  export type Deal$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Deal.Activity
   */
  export type Deal$ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Deal.DealTag
   */
  export type Deal$DealTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealTag
     */
    select?: DealTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealTag
     */
    omit?: DealTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealTagInclude<ExtArgs> | null
    where?: DealTagWhereInput
    orderBy?: DealTagOrderByWithRelationInput | DealTagOrderByWithRelationInput[]
    cursor?: DealTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealTagScalarFieldEnum | DealTagScalarFieldEnum[]
  }

  /**
   * Deal without action
   */
  export type DealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    title: string | null
    type: string | null
    status: string | null
    description: string | null
    date: Date | null
    ownerId: string | null
    accountId: string | null
    contactId: string | null
    dealId: string | null
    parentId: string | null
    createdAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    title: string | null
    type: string | null
    status: string | null
    description: string | null
    date: Date | null
    ownerId: string | null
    accountId: string | null
    contactId: string | null
    dealId: string | null
    parentId: string | null
    createdAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    title: number
    type: number
    status: number
    description: number
    date: number
    ownerId: number
    accountId: number
    contactId: number
    dealId: number
    parentId: number
    createdAt: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    status?: true
    description?: true
    date?: true
    ownerId?: true
    accountId?: true
    contactId?: true
    dealId?: true
    parentId?: true
    createdAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    status?: true
    description?: true
    date?: true
    ownerId?: true
    accountId?: true
    contactId?: true
    dealId?: true
    parentId?: true
    createdAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    status?: true
    description?: true
    date?: true
    ownerId?: true
    accountId?: true
    contactId?: true
    dealId?: true
    parentId?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    title: string
    type: string
    status: string
    description: string | null
    date: Date
    ownerId: string
    accountId: string | null
    contactId: string | null
    dealId: string | null
    parentId: string | null
    createdAt: Date
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    date?: boolean
    ownerId?: boolean
    accountId?: boolean
    contactId?: boolean
    dealId?: boolean
    parentId?: boolean
    createdAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | Activity$accountArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
    parent?: boolean | Activity$parentArgs<ExtArgs>
    subtasks?: boolean | Activity$subtasksArgs<ExtArgs>
    tags?: boolean | Activity$tagsArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    date?: boolean
    ownerId?: boolean
    accountId?: boolean
    contactId?: boolean
    dealId?: boolean
    parentId?: boolean
    createdAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | Activity$accountArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
    parent?: boolean | Activity$parentArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    date?: boolean
    ownerId?: boolean
    accountId?: boolean
    contactId?: boolean
    dealId?: boolean
    parentId?: boolean
    createdAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | Activity$accountArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
    parent?: boolean | Activity$parentArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    title?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    date?: boolean
    ownerId?: boolean
    accountId?: boolean
    contactId?: boolean
    dealId?: boolean
    parentId?: boolean
    createdAt?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "type" | "status" | "description" | "date" | "ownerId" | "accountId" | "contactId" | "dealId" | "parentId" | "createdAt", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | Activity$accountArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
    parent?: boolean | Activity$parentArgs<ExtArgs>
    subtasks?: boolean | Activity$subtasksArgs<ExtArgs>
    tags?: boolean | Activity$tagsArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | Activity$accountArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
    parent?: boolean | Activity$parentArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | Activity$accountArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
    parent?: boolean | Activity$parentArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
      deal: Prisma.$DealPayload<ExtArgs> | null
      parent: Prisma.$ActivityPayload<ExtArgs> | null
      subtasks: Prisma.$ActivityPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      type: string
      status: string
      description: string | null
      date: Date
      ownerId: string
      accountId: string | null
      contactId: string | null
      dealId: string | null
      parentId: string | null
      createdAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends Activity$accountArgs<ExtArgs> = {}>(args?: Subset<T, Activity$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contact<T extends Activity$contactArgs<ExtArgs> = {}>(args?: Subset<T, Activity$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deal<T extends Activity$dealArgs<ExtArgs> = {}>(args?: Subset<T, Activity$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parent<T extends Activity$parentArgs<ExtArgs> = {}>(args?: Subset<T, Activity$parentArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subtasks<T extends Activity$subtasksArgs<ExtArgs> = {}>(args?: Subset<T, Activity$subtasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Activity$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Activity$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly title: FieldRef<"Activity", 'String'>
    readonly type: FieldRef<"Activity", 'String'>
    readonly status: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly date: FieldRef<"Activity", 'DateTime'>
    readonly ownerId: FieldRef<"Activity", 'String'>
    readonly accountId: FieldRef<"Activity", 'String'>
    readonly contactId: FieldRef<"Activity", 'String'>
    readonly dealId: FieldRef<"Activity", 'String'>
    readonly parentId: FieldRef<"Activity", 'String'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity.account
   */
  export type Activity$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Activity.contact
   */
  export type Activity$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Activity.deal
   */
  export type Activity$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Activity.parent
   */
  export type Activity$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
  }

  /**
   * Activity.subtasks
   */
  export type Activity$subtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity.tags
   */
  export type Activity$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model EmailAccount
   */

  export type AggregateEmailAccount = {
    _count: EmailAccountCountAggregateOutputType | null
    _avg: EmailAccountAvgAggregateOutputType | null
    _sum: EmailAccountSumAggregateOutputType | null
    _min: EmailAccountMinAggregateOutputType | null
    _max: EmailAccountMaxAggregateOutputType | null
  }

  export type EmailAccountAvgAggregateOutputType = {
    smtpPort: number | null
  }

  export type EmailAccountSumAggregateOutputType = {
    smtpPort: number | null
  }

  export type EmailAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    smtpHost: string | null
    smtpPort: number | null
    smtpSecure: boolean | null
    email: string | null
    password: string | null
    createdAt: Date | null
  }

  export type EmailAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    smtpHost: string | null
    smtpPort: number | null
    smtpSecure: boolean | null
    email: string | null
    password: string | null
    createdAt: Date | null
  }

  export type EmailAccountCountAggregateOutputType = {
    id: number
    userId: number
    smtpHost: number
    smtpPort: number
    smtpSecure: number
    email: number
    password: number
    createdAt: number
    _all: number
  }


  export type EmailAccountAvgAggregateInputType = {
    smtpPort?: true
  }

  export type EmailAccountSumAggregateInputType = {
    smtpPort?: true
  }

  export type EmailAccountMinAggregateInputType = {
    id?: true
    userId?: true
    smtpHost?: true
    smtpPort?: true
    smtpSecure?: true
    email?: true
    password?: true
    createdAt?: true
  }

  export type EmailAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    smtpHost?: true
    smtpPort?: true
    smtpSecure?: true
    email?: true
    password?: true
    createdAt?: true
  }

  export type EmailAccountCountAggregateInputType = {
    id?: true
    userId?: true
    smtpHost?: true
    smtpPort?: true
    smtpSecure?: true
    email?: true
    password?: true
    createdAt?: true
    _all?: true
  }

  export type EmailAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAccount to aggregate.
     */
    where?: EmailAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAccounts to fetch.
     */
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailAccounts
    **/
    _count?: true | EmailAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailAccountMaxAggregateInputType
  }

  export type GetEmailAccountAggregateType<T extends EmailAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailAccount[P]>
      : GetScalarType<T[P], AggregateEmailAccount[P]>
  }




  export type EmailAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAccountWhereInput
    orderBy?: EmailAccountOrderByWithAggregationInput | EmailAccountOrderByWithAggregationInput[]
    by: EmailAccountScalarFieldEnum[] | EmailAccountScalarFieldEnum
    having?: EmailAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailAccountCountAggregateInputType | true
    _avg?: EmailAccountAvgAggregateInputType
    _sum?: EmailAccountSumAggregateInputType
    _min?: EmailAccountMinAggregateInputType
    _max?: EmailAccountMaxAggregateInputType
  }

  export type EmailAccountGroupByOutputType = {
    id: string
    userId: string
    smtpHost: string
    smtpPort: number
    smtpSecure: boolean
    email: string
    password: string
    createdAt: Date
    _count: EmailAccountCountAggregateOutputType | null
    _avg: EmailAccountAvgAggregateOutputType | null
    _sum: EmailAccountSumAggregateOutputType | null
    _min: EmailAccountMinAggregateOutputType | null
    _max: EmailAccountMaxAggregateOutputType | null
  }

  type GetEmailAccountGroupByPayload<T extends EmailAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailAccountGroupByOutputType[P]>
            : GetScalarType<T[P], EmailAccountGroupByOutputType[P]>
        }
      >
    >


  export type EmailAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpSecure?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAccount"]>

  export type EmailAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpSecure?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAccount"]>

  export type EmailAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpSecure?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAccount"]>

  export type EmailAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpSecure?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
  }

  export type EmailAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "smtpHost" | "smtpPort" | "smtpSecure" | "email" | "password" | "createdAt", ExtArgs["result"]["emailAccount"]>
  export type EmailAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      smtpHost: string
      smtpPort: number
      smtpSecure: boolean
      email: string
      password: string
      createdAt: Date
    }, ExtArgs["result"]["emailAccount"]>
    composites: {}
  }

  type EmailAccountGetPayload<S extends boolean | null | undefined | EmailAccountDefaultArgs> = $Result.GetResult<Prisma.$EmailAccountPayload, S>

  type EmailAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailAccountCountAggregateInputType | true
    }

  export interface EmailAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailAccount'], meta: { name: 'EmailAccount' } }
    /**
     * Find zero or one EmailAccount that matches the filter.
     * @param {EmailAccountFindUniqueArgs} args - Arguments to find a EmailAccount
     * @example
     * // Get one EmailAccount
     * const emailAccount = await prisma.emailAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailAccountFindUniqueArgs>(args: SelectSubset<T, EmailAccountFindUniqueArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailAccountFindUniqueOrThrowArgs} args - Arguments to find a EmailAccount
     * @example
     * // Get one EmailAccount
     * const emailAccount = await prisma.emailAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountFindFirstArgs} args - Arguments to find a EmailAccount
     * @example
     * // Get one EmailAccount
     * const emailAccount = await prisma.emailAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailAccountFindFirstArgs>(args?: SelectSubset<T, EmailAccountFindFirstArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountFindFirstOrThrowArgs} args - Arguments to find a EmailAccount
     * @example
     * // Get one EmailAccount
     * const emailAccount = await prisma.emailAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailAccounts
     * const emailAccounts = await prisma.emailAccount.findMany()
     * 
     * // Get first 10 EmailAccounts
     * const emailAccounts = await prisma.emailAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailAccountWithIdOnly = await prisma.emailAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailAccountFindManyArgs>(args?: SelectSubset<T, EmailAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailAccount.
     * @param {EmailAccountCreateArgs} args - Arguments to create a EmailAccount.
     * @example
     * // Create one EmailAccount
     * const EmailAccount = await prisma.emailAccount.create({
     *   data: {
     *     // ... data to create a EmailAccount
     *   }
     * })
     * 
     */
    create<T extends EmailAccountCreateArgs>(args: SelectSubset<T, EmailAccountCreateArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailAccounts.
     * @param {EmailAccountCreateManyArgs} args - Arguments to create many EmailAccounts.
     * @example
     * // Create many EmailAccounts
     * const emailAccount = await prisma.emailAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailAccountCreateManyArgs>(args?: SelectSubset<T, EmailAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailAccounts and returns the data saved in the database.
     * @param {EmailAccountCreateManyAndReturnArgs} args - Arguments to create many EmailAccounts.
     * @example
     * // Create many EmailAccounts
     * const emailAccount = await prisma.emailAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailAccounts and only return the `id`
     * const emailAccountWithIdOnly = await prisma.emailAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailAccount.
     * @param {EmailAccountDeleteArgs} args - Arguments to delete one EmailAccount.
     * @example
     * // Delete one EmailAccount
     * const EmailAccount = await prisma.emailAccount.delete({
     *   where: {
     *     // ... filter to delete one EmailAccount
     *   }
     * })
     * 
     */
    delete<T extends EmailAccountDeleteArgs>(args: SelectSubset<T, EmailAccountDeleteArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailAccount.
     * @param {EmailAccountUpdateArgs} args - Arguments to update one EmailAccount.
     * @example
     * // Update one EmailAccount
     * const emailAccount = await prisma.emailAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailAccountUpdateArgs>(args: SelectSubset<T, EmailAccountUpdateArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailAccounts.
     * @param {EmailAccountDeleteManyArgs} args - Arguments to filter EmailAccounts to delete.
     * @example
     * // Delete a few EmailAccounts
     * const { count } = await prisma.emailAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailAccountDeleteManyArgs>(args?: SelectSubset<T, EmailAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailAccounts
     * const emailAccount = await prisma.emailAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailAccountUpdateManyArgs>(args: SelectSubset<T, EmailAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAccounts and returns the data updated in the database.
     * @param {EmailAccountUpdateManyAndReturnArgs} args - Arguments to update many EmailAccounts.
     * @example
     * // Update many EmailAccounts
     * const emailAccount = await prisma.emailAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailAccounts and only return the `id`
     * const emailAccountWithIdOnly = await prisma.emailAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailAccount.
     * @param {EmailAccountUpsertArgs} args - Arguments to update or create a EmailAccount.
     * @example
     * // Update or create a EmailAccount
     * const emailAccount = await prisma.emailAccount.upsert({
     *   create: {
     *     // ... data to create a EmailAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailAccount we want to update
     *   }
     * })
     */
    upsert<T extends EmailAccountUpsertArgs>(args: SelectSubset<T, EmailAccountUpsertArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountCountArgs} args - Arguments to filter EmailAccounts to count.
     * @example
     * // Count the number of EmailAccounts
     * const count = await prisma.emailAccount.count({
     *   where: {
     *     // ... the filter for the EmailAccounts we want to count
     *   }
     * })
    **/
    count<T extends EmailAccountCountArgs>(
      args?: Subset<T, EmailAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAccountAggregateArgs>(args: Subset<T, EmailAccountAggregateArgs>): Prisma.PrismaPromise<GetEmailAccountAggregateType<T>>

    /**
     * Group by EmailAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailAccountGroupByArgs['orderBy'] }
        : { orderBy?: EmailAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailAccount model
   */
  readonly fields: EmailAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailAccount model
   */
  interface EmailAccountFieldRefs {
    readonly id: FieldRef<"EmailAccount", 'String'>
    readonly userId: FieldRef<"EmailAccount", 'String'>
    readonly smtpHost: FieldRef<"EmailAccount", 'String'>
    readonly smtpPort: FieldRef<"EmailAccount", 'Int'>
    readonly smtpSecure: FieldRef<"EmailAccount", 'Boolean'>
    readonly email: FieldRef<"EmailAccount", 'String'>
    readonly password: FieldRef<"EmailAccount", 'String'>
    readonly createdAt: FieldRef<"EmailAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailAccount findUnique
   */
  export type EmailAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccount to fetch.
     */
    where: EmailAccountWhereUniqueInput
  }

  /**
   * EmailAccount findUniqueOrThrow
   */
  export type EmailAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccount to fetch.
     */
    where: EmailAccountWhereUniqueInput
  }

  /**
   * EmailAccount findFirst
   */
  export type EmailAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccount to fetch.
     */
    where?: EmailAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAccounts to fetch.
     */
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAccounts.
     */
    cursor?: EmailAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAccounts.
     */
    distinct?: EmailAccountScalarFieldEnum | EmailAccountScalarFieldEnum[]
  }

  /**
   * EmailAccount findFirstOrThrow
   */
  export type EmailAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccount to fetch.
     */
    where?: EmailAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAccounts to fetch.
     */
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAccounts.
     */
    cursor?: EmailAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAccounts.
     */
    distinct?: EmailAccountScalarFieldEnum | EmailAccountScalarFieldEnum[]
  }

  /**
   * EmailAccount findMany
   */
  export type EmailAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccounts to fetch.
     */
    where?: EmailAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAccounts to fetch.
     */
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailAccounts.
     */
    cursor?: EmailAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAccounts.
     */
    skip?: number
    distinct?: EmailAccountScalarFieldEnum | EmailAccountScalarFieldEnum[]
  }

  /**
   * EmailAccount create
   */
  export type EmailAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailAccount.
     */
    data: XOR<EmailAccountCreateInput, EmailAccountUncheckedCreateInput>
  }

  /**
   * EmailAccount createMany
   */
  export type EmailAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailAccounts.
     */
    data: EmailAccountCreateManyInput | EmailAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailAccount createManyAndReturn
   */
  export type EmailAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * The data used to create many EmailAccounts.
     */
    data: EmailAccountCreateManyInput | EmailAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAccount update
   */
  export type EmailAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailAccount.
     */
    data: XOR<EmailAccountUpdateInput, EmailAccountUncheckedUpdateInput>
    /**
     * Choose, which EmailAccount to update.
     */
    where: EmailAccountWhereUniqueInput
  }

  /**
   * EmailAccount updateMany
   */
  export type EmailAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailAccounts.
     */
    data: XOR<EmailAccountUpdateManyMutationInput, EmailAccountUncheckedUpdateManyInput>
    /**
     * Filter which EmailAccounts to update
     */
    where?: EmailAccountWhereInput
    /**
     * Limit how many EmailAccounts to update.
     */
    limit?: number
  }

  /**
   * EmailAccount updateManyAndReturn
   */
  export type EmailAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * The data used to update EmailAccounts.
     */
    data: XOR<EmailAccountUpdateManyMutationInput, EmailAccountUncheckedUpdateManyInput>
    /**
     * Filter which EmailAccounts to update
     */
    where?: EmailAccountWhereInput
    /**
     * Limit how many EmailAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAccount upsert
   */
  export type EmailAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailAccount to update in case it exists.
     */
    where: EmailAccountWhereUniqueInput
    /**
     * In case the EmailAccount found by the `where` argument doesn't exist, create a new EmailAccount with this data.
     */
    create: XOR<EmailAccountCreateInput, EmailAccountUncheckedCreateInput>
    /**
     * In case the EmailAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailAccountUpdateInput, EmailAccountUncheckedUpdateInput>
  }

  /**
   * EmailAccount delete
   */
  export type EmailAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter which EmailAccount to delete.
     */
    where: EmailAccountWhereUniqueInput
  }

  /**
   * EmailAccount deleteMany
   */
  export type EmailAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAccounts to delete
     */
    where?: EmailAccountWhereInput
    /**
     * Limit how many EmailAccounts to delete.
     */
    limit?: number
  }

  /**
   * EmailAccount without action
   */
  export type EmailAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
  }


  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    body: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    body: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    body: number
    userId: number
    createdAt: number
    _all: number
  }


  export type EmailTemplateMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    userId?: true
    createdAt?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    userId?: true
    createdAt?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: string
    name: string
    subject: string
    body: string
    userId: string
    createdAt: Date
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    EmailMessage?: boolean | EmailTemplate$EmailMessageArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type EmailTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subject" | "body" | "userId" | "createdAt", ExtArgs["result"]["emailTemplate"]>
  export type EmailTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    EmailMessage?: boolean | EmailTemplate$EmailMessageArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      EmailMessage: Prisma.$EmailMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string
      body: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }

  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailTemplateFindUniqueArgs>(args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailTemplateFindFirstArgs>(args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailTemplateFindManyArgs>(args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
     */
    create<T extends EmailTemplateCreateArgs>(args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailTemplates.
     * @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailTemplateCreateManyArgs>(args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTemplates and returns the data saved in the database.
     * @param {EmailTemplateCreateManyAndReturnArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
     */
    delete<T extends EmailTemplateDeleteArgs>(args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailTemplateUpdateArgs>(args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailTemplateDeleteManyArgs>(args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailTemplateUpdateManyArgs>(args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates and returns the data updated in the database.
     * @param {EmailTemplateUpdateManyAndReturnArgs} args - Arguments to update many EmailTemplates.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
     */
    upsert<T extends EmailTemplateUpsertArgs>(args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    EmailMessage<T extends EmailTemplate$EmailMessageArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$EmailMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailTemplate model
   */
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'String'>
    readonly name: FieldRef<"EmailTemplate", 'String'>
    readonly subject: FieldRef<"EmailTemplate", 'String'>
    readonly body: FieldRef<"EmailTemplate", 'String'>
    readonly userId: FieldRef<"EmailTemplate", 'String'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }

  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate createManyAndReturn
   */
  export type EmailTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate updateManyAndReturn
   */
  export type EmailTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }

  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to delete.
     */
    limit?: number
  }

  /**
   * EmailTemplate.EmailMessage
   */
  export type EmailTemplate$EmailMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    where?: EmailMessageWhereInput
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    cursor?: EmailMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }

  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
  }


  /**
   * Model EmailMessage
   */

  export type AggregateEmailMessage = {
    _count: EmailMessageCountAggregateOutputType | null
    _min: EmailMessageMinAggregateOutputType | null
    _max: EmailMessageMaxAggregateOutputType | null
  }

  export type EmailMessageMinAggregateOutputType = {
    id: string | null
    subject: string | null
    to: string | null
    body: string | null
    status: string | null
    userId: string | null
    templateId: string | null
    createdAt: Date | null
  }

  export type EmailMessageMaxAggregateOutputType = {
    id: string | null
    subject: string | null
    to: string | null
    body: string | null
    status: string | null
    userId: string | null
    templateId: string | null
    createdAt: Date | null
  }

  export type EmailMessageCountAggregateOutputType = {
    id: number
    subject: number
    to: number
    body: number
    status: number
    userId: number
    templateId: number
    attachments: number
    createdAt: number
    _all: number
  }


  export type EmailMessageMinAggregateInputType = {
    id?: true
    subject?: true
    to?: true
    body?: true
    status?: true
    userId?: true
    templateId?: true
    createdAt?: true
  }

  export type EmailMessageMaxAggregateInputType = {
    id?: true
    subject?: true
    to?: true
    body?: true
    status?: true
    userId?: true
    templateId?: true
    createdAt?: true
  }

  export type EmailMessageCountAggregateInputType = {
    id?: true
    subject?: true
    to?: true
    body?: true
    status?: true
    userId?: true
    templateId?: true
    attachments?: true
    createdAt?: true
    _all?: true
  }

  export type EmailMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailMessage to aggregate.
     */
    where?: EmailMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailMessages to fetch.
     */
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailMessages
    **/
    _count?: true | EmailMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailMessageMaxAggregateInputType
  }

  export type GetEmailMessageAggregateType<T extends EmailMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailMessage[P]>
      : GetScalarType<T[P], AggregateEmailMessage[P]>
  }




  export type EmailMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailMessageWhereInput
    orderBy?: EmailMessageOrderByWithAggregationInput | EmailMessageOrderByWithAggregationInput[]
    by: EmailMessageScalarFieldEnum[] | EmailMessageScalarFieldEnum
    having?: EmailMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailMessageCountAggregateInputType | true
    _min?: EmailMessageMinAggregateInputType
    _max?: EmailMessageMaxAggregateInputType
  }

  export type EmailMessageGroupByOutputType = {
    id: string
    subject: string
    to: string
    body: string
    status: string
    userId: string
    templateId: string | null
    attachments: JsonValue | null
    createdAt: Date
    _count: EmailMessageCountAggregateOutputType | null
    _min: EmailMessageMinAggregateOutputType | null
    _max: EmailMessageMaxAggregateOutputType | null
  }

  type GetEmailMessageGroupByPayload<T extends EmailMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailMessageGroupByOutputType[P]>
            : GetScalarType<T[P], EmailMessageGroupByOutputType[P]>
        }
      >
    >


  export type EmailMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    to?: boolean
    body?: boolean
    status?: boolean
    userId?: boolean
    templateId?: boolean
    attachments?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | EmailMessage$templateArgs<ExtArgs>
  }, ExtArgs["result"]["emailMessage"]>

  export type EmailMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    to?: boolean
    body?: boolean
    status?: boolean
    userId?: boolean
    templateId?: boolean
    attachments?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | EmailMessage$templateArgs<ExtArgs>
  }, ExtArgs["result"]["emailMessage"]>

  export type EmailMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    to?: boolean
    body?: boolean
    status?: boolean
    userId?: boolean
    templateId?: boolean
    attachments?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | EmailMessage$templateArgs<ExtArgs>
  }, ExtArgs["result"]["emailMessage"]>

  export type EmailMessageSelectScalar = {
    id?: boolean
    subject?: boolean
    to?: boolean
    body?: boolean
    status?: boolean
    userId?: boolean
    templateId?: boolean
    attachments?: boolean
    createdAt?: boolean
  }

  export type EmailMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subject" | "to" | "body" | "status" | "userId" | "templateId" | "attachments" | "createdAt", ExtArgs["result"]["emailMessage"]>
  export type EmailMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | EmailMessage$templateArgs<ExtArgs>
  }
  export type EmailMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | EmailMessage$templateArgs<ExtArgs>
  }
  export type EmailMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | EmailMessage$templateArgs<ExtArgs>
  }

  export type $EmailMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailMessage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      template: Prisma.$EmailTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subject: string
      to: string
      body: string
      status: string
      userId: string
      templateId: string | null
      attachments: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["emailMessage"]>
    composites: {}
  }

  type EmailMessageGetPayload<S extends boolean | null | undefined | EmailMessageDefaultArgs> = $Result.GetResult<Prisma.$EmailMessagePayload, S>

  type EmailMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailMessageCountAggregateInputType | true
    }

  export interface EmailMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailMessage'], meta: { name: 'EmailMessage' } }
    /**
     * Find zero or one EmailMessage that matches the filter.
     * @param {EmailMessageFindUniqueArgs} args - Arguments to find a EmailMessage
     * @example
     * // Get one EmailMessage
     * const emailMessage = await prisma.emailMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailMessageFindUniqueArgs>(args: SelectSubset<T, EmailMessageFindUniqueArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailMessageFindUniqueOrThrowArgs} args - Arguments to find a EmailMessage
     * @example
     * // Get one EmailMessage
     * const emailMessage = await prisma.emailMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageFindFirstArgs} args - Arguments to find a EmailMessage
     * @example
     * // Get one EmailMessage
     * const emailMessage = await prisma.emailMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailMessageFindFirstArgs>(args?: SelectSubset<T, EmailMessageFindFirstArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageFindFirstOrThrowArgs} args - Arguments to find a EmailMessage
     * @example
     * // Get one EmailMessage
     * const emailMessage = await prisma.emailMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailMessages
     * const emailMessages = await prisma.emailMessage.findMany()
     * 
     * // Get first 10 EmailMessages
     * const emailMessages = await prisma.emailMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailMessageWithIdOnly = await prisma.emailMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailMessageFindManyArgs>(args?: SelectSubset<T, EmailMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailMessage.
     * @param {EmailMessageCreateArgs} args - Arguments to create a EmailMessage.
     * @example
     * // Create one EmailMessage
     * const EmailMessage = await prisma.emailMessage.create({
     *   data: {
     *     // ... data to create a EmailMessage
     *   }
     * })
     * 
     */
    create<T extends EmailMessageCreateArgs>(args: SelectSubset<T, EmailMessageCreateArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailMessages.
     * @param {EmailMessageCreateManyArgs} args - Arguments to create many EmailMessages.
     * @example
     * // Create many EmailMessages
     * const emailMessage = await prisma.emailMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailMessageCreateManyArgs>(args?: SelectSubset<T, EmailMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailMessages and returns the data saved in the database.
     * @param {EmailMessageCreateManyAndReturnArgs} args - Arguments to create many EmailMessages.
     * @example
     * // Create many EmailMessages
     * const emailMessage = await prisma.emailMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailMessages and only return the `id`
     * const emailMessageWithIdOnly = await prisma.emailMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailMessage.
     * @param {EmailMessageDeleteArgs} args - Arguments to delete one EmailMessage.
     * @example
     * // Delete one EmailMessage
     * const EmailMessage = await prisma.emailMessage.delete({
     *   where: {
     *     // ... filter to delete one EmailMessage
     *   }
     * })
     * 
     */
    delete<T extends EmailMessageDeleteArgs>(args: SelectSubset<T, EmailMessageDeleteArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailMessage.
     * @param {EmailMessageUpdateArgs} args - Arguments to update one EmailMessage.
     * @example
     * // Update one EmailMessage
     * const emailMessage = await prisma.emailMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailMessageUpdateArgs>(args: SelectSubset<T, EmailMessageUpdateArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailMessages.
     * @param {EmailMessageDeleteManyArgs} args - Arguments to filter EmailMessages to delete.
     * @example
     * // Delete a few EmailMessages
     * const { count } = await prisma.emailMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailMessageDeleteManyArgs>(args?: SelectSubset<T, EmailMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailMessages
     * const emailMessage = await prisma.emailMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailMessageUpdateManyArgs>(args: SelectSubset<T, EmailMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailMessages and returns the data updated in the database.
     * @param {EmailMessageUpdateManyAndReturnArgs} args - Arguments to update many EmailMessages.
     * @example
     * // Update many EmailMessages
     * const emailMessage = await prisma.emailMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailMessages and only return the `id`
     * const emailMessageWithIdOnly = await prisma.emailMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailMessage.
     * @param {EmailMessageUpsertArgs} args - Arguments to update or create a EmailMessage.
     * @example
     * // Update or create a EmailMessage
     * const emailMessage = await prisma.emailMessage.upsert({
     *   create: {
     *     // ... data to create a EmailMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailMessage we want to update
     *   }
     * })
     */
    upsert<T extends EmailMessageUpsertArgs>(args: SelectSubset<T, EmailMessageUpsertArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageCountArgs} args - Arguments to filter EmailMessages to count.
     * @example
     * // Count the number of EmailMessages
     * const count = await prisma.emailMessage.count({
     *   where: {
     *     // ... the filter for the EmailMessages we want to count
     *   }
     * })
    **/
    count<T extends EmailMessageCountArgs>(
      args?: Subset<T, EmailMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailMessageAggregateArgs>(args: Subset<T, EmailMessageAggregateArgs>): Prisma.PrismaPromise<GetEmailMessageAggregateType<T>>

    /**
     * Group by EmailMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailMessageGroupByArgs['orderBy'] }
        : { orderBy?: EmailMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailMessage model
   */
  readonly fields: EmailMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends EmailMessage$templateArgs<ExtArgs> = {}>(args?: Subset<T, EmailMessage$templateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailMessage model
   */
  interface EmailMessageFieldRefs {
    readonly id: FieldRef<"EmailMessage", 'String'>
    readonly subject: FieldRef<"EmailMessage", 'String'>
    readonly to: FieldRef<"EmailMessage", 'String'>
    readonly body: FieldRef<"EmailMessage", 'String'>
    readonly status: FieldRef<"EmailMessage", 'String'>
    readonly userId: FieldRef<"EmailMessage", 'String'>
    readonly templateId: FieldRef<"EmailMessage", 'String'>
    readonly attachments: FieldRef<"EmailMessage", 'Json'>
    readonly createdAt: FieldRef<"EmailMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailMessage findUnique
   */
  export type EmailMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessage to fetch.
     */
    where: EmailMessageWhereUniqueInput
  }

  /**
   * EmailMessage findUniqueOrThrow
   */
  export type EmailMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessage to fetch.
     */
    where: EmailMessageWhereUniqueInput
  }

  /**
   * EmailMessage findFirst
   */
  export type EmailMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessage to fetch.
     */
    where?: EmailMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailMessages to fetch.
     */
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailMessages.
     */
    cursor?: EmailMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailMessages.
     */
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }

  /**
   * EmailMessage findFirstOrThrow
   */
  export type EmailMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessage to fetch.
     */
    where?: EmailMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailMessages to fetch.
     */
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailMessages.
     */
    cursor?: EmailMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailMessages.
     */
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }

  /**
   * EmailMessage findMany
   */
  export type EmailMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessages to fetch.
     */
    where?: EmailMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailMessages to fetch.
     */
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailMessages.
     */
    cursor?: EmailMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailMessages.
     */
    skip?: number
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }

  /**
   * EmailMessage create
   */
  export type EmailMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailMessage.
     */
    data: XOR<EmailMessageCreateInput, EmailMessageUncheckedCreateInput>
  }

  /**
   * EmailMessage createMany
   */
  export type EmailMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailMessages.
     */
    data: EmailMessageCreateManyInput | EmailMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailMessage createManyAndReturn
   */
  export type EmailMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * The data used to create many EmailMessages.
     */
    data: EmailMessageCreateManyInput | EmailMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailMessage update
   */
  export type EmailMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailMessage.
     */
    data: XOR<EmailMessageUpdateInput, EmailMessageUncheckedUpdateInput>
    /**
     * Choose, which EmailMessage to update.
     */
    where: EmailMessageWhereUniqueInput
  }

  /**
   * EmailMessage updateMany
   */
  export type EmailMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailMessages.
     */
    data: XOR<EmailMessageUpdateManyMutationInput, EmailMessageUncheckedUpdateManyInput>
    /**
     * Filter which EmailMessages to update
     */
    where?: EmailMessageWhereInput
    /**
     * Limit how many EmailMessages to update.
     */
    limit?: number
  }

  /**
   * EmailMessage updateManyAndReturn
   */
  export type EmailMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * The data used to update EmailMessages.
     */
    data: XOR<EmailMessageUpdateManyMutationInput, EmailMessageUncheckedUpdateManyInput>
    /**
     * Filter which EmailMessages to update
     */
    where?: EmailMessageWhereInput
    /**
     * Limit how many EmailMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailMessage upsert
   */
  export type EmailMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailMessage to update in case it exists.
     */
    where: EmailMessageWhereUniqueInput
    /**
     * In case the EmailMessage found by the `where` argument doesn't exist, create a new EmailMessage with this data.
     */
    create: XOR<EmailMessageCreateInput, EmailMessageUncheckedCreateInput>
    /**
     * In case the EmailMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailMessageUpdateInput, EmailMessageUncheckedUpdateInput>
  }

  /**
   * EmailMessage delete
   */
  export type EmailMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter which EmailMessage to delete.
     */
    where: EmailMessageWhereUniqueInput
  }

  /**
   * EmailMessage deleteMany
   */
  export type EmailMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailMessages to delete
     */
    where?: EmailMessageWhereInput
    /**
     * Limit how many EmailMessages to delete.
     */
    limit?: number
  }

  /**
   * EmailMessage.template
   */
  export type EmailMessage$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }

  /**
   * EmailMessage without action
   */
  export type EmailMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
  }


  /**
   * Model EmailInboxMessage
   */

  export type AggregateEmailInboxMessage = {
    _count: EmailInboxMessageCountAggregateOutputType | null
    _min: EmailInboxMessageMinAggregateOutputType | null
    _max: EmailInboxMessageMaxAggregateOutputType | null
  }

  export type EmailInboxMessageMinAggregateOutputType = {
    id: string | null
    userId: string | null
    from: string | null
    to: string | null
    subject: string | null
    text: string | null
    html: string | null
    date: Date | null
    folder: string | null
    messageId: string | null
    seen: boolean | null
    flagged: boolean | null
    createdAt: Date | null
  }

  export type EmailInboxMessageMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    from: string | null
    to: string | null
    subject: string | null
    text: string | null
    html: string | null
    date: Date | null
    folder: string | null
    messageId: string | null
    seen: boolean | null
    flagged: boolean | null
    createdAt: Date | null
  }

  export type EmailInboxMessageCountAggregateOutputType = {
    id: number
    userId: number
    from: number
    to: number
    subject: number
    text: number
    html: number
    date: number
    folder: number
    messageId: number
    seen: number
    flagged: number
    attachments: number
    createdAt: number
    _all: number
  }


  export type EmailInboxMessageMinAggregateInputType = {
    id?: true
    userId?: true
    from?: true
    to?: true
    subject?: true
    text?: true
    html?: true
    date?: true
    folder?: true
    messageId?: true
    seen?: true
    flagged?: true
    createdAt?: true
  }

  export type EmailInboxMessageMaxAggregateInputType = {
    id?: true
    userId?: true
    from?: true
    to?: true
    subject?: true
    text?: true
    html?: true
    date?: true
    folder?: true
    messageId?: true
    seen?: true
    flagged?: true
    createdAt?: true
  }

  export type EmailInboxMessageCountAggregateInputType = {
    id?: true
    userId?: true
    from?: true
    to?: true
    subject?: true
    text?: true
    html?: true
    date?: true
    folder?: true
    messageId?: true
    seen?: true
    flagged?: true
    attachments?: true
    createdAt?: true
    _all?: true
  }

  export type EmailInboxMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailInboxMessage to aggregate.
     */
    where?: EmailInboxMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailInboxMessages to fetch.
     */
    orderBy?: EmailInboxMessageOrderByWithRelationInput | EmailInboxMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailInboxMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailInboxMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailInboxMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailInboxMessages
    **/
    _count?: true | EmailInboxMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailInboxMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailInboxMessageMaxAggregateInputType
  }

  export type GetEmailInboxMessageAggregateType<T extends EmailInboxMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailInboxMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailInboxMessage[P]>
      : GetScalarType<T[P], AggregateEmailInboxMessage[P]>
  }




  export type EmailInboxMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailInboxMessageWhereInput
    orderBy?: EmailInboxMessageOrderByWithAggregationInput | EmailInboxMessageOrderByWithAggregationInput[]
    by: EmailInboxMessageScalarFieldEnum[] | EmailInboxMessageScalarFieldEnum
    having?: EmailInboxMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailInboxMessageCountAggregateInputType | true
    _min?: EmailInboxMessageMinAggregateInputType
    _max?: EmailInboxMessageMaxAggregateInputType
  }

  export type EmailInboxMessageGroupByOutputType = {
    id: string
    userId: string
    from: string
    to: string
    subject: string
    text: string | null
    html: string | null
    date: Date
    folder: string
    messageId: string
    seen: boolean
    flagged: boolean
    attachments: JsonValue | null
    createdAt: Date
    _count: EmailInboxMessageCountAggregateOutputType | null
    _min: EmailInboxMessageMinAggregateOutputType | null
    _max: EmailInboxMessageMaxAggregateOutputType | null
  }

  type GetEmailInboxMessageGroupByPayload<T extends EmailInboxMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailInboxMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailInboxMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailInboxMessageGroupByOutputType[P]>
            : GetScalarType<T[P], EmailInboxMessageGroupByOutputType[P]>
        }
      >
    >


  export type EmailInboxMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    from?: boolean
    to?: boolean
    subject?: boolean
    text?: boolean
    html?: boolean
    date?: boolean
    folder?: boolean
    messageId?: boolean
    seen?: boolean
    flagged?: boolean
    attachments?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailInboxMessage"]>

  export type EmailInboxMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    from?: boolean
    to?: boolean
    subject?: boolean
    text?: boolean
    html?: boolean
    date?: boolean
    folder?: boolean
    messageId?: boolean
    seen?: boolean
    flagged?: boolean
    attachments?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailInboxMessage"]>

  export type EmailInboxMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    from?: boolean
    to?: boolean
    subject?: boolean
    text?: boolean
    html?: boolean
    date?: boolean
    folder?: boolean
    messageId?: boolean
    seen?: boolean
    flagged?: boolean
    attachments?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailInboxMessage"]>

  export type EmailInboxMessageSelectScalar = {
    id?: boolean
    userId?: boolean
    from?: boolean
    to?: boolean
    subject?: boolean
    text?: boolean
    html?: boolean
    date?: boolean
    folder?: boolean
    messageId?: boolean
    seen?: boolean
    flagged?: boolean
    attachments?: boolean
    createdAt?: boolean
  }

  export type EmailInboxMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "from" | "to" | "subject" | "text" | "html" | "date" | "folder" | "messageId" | "seen" | "flagged" | "attachments" | "createdAt", ExtArgs["result"]["emailInboxMessage"]>
  export type EmailInboxMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailInboxMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailInboxMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailInboxMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailInboxMessage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      from: string
      to: string
      subject: string
      text: string | null
      html: string | null
      date: Date
      folder: string
      messageId: string
      seen: boolean
      flagged: boolean
      attachments: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["emailInboxMessage"]>
    composites: {}
  }

  type EmailInboxMessageGetPayload<S extends boolean | null | undefined | EmailInboxMessageDefaultArgs> = $Result.GetResult<Prisma.$EmailInboxMessagePayload, S>

  type EmailInboxMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailInboxMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailInboxMessageCountAggregateInputType | true
    }

  export interface EmailInboxMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailInboxMessage'], meta: { name: 'EmailInboxMessage' } }
    /**
     * Find zero or one EmailInboxMessage that matches the filter.
     * @param {EmailInboxMessageFindUniqueArgs} args - Arguments to find a EmailInboxMessage
     * @example
     * // Get one EmailInboxMessage
     * const emailInboxMessage = await prisma.emailInboxMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailInboxMessageFindUniqueArgs>(args: SelectSubset<T, EmailInboxMessageFindUniqueArgs<ExtArgs>>): Prisma__EmailInboxMessageClient<$Result.GetResult<Prisma.$EmailInboxMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailInboxMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailInboxMessageFindUniqueOrThrowArgs} args - Arguments to find a EmailInboxMessage
     * @example
     * // Get one EmailInboxMessage
     * const emailInboxMessage = await prisma.emailInboxMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailInboxMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailInboxMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailInboxMessageClient<$Result.GetResult<Prisma.$EmailInboxMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailInboxMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailInboxMessageFindFirstArgs} args - Arguments to find a EmailInboxMessage
     * @example
     * // Get one EmailInboxMessage
     * const emailInboxMessage = await prisma.emailInboxMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailInboxMessageFindFirstArgs>(args?: SelectSubset<T, EmailInboxMessageFindFirstArgs<ExtArgs>>): Prisma__EmailInboxMessageClient<$Result.GetResult<Prisma.$EmailInboxMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailInboxMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailInboxMessageFindFirstOrThrowArgs} args - Arguments to find a EmailInboxMessage
     * @example
     * // Get one EmailInboxMessage
     * const emailInboxMessage = await prisma.emailInboxMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailInboxMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailInboxMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailInboxMessageClient<$Result.GetResult<Prisma.$EmailInboxMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailInboxMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailInboxMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailInboxMessages
     * const emailInboxMessages = await prisma.emailInboxMessage.findMany()
     * 
     * // Get first 10 EmailInboxMessages
     * const emailInboxMessages = await prisma.emailInboxMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailInboxMessageWithIdOnly = await prisma.emailInboxMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailInboxMessageFindManyArgs>(args?: SelectSubset<T, EmailInboxMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailInboxMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailInboxMessage.
     * @param {EmailInboxMessageCreateArgs} args - Arguments to create a EmailInboxMessage.
     * @example
     * // Create one EmailInboxMessage
     * const EmailInboxMessage = await prisma.emailInboxMessage.create({
     *   data: {
     *     // ... data to create a EmailInboxMessage
     *   }
     * })
     * 
     */
    create<T extends EmailInboxMessageCreateArgs>(args: SelectSubset<T, EmailInboxMessageCreateArgs<ExtArgs>>): Prisma__EmailInboxMessageClient<$Result.GetResult<Prisma.$EmailInboxMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailInboxMessages.
     * @param {EmailInboxMessageCreateManyArgs} args - Arguments to create many EmailInboxMessages.
     * @example
     * // Create many EmailInboxMessages
     * const emailInboxMessage = await prisma.emailInboxMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailInboxMessageCreateManyArgs>(args?: SelectSubset<T, EmailInboxMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailInboxMessages and returns the data saved in the database.
     * @param {EmailInboxMessageCreateManyAndReturnArgs} args - Arguments to create many EmailInboxMessages.
     * @example
     * // Create many EmailInboxMessages
     * const emailInboxMessage = await prisma.emailInboxMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailInboxMessages and only return the `id`
     * const emailInboxMessageWithIdOnly = await prisma.emailInboxMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailInboxMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailInboxMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailInboxMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailInboxMessage.
     * @param {EmailInboxMessageDeleteArgs} args - Arguments to delete one EmailInboxMessage.
     * @example
     * // Delete one EmailInboxMessage
     * const EmailInboxMessage = await prisma.emailInboxMessage.delete({
     *   where: {
     *     // ... filter to delete one EmailInboxMessage
     *   }
     * })
     * 
     */
    delete<T extends EmailInboxMessageDeleteArgs>(args: SelectSubset<T, EmailInboxMessageDeleteArgs<ExtArgs>>): Prisma__EmailInboxMessageClient<$Result.GetResult<Prisma.$EmailInboxMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailInboxMessage.
     * @param {EmailInboxMessageUpdateArgs} args - Arguments to update one EmailInboxMessage.
     * @example
     * // Update one EmailInboxMessage
     * const emailInboxMessage = await prisma.emailInboxMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailInboxMessageUpdateArgs>(args: SelectSubset<T, EmailInboxMessageUpdateArgs<ExtArgs>>): Prisma__EmailInboxMessageClient<$Result.GetResult<Prisma.$EmailInboxMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailInboxMessages.
     * @param {EmailInboxMessageDeleteManyArgs} args - Arguments to filter EmailInboxMessages to delete.
     * @example
     * // Delete a few EmailInboxMessages
     * const { count } = await prisma.emailInboxMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailInboxMessageDeleteManyArgs>(args?: SelectSubset<T, EmailInboxMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailInboxMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailInboxMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailInboxMessages
     * const emailInboxMessage = await prisma.emailInboxMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailInboxMessageUpdateManyArgs>(args: SelectSubset<T, EmailInboxMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailInboxMessages and returns the data updated in the database.
     * @param {EmailInboxMessageUpdateManyAndReturnArgs} args - Arguments to update many EmailInboxMessages.
     * @example
     * // Update many EmailInboxMessages
     * const emailInboxMessage = await prisma.emailInboxMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailInboxMessages and only return the `id`
     * const emailInboxMessageWithIdOnly = await prisma.emailInboxMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailInboxMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailInboxMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailInboxMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailInboxMessage.
     * @param {EmailInboxMessageUpsertArgs} args - Arguments to update or create a EmailInboxMessage.
     * @example
     * // Update or create a EmailInboxMessage
     * const emailInboxMessage = await prisma.emailInboxMessage.upsert({
     *   create: {
     *     // ... data to create a EmailInboxMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailInboxMessage we want to update
     *   }
     * })
     */
    upsert<T extends EmailInboxMessageUpsertArgs>(args: SelectSubset<T, EmailInboxMessageUpsertArgs<ExtArgs>>): Prisma__EmailInboxMessageClient<$Result.GetResult<Prisma.$EmailInboxMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailInboxMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailInboxMessageCountArgs} args - Arguments to filter EmailInboxMessages to count.
     * @example
     * // Count the number of EmailInboxMessages
     * const count = await prisma.emailInboxMessage.count({
     *   where: {
     *     // ... the filter for the EmailInboxMessages we want to count
     *   }
     * })
    **/
    count<T extends EmailInboxMessageCountArgs>(
      args?: Subset<T, EmailInboxMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailInboxMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailInboxMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailInboxMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailInboxMessageAggregateArgs>(args: Subset<T, EmailInboxMessageAggregateArgs>): Prisma.PrismaPromise<GetEmailInboxMessageAggregateType<T>>

    /**
     * Group by EmailInboxMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailInboxMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailInboxMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailInboxMessageGroupByArgs['orderBy'] }
        : { orderBy?: EmailInboxMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailInboxMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailInboxMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailInboxMessage model
   */
  readonly fields: EmailInboxMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailInboxMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailInboxMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailInboxMessage model
   */
  interface EmailInboxMessageFieldRefs {
    readonly id: FieldRef<"EmailInboxMessage", 'String'>
    readonly userId: FieldRef<"EmailInboxMessage", 'String'>
    readonly from: FieldRef<"EmailInboxMessage", 'String'>
    readonly to: FieldRef<"EmailInboxMessage", 'String'>
    readonly subject: FieldRef<"EmailInboxMessage", 'String'>
    readonly text: FieldRef<"EmailInboxMessage", 'String'>
    readonly html: FieldRef<"EmailInboxMessage", 'String'>
    readonly date: FieldRef<"EmailInboxMessage", 'DateTime'>
    readonly folder: FieldRef<"EmailInboxMessage", 'String'>
    readonly messageId: FieldRef<"EmailInboxMessage", 'String'>
    readonly seen: FieldRef<"EmailInboxMessage", 'Boolean'>
    readonly flagged: FieldRef<"EmailInboxMessage", 'Boolean'>
    readonly attachments: FieldRef<"EmailInboxMessage", 'Json'>
    readonly createdAt: FieldRef<"EmailInboxMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailInboxMessage findUnique
   */
  export type EmailInboxMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailInboxMessage
     */
    select?: EmailInboxMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailInboxMessage
     */
    omit?: EmailInboxMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInboxMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailInboxMessage to fetch.
     */
    where: EmailInboxMessageWhereUniqueInput
  }

  /**
   * EmailInboxMessage findUniqueOrThrow
   */
  export type EmailInboxMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailInboxMessage
     */
    select?: EmailInboxMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailInboxMessage
     */
    omit?: EmailInboxMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInboxMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailInboxMessage to fetch.
     */
    where: EmailInboxMessageWhereUniqueInput
  }

  /**
   * EmailInboxMessage findFirst
   */
  export type EmailInboxMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailInboxMessage
     */
    select?: EmailInboxMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailInboxMessage
     */
    omit?: EmailInboxMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInboxMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailInboxMessage to fetch.
     */
    where?: EmailInboxMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailInboxMessages to fetch.
     */
    orderBy?: EmailInboxMessageOrderByWithRelationInput | EmailInboxMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailInboxMessages.
     */
    cursor?: EmailInboxMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailInboxMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailInboxMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailInboxMessages.
     */
    distinct?: EmailInboxMessageScalarFieldEnum | EmailInboxMessageScalarFieldEnum[]
  }

  /**
   * EmailInboxMessage findFirstOrThrow
   */
  export type EmailInboxMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailInboxMessage
     */
    select?: EmailInboxMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailInboxMessage
     */
    omit?: EmailInboxMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInboxMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailInboxMessage to fetch.
     */
    where?: EmailInboxMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailInboxMessages to fetch.
     */
    orderBy?: EmailInboxMessageOrderByWithRelationInput | EmailInboxMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailInboxMessages.
     */
    cursor?: EmailInboxMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailInboxMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailInboxMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailInboxMessages.
     */
    distinct?: EmailInboxMessageScalarFieldEnum | EmailInboxMessageScalarFieldEnum[]
  }

  /**
   * EmailInboxMessage findMany
   */
  export type EmailInboxMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailInboxMessage
     */
    select?: EmailInboxMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailInboxMessage
     */
    omit?: EmailInboxMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInboxMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailInboxMessages to fetch.
     */
    where?: EmailInboxMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailInboxMessages to fetch.
     */
    orderBy?: EmailInboxMessageOrderByWithRelationInput | EmailInboxMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailInboxMessages.
     */
    cursor?: EmailInboxMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailInboxMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailInboxMessages.
     */
    skip?: number
    distinct?: EmailInboxMessageScalarFieldEnum | EmailInboxMessageScalarFieldEnum[]
  }

  /**
   * EmailInboxMessage create
   */
  export type EmailInboxMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailInboxMessage
     */
    select?: EmailInboxMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailInboxMessage
     */
    omit?: EmailInboxMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInboxMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailInboxMessage.
     */
    data: XOR<EmailInboxMessageCreateInput, EmailInboxMessageUncheckedCreateInput>
  }

  /**
   * EmailInboxMessage createMany
   */
  export type EmailInboxMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailInboxMessages.
     */
    data: EmailInboxMessageCreateManyInput | EmailInboxMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailInboxMessage createManyAndReturn
   */
  export type EmailInboxMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailInboxMessage
     */
    select?: EmailInboxMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailInboxMessage
     */
    omit?: EmailInboxMessageOmit<ExtArgs> | null
    /**
     * The data used to create many EmailInboxMessages.
     */
    data: EmailInboxMessageCreateManyInput | EmailInboxMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInboxMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailInboxMessage update
   */
  export type EmailInboxMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailInboxMessage
     */
    select?: EmailInboxMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailInboxMessage
     */
    omit?: EmailInboxMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInboxMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailInboxMessage.
     */
    data: XOR<EmailInboxMessageUpdateInput, EmailInboxMessageUncheckedUpdateInput>
    /**
     * Choose, which EmailInboxMessage to update.
     */
    where: EmailInboxMessageWhereUniqueInput
  }

  /**
   * EmailInboxMessage updateMany
   */
  export type EmailInboxMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailInboxMessages.
     */
    data: XOR<EmailInboxMessageUpdateManyMutationInput, EmailInboxMessageUncheckedUpdateManyInput>
    /**
     * Filter which EmailInboxMessages to update
     */
    where?: EmailInboxMessageWhereInput
    /**
     * Limit how many EmailInboxMessages to update.
     */
    limit?: number
  }

  /**
   * EmailInboxMessage updateManyAndReturn
   */
  export type EmailInboxMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailInboxMessage
     */
    select?: EmailInboxMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailInboxMessage
     */
    omit?: EmailInboxMessageOmit<ExtArgs> | null
    /**
     * The data used to update EmailInboxMessages.
     */
    data: XOR<EmailInboxMessageUpdateManyMutationInput, EmailInboxMessageUncheckedUpdateManyInput>
    /**
     * Filter which EmailInboxMessages to update
     */
    where?: EmailInboxMessageWhereInput
    /**
     * Limit how many EmailInboxMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInboxMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailInboxMessage upsert
   */
  export type EmailInboxMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailInboxMessage
     */
    select?: EmailInboxMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailInboxMessage
     */
    omit?: EmailInboxMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInboxMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailInboxMessage to update in case it exists.
     */
    where: EmailInboxMessageWhereUniqueInput
    /**
     * In case the EmailInboxMessage found by the `where` argument doesn't exist, create a new EmailInboxMessage with this data.
     */
    create: XOR<EmailInboxMessageCreateInput, EmailInboxMessageUncheckedCreateInput>
    /**
     * In case the EmailInboxMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailInboxMessageUpdateInput, EmailInboxMessageUncheckedUpdateInput>
  }

  /**
   * EmailInboxMessage delete
   */
  export type EmailInboxMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailInboxMessage
     */
    select?: EmailInboxMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailInboxMessage
     */
    omit?: EmailInboxMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInboxMessageInclude<ExtArgs> | null
    /**
     * Filter which EmailInboxMessage to delete.
     */
    where: EmailInboxMessageWhereUniqueInput
  }

  /**
   * EmailInboxMessage deleteMany
   */
  export type EmailInboxMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailInboxMessages to delete
     */
    where?: EmailInboxMessageWhereInput
    /**
     * Limit how many EmailInboxMessages to delete.
     */
    limit?: number
  }

  /**
   * EmailInboxMessage without action
   */
  export type EmailInboxMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailInboxMessage
     */
    select?: EmailInboxMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailInboxMessage
     */
    omit?: EmailInboxMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInboxMessageInclude<ExtArgs> | null
  }


  /**
   * Model EmailContact
   */

  export type AggregateEmailContact = {
    _count: EmailContactCountAggregateOutputType | null
    _min: EmailContactMinAggregateOutputType | null
    _max: EmailContactMaxAggregateOutputType | null
  }

  export type EmailContactMinAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    name: string | null
    phone: string | null
    company: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type EmailContactMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    name: string | null
    phone: string | null
    company: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type EmailContactCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    name: number
    phone: number
    company: number
    notes: number
    createdAt: number
    _all: number
  }


  export type EmailContactMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    name?: true
    phone?: true
    company?: true
    notes?: true
    createdAt?: true
  }

  export type EmailContactMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    name?: true
    phone?: true
    company?: true
    notes?: true
    createdAt?: true
  }

  export type EmailContactCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    name?: true
    phone?: true
    company?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type EmailContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailContact to aggregate.
     */
    where?: EmailContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailContacts to fetch.
     */
    orderBy?: EmailContactOrderByWithRelationInput | EmailContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailContacts
    **/
    _count?: true | EmailContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailContactMaxAggregateInputType
  }

  export type GetEmailContactAggregateType<T extends EmailContactAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailContact[P]>
      : GetScalarType<T[P], AggregateEmailContact[P]>
  }




  export type EmailContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailContactWhereInput
    orderBy?: EmailContactOrderByWithAggregationInput | EmailContactOrderByWithAggregationInput[]
    by: EmailContactScalarFieldEnum[] | EmailContactScalarFieldEnum
    having?: EmailContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailContactCountAggregateInputType | true
    _min?: EmailContactMinAggregateInputType
    _max?: EmailContactMaxAggregateInputType
  }

  export type EmailContactGroupByOutputType = {
    id: string
    userId: string
    email: string
    name: string | null
    phone: string | null
    company: string | null
    notes: string | null
    createdAt: Date
    _count: EmailContactCountAggregateOutputType | null
    _min: EmailContactMinAggregateOutputType | null
    _max: EmailContactMaxAggregateOutputType | null
  }

  type GetEmailContactGroupByPayload<T extends EmailContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailContactGroupByOutputType[P]>
            : GetScalarType<T[P], EmailContactGroupByOutputType[P]>
        }
      >
    >


  export type EmailContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    company?: boolean
    notes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailContact"]>

  export type EmailContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    company?: boolean
    notes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailContact"]>

  export type EmailContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    company?: boolean
    notes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailContact"]>

  export type EmailContactSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    company?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type EmailContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "email" | "name" | "phone" | "company" | "notes" | "createdAt", ExtArgs["result"]["emailContact"]>
  export type EmailContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailContact"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      email: string
      name: string | null
      phone: string | null
      company: string | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["emailContact"]>
    composites: {}
  }

  type EmailContactGetPayload<S extends boolean | null | undefined | EmailContactDefaultArgs> = $Result.GetResult<Prisma.$EmailContactPayload, S>

  type EmailContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailContactCountAggregateInputType | true
    }

  export interface EmailContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailContact'], meta: { name: 'EmailContact' } }
    /**
     * Find zero or one EmailContact that matches the filter.
     * @param {EmailContactFindUniqueArgs} args - Arguments to find a EmailContact
     * @example
     * // Get one EmailContact
     * const emailContact = await prisma.emailContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailContactFindUniqueArgs>(args: SelectSubset<T, EmailContactFindUniqueArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailContactFindUniqueOrThrowArgs} args - Arguments to find a EmailContact
     * @example
     * // Get one EmailContact
     * const emailContact = await prisma.emailContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailContactFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactFindFirstArgs} args - Arguments to find a EmailContact
     * @example
     * // Get one EmailContact
     * const emailContact = await prisma.emailContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailContactFindFirstArgs>(args?: SelectSubset<T, EmailContactFindFirstArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactFindFirstOrThrowArgs} args - Arguments to find a EmailContact
     * @example
     * // Get one EmailContact
     * const emailContact = await prisma.emailContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailContactFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailContacts
     * const emailContacts = await prisma.emailContact.findMany()
     * 
     * // Get first 10 EmailContacts
     * const emailContacts = await prisma.emailContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailContactWithIdOnly = await prisma.emailContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailContactFindManyArgs>(args?: SelectSubset<T, EmailContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailContact.
     * @param {EmailContactCreateArgs} args - Arguments to create a EmailContact.
     * @example
     * // Create one EmailContact
     * const EmailContact = await prisma.emailContact.create({
     *   data: {
     *     // ... data to create a EmailContact
     *   }
     * })
     * 
     */
    create<T extends EmailContactCreateArgs>(args: SelectSubset<T, EmailContactCreateArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailContacts.
     * @param {EmailContactCreateManyArgs} args - Arguments to create many EmailContacts.
     * @example
     * // Create many EmailContacts
     * const emailContact = await prisma.emailContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailContactCreateManyArgs>(args?: SelectSubset<T, EmailContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailContacts and returns the data saved in the database.
     * @param {EmailContactCreateManyAndReturnArgs} args - Arguments to create many EmailContacts.
     * @example
     * // Create many EmailContacts
     * const emailContact = await prisma.emailContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailContacts and only return the `id`
     * const emailContactWithIdOnly = await prisma.emailContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailContactCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailContact.
     * @param {EmailContactDeleteArgs} args - Arguments to delete one EmailContact.
     * @example
     * // Delete one EmailContact
     * const EmailContact = await prisma.emailContact.delete({
     *   where: {
     *     // ... filter to delete one EmailContact
     *   }
     * })
     * 
     */
    delete<T extends EmailContactDeleteArgs>(args: SelectSubset<T, EmailContactDeleteArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailContact.
     * @param {EmailContactUpdateArgs} args - Arguments to update one EmailContact.
     * @example
     * // Update one EmailContact
     * const emailContact = await prisma.emailContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailContactUpdateArgs>(args: SelectSubset<T, EmailContactUpdateArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailContacts.
     * @param {EmailContactDeleteManyArgs} args - Arguments to filter EmailContacts to delete.
     * @example
     * // Delete a few EmailContacts
     * const { count } = await prisma.emailContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailContactDeleteManyArgs>(args?: SelectSubset<T, EmailContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailContacts
     * const emailContact = await prisma.emailContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailContactUpdateManyArgs>(args: SelectSubset<T, EmailContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailContacts and returns the data updated in the database.
     * @param {EmailContactUpdateManyAndReturnArgs} args - Arguments to update many EmailContacts.
     * @example
     * // Update many EmailContacts
     * const emailContact = await prisma.emailContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailContacts and only return the `id`
     * const emailContactWithIdOnly = await prisma.emailContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailContactUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailContact.
     * @param {EmailContactUpsertArgs} args - Arguments to update or create a EmailContact.
     * @example
     * // Update or create a EmailContact
     * const emailContact = await prisma.emailContact.upsert({
     *   create: {
     *     // ... data to create a EmailContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailContact we want to update
     *   }
     * })
     */
    upsert<T extends EmailContactUpsertArgs>(args: SelectSubset<T, EmailContactUpsertArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactCountArgs} args - Arguments to filter EmailContacts to count.
     * @example
     * // Count the number of EmailContacts
     * const count = await prisma.emailContact.count({
     *   where: {
     *     // ... the filter for the EmailContacts we want to count
     *   }
     * })
    **/
    count<T extends EmailContactCountArgs>(
      args?: Subset<T, EmailContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailContactAggregateArgs>(args: Subset<T, EmailContactAggregateArgs>): Prisma.PrismaPromise<GetEmailContactAggregateType<T>>

    /**
     * Group by EmailContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailContactGroupByArgs['orderBy'] }
        : { orderBy?: EmailContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailContact model
   */
  readonly fields: EmailContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailContact model
   */
  interface EmailContactFieldRefs {
    readonly id: FieldRef<"EmailContact", 'String'>
    readonly userId: FieldRef<"EmailContact", 'String'>
    readonly email: FieldRef<"EmailContact", 'String'>
    readonly name: FieldRef<"EmailContact", 'String'>
    readonly phone: FieldRef<"EmailContact", 'String'>
    readonly company: FieldRef<"EmailContact", 'String'>
    readonly notes: FieldRef<"EmailContact", 'String'>
    readonly createdAt: FieldRef<"EmailContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailContact findUnique
   */
  export type EmailContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * Filter, which EmailContact to fetch.
     */
    where: EmailContactWhereUniqueInput
  }

  /**
   * EmailContact findUniqueOrThrow
   */
  export type EmailContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * Filter, which EmailContact to fetch.
     */
    where: EmailContactWhereUniqueInput
  }

  /**
   * EmailContact findFirst
   */
  export type EmailContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * Filter, which EmailContact to fetch.
     */
    where?: EmailContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailContacts to fetch.
     */
    orderBy?: EmailContactOrderByWithRelationInput | EmailContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailContacts.
     */
    cursor?: EmailContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailContacts.
     */
    distinct?: EmailContactScalarFieldEnum | EmailContactScalarFieldEnum[]
  }

  /**
   * EmailContact findFirstOrThrow
   */
  export type EmailContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * Filter, which EmailContact to fetch.
     */
    where?: EmailContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailContacts to fetch.
     */
    orderBy?: EmailContactOrderByWithRelationInput | EmailContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailContacts.
     */
    cursor?: EmailContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailContacts.
     */
    distinct?: EmailContactScalarFieldEnum | EmailContactScalarFieldEnum[]
  }

  /**
   * EmailContact findMany
   */
  export type EmailContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * Filter, which EmailContacts to fetch.
     */
    where?: EmailContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailContacts to fetch.
     */
    orderBy?: EmailContactOrderByWithRelationInput | EmailContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailContacts.
     */
    cursor?: EmailContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailContacts.
     */
    skip?: number
    distinct?: EmailContactScalarFieldEnum | EmailContactScalarFieldEnum[]
  }

  /**
   * EmailContact create
   */
  export type EmailContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailContact.
     */
    data: XOR<EmailContactCreateInput, EmailContactUncheckedCreateInput>
  }

  /**
   * EmailContact createMany
   */
  export type EmailContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailContacts.
     */
    data: EmailContactCreateManyInput | EmailContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailContact createManyAndReturn
   */
  export type EmailContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * The data used to create many EmailContacts.
     */
    data: EmailContactCreateManyInput | EmailContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailContact update
   */
  export type EmailContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailContact.
     */
    data: XOR<EmailContactUpdateInput, EmailContactUncheckedUpdateInput>
    /**
     * Choose, which EmailContact to update.
     */
    where: EmailContactWhereUniqueInput
  }

  /**
   * EmailContact updateMany
   */
  export type EmailContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailContacts.
     */
    data: XOR<EmailContactUpdateManyMutationInput, EmailContactUncheckedUpdateManyInput>
    /**
     * Filter which EmailContacts to update
     */
    where?: EmailContactWhereInput
    /**
     * Limit how many EmailContacts to update.
     */
    limit?: number
  }

  /**
   * EmailContact updateManyAndReturn
   */
  export type EmailContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * The data used to update EmailContacts.
     */
    data: XOR<EmailContactUpdateManyMutationInput, EmailContactUncheckedUpdateManyInput>
    /**
     * Filter which EmailContacts to update
     */
    where?: EmailContactWhereInput
    /**
     * Limit how many EmailContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailContact upsert
   */
  export type EmailContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailContact to update in case it exists.
     */
    where: EmailContactWhereUniqueInput
    /**
     * In case the EmailContact found by the `where` argument doesn't exist, create a new EmailContact with this data.
     */
    create: XOR<EmailContactCreateInput, EmailContactUncheckedCreateInput>
    /**
     * In case the EmailContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailContactUpdateInput, EmailContactUncheckedUpdateInput>
  }

  /**
   * EmailContact delete
   */
  export type EmailContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * Filter which EmailContact to delete.
     */
    where: EmailContactWhereUniqueInput
  }

  /**
   * EmailContact deleteMany
   */
  export type EmailContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailContacts to delete
     */
    where?: EmailContactWhereInput
    /**
     * Limit how many EmailContacts to delete.
     */
    limit?: number
  }

  /**
   * EmailContact without action
   */
  export type EmailContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
  }


  /**
   * Model DocumentTemplate
   */

  export type AggregateDocumentTemplate = {
    _count: DocumentTemplateCountAggregateOutputType | null
    _min: DocumentTemplateMinAggregateOutputType | null
    _max: DocumentTemplateMaxAggregateOutputType | null
  }

  export type DocumentTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    content: string | null
    format: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type DocumentTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    content: string | null
    format: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type DocumentTemplateCountAggregateOutputType = {
    id: number
    name: number
    content: number
    format: number
    userId: number
    createdAt: number
    _all: number
  }


  export type DocumentTemplateMinAggregateInputType = {
    id?: true
    name?: true
    content?: true
    format?: true
    userId?: true
    createdAt?: true
  }

  export type DocumentTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    content?: true
    format?: true
    userId?: true
    createdAt?: true
  }

  export type DocumentTemplateCountAggregateInputType = {
    id?: true
    name?: true
    content?: true
    format?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentTemplate to aggregate.
     */
    where?: DocumentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTemplates to fetch.
     */
    orderBy?: DocumentTemplateOrderByWithRelationInput | DocumentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentTemplates
    **/
    _count?: true | DocumentTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentTemplateMaxAggregateInputType
  }

  export type GetDocumentTemplateAggregateType<T extends DocumentTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentTemplate[P]>
      : GetScalarType<T[P], AggregateDocumentTemplate[P]>
  }




  export type DocumentTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentTemplateWhereInput
    orderBy?: DocumentTemplateOrderByWithAggregationInput | DocumentTemplateOrderByWithAggregationInput[]
    by: DocumentTemplateScalarFieldEnum[] | DocumentTemplateScalarFieldEnum
    having?: DocumentTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentTemplateCountAggregateInputType | true
    _min?: DocumentTemplateMinAggregateInputType
    _max?: DocumentTemplateMaxAggregateInputType
  }

  export type DocumentTemplateGroupByOutputType = {
    id: string
    name: string
    content: string
    format: string
    userId: string
    createdAt: Date
    _count: DocumentTemplateCountAggregateOutputType | null
    _min: DocumentTemplateMinAggregateOutputType | null
    _max: DocumentTemplateMaxAggregateOutputType | null
  }

  type GetDocumentTemplateGroupByPayload<T extends DocumentTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentTemplateGroupByOutputType[P]>
        }
      >
    >


  export type DocumentTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    format?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    GeneratedDocument?: boolean | DocumentTemplate$GeneratedDocumentArgs<ExtArgs>
    _count?: boolean | DocumentTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentTemplate"]>

  export type DocumentTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    format?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentTemplate"]>

  export type DocumentTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    format?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentTemplate"]>

  export type DocumentTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    content?: boolean
    format?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type DocumentTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "content" | "format" | "userId" | "createdAt", ExtArgs["result"]["documentTemplate"]>
  export type DocumentTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    GeneratedDocument?: boolean | DocumentTemplate$GeneratedDocumentArgs<ExtArgs>
    _count?: boolean | DocumentTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentTemplate"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      GeneratedDocument: Prisma.$GeneratedDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      content: string
      format: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["documentTemplate"]>
    composites: {}
  }

  type DocumentTemplateGetPayload<S extends boolean | null | undefined | DocumentTemplateDefaultArgs> = $Result.GetResult<Prisma.$DocumentTemplatePayload, S>

  type DocumentTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentTemplateCountAggregateInputType | true
    }

  export interface DocumentTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentTemplate'], meta: { name: 'DocumentTemplate' } }
    /**
     * Find zero or one DocumentTemplate that matches the filter.
     * @param {DocumentTemplateFindUniqueArgs} args - Arguments to find a DocumentTemplate
     * @example
     * // Get one DocumentTemplate
     * const documentTemplate = await prisma.documentTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentTemplateFindUniqueArgs>(args: SelectSubset<T, DocumentTemplateFindUniqueArgs<ExtArgs>>): Prisma__DocumentTemplateClient<$Result.GetResult<Prisma.$DocumentTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentTemplateFindUniqueOrThrowArgs} args - Arguments to find a DocumentTemplate
     * @example
     * // Get one DocumentTemplate
     * const documentTemplate = await prisma.documentTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentTemplateClient<$Result.GetResult<Prisma.$DocumentTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTemplateFindFirstArgs} args - Arguments to find a DocumentTemplate
     * @example
     * // Get one DocumentTemplate
     * const documentTemplate = await prisma.documentTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentTemplateFindFirstArgs>(args?: SelectSubset<T, DocumentTemplateFindFirstArgs<ExtArgs>>): Prisma__DocumentTemplateClient<$Result.GetResult<Prisma.$DocumentTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTemplateFindFirstOrThrowArgs} args - Arguments to find a DocumentTemplate
     * @example
     * // Get one DocumentTemplate
     * const documentTemplate = await prisma.documentTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentTemplateClient<$Result.GetResult<Prisma.$DocumentTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentTemplates
     * const documentTemplates = await prisma.documentTemplate.findMany()
     * 
     * // Get first 10 DocumentTemplates
     * const documentTemplates = await prisma.documentTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentTemplateWithIdOnly = await prisma.documentTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentTemplateFindManyArgs>(args?: SelectSubset<T, DocumentTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentTemplate.
     * @param {DocumentTemplateCreateArgs} args - Arguments to create a DocumentTemplate.
     * @example
     * // Create one DocumentTemplate
     * const DocumentTemplate = await prisma.documentTemplate.create({
     *   data: {
     *     // ... data to create a DocumentTemplate
     *   }
     * })
     * 
     */
    create<T extends DocumentTemplateCreateArgs>(args: SelectSubset<T, DocumentTemplateCreateArgs<ExtArgs>>): Prisma__DocumentTemplateClient<$Result.GetResult<Prisma.$DocumentTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentTemplates.
     * @param {DocumentTemplateCreateManyArgs} args - Arguments to create many DocumentTemplates.
     * @example
     * // Create many DocumentTemplates
     * const documentTemplate = await prisma.documentTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentTemplateCreateManyArgs>(args?: SelectSubset<T, DocumentTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentTemplates and returns the data saved in the database.
     * @param {DocumentTemplateCreateManyAndReturnArgs} args - Arguments to create many DocumentTemplates.
     * @example
     * // Create many DocumentTemplates
     * const documentTemplate = await prisma.documentTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentTemplates and only return the `id`
     * const documentTemplateWithIdOnly = await prisma.documentTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentTemplate.
     * @param {DocumentTemplateDeleteArgs} args - Arguments to delete one DocumentTemplate.
     * @example
     * // Delete one DocumentTemplate
     * const DocumentTemplate = await prisma.documentTemplate.delete({
     *   where: {
     *     // ... filter to delete one DocumentTemplate
     *   }
     * })
     * 
     */
    delete<T extends DocumentTemplateDeleteArgs>(args: SelectSubset<T, DocumentTemplateDeleteArgs<ExtArgs>>): Prisma__DocumentTemplateClient<$Result.GetResult<Prisma.$DocumentTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentTemplate.
     * @param {DocumentTemplateUpdateArgs} args - Arguments to update one DocumentTemplate.
     * @example
     * // Update one DocumentTemplate
     * const documentTemplate = await prisma.documentTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentTemplateUpdateArgs>(args: SelectSubset<T, DocumentTemplateUpdateArgs<ExtArgs>>): Prisma__DocumentTemplateClient<$Result.GetResult<Prisma.$DocumentTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentTemplates.
     * @param {DocumentTemplateDeleteManyArgs} args - Arguments to filter DocumentTemplates to delete.
     * @example
     * // Delete a few DocumentTemplates
     * const { count } = await prisma.documentTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentTemplateDeleteManyArgs>(args?: SelectSubset<T, DocumentTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentTemplates
     * const documentTemplate = await prisma.documentTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentTemplateUpdateManyArgs>(args: SelectSubset<T, DocumentTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentTemplates and returns the data updated in the database.
     * @param {DocumentTemplateUpdateManyAndReturnArgs} args - Arguments to update many DocumentTemplates.
     * @example
     * // Update many DocumentTemplates
     * const documentTemplate = await prisma.documentTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentTemplates and only return the `id`
     * const documentTemplateWithIdOnly = await prisma.documentTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentTemplate.
     * @param {DocumentTemplateUpsertArgs} args - Arguments to update or create a DocumentTemplate.
     * @example
     * // Update or create a DocumentTemplate
     * const documentTemplate = await prisma.documentTemplate.upsert({
     *   create: {
     *     // ... data to create a DocumentTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentTemplate we want to update
     *   }
     * })
     */
    upsert<T extends DocumentTemplateUpsertArgs>(args: SelectSubset<T, DocumentTemplateUpsertArgs<ExtArgs>>): Prisma__DocumentTemplateClient<$Result.GetResult<Prisma.$DocumentTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTemplateCountArgs} args - Arguments to filter DocumentTemplates to count.
     * @example
     * // Count the number of DocumentTemplates
     * const count = await prisma.documentTemplate.count({
     *   where: {
     *     // ... the filter for the DocumentTemplates we want to count
     *   }
     * })
    **/
    count<T extends DocumentTemplateCountArgs>(
      args?: Subset<T, DocumentTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentTemplateAggregateArgs>(args: Subset<T, DocumentTemplateAggregateArgs>): Prisma.PrismaPromise<GetDocumentTemplateAggregateType<T>>

    /**
     * Group by DocumentTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentTemplateGroupByArgs['orderBy'] }
        : { orderBy?: DocumentTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentTemplate model
   */
  readonly fields: DocumentTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    GeneratedDocument<T extends DocumentTemplate$GeneratedDocumentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentTemplate$GeneratedDocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentTemplate model
   */
  interface DocumentTemplateFieldRefs {
    readonly id: FieldRef<"DocumentTemplate", 'String'>
    readonly name: FieldRef<"DocumentTemplate", 'String'>
    readonly content: FieldRef<"DocumentTemplate", 'String'>
    readonly format: FieldRef<"DocumentTemplate", 'String'>
    readonly userId: FieldRef<"DocumentTemplate", 'String'>
    readonly createdAt: FieldRef<"DocumentTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentTemplate findUnique
   */
  export type DocumentTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTemplate
     */
    select?: DocumentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTemplate
     */
    omit?: DocumentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTemplate to fetch.
     */
    where: DocumentTemplateWhereUniqueInput
  }

  /**
   * DocumentTemplate findUniqueOrThrow
   */
  export type DocumentTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTemplate
     */
    select?: DocumentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTemplate
     */
    omit?: DocumentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTemplate to fetch.
     */
    where: DocumentTemplateWhereUniqueInput
  }

  /**
   * DocumentTemplate findFirst
   */
  export type DocumentTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTemplate
     */
    select?: DocumentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTemplate
     */
    omit?: DocumentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTemplate to fetch.
     */
    where?: DocumentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTemplates to fetch.
     */
    orderBy?: DocumentTemplateOrderByWithRelationInput | DocumentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentTemplates.
     */
    cursor?: DocumentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentTemplates.
     */
    distinct?: DocumentTemplateScalarFieldEnum | DocumentTemplateScalarFieldEnum[]
  }

  /**
   * DocumentTemplate findFirstOrThrow
   */
  export type DocumentTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTemplate
     */
    select?: DocumentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTemplate
     */
    omit?: DocumentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTemplate to fetch.
     */
    where?: DocumentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTemplates to fetch.
     */
    orderBy?: DocumentTemplateOrderByWithRelationInput | DocumentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentTemplates.
     */
    cursor?: DocumentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentTemplates.
     */
    distinct?: DocumentTemplateScalarFieldEnum | DocumentTemplateScalarFieldEnum[]
  }

  /**
   * DocumentTemplate findMany
   */
  export type DocumentTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTemplate
     */
    select?: DocumentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTemplate
     */
    omit?: DocumentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTemplates to fetch.
     */
    where?: DocumentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTemplates to fetch.
     */
    orderBy?: DocumentTemplateOrderByWithRelationInput | DocumentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentTemplates.
     */
    cursor?: DocumentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTemplates.
     */
    skip?: number
    distinct?: DocumentTemplateScalarFieldEnum | DocumentTemplateScalarFieldEnum[]
  }

  /**
   * DocumentTemplate create
   */
  export type DocumentTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTemplate
     */
    select?: DocumentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTemplate
     */
    omit?: DocumentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentTemplate.
     */
    data: XOR<DocumentTemplateCreateInput, DocumentTemplateUncheckedCreateInput>
  }

  /**
   * DocumentTemplate createMany
   */
  export type DocumentTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentTemplates.
     */
    data: DocumentTemplateCreateManyInput | DocumentTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentTemplate createManyAndReturn
   */
  export type DocumentTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTemplate
     */
    select?: DocumentTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTemplate
     */
    omit?: DocumentTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentTemplates.
     */
    data: DocumentTemplateCreateManyInput | DocumentTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentTemplate update
   */
  export type DocumentTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTemplate
     */
    select?: DocumentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTemplate
     */
    omit?: DocumentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentTemplate.
     */
    data: XOR<DocumentTemplateUpdateInput, DocumentTemplateUncheckedUpdateInput>
    /**
     * Choose, which DocumentTemplate to update.
     */
    where: DocumentTemplateWhereUniqueInput
  }

  /**
   * DocumentTemplate updateMany
   */
  export type DocumentTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentTemplates.
     */
    data: XOR<DocumentTemplateUpdateManyMutationInput, DocumentTemplateUncheckedUpdateManyInput>
    /**
     * Filter which DocumentTemplates to update
     */
    where?: DocumentTemplateWhereInput
    /**
     * Limit how many DocumentTemplates to update.
     */
    limit?: number
  }

  /**
   * DocumentTemplate updateManyAndReturn
   */
  export type DocumentTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTemplate
     */
    select?: DocumentTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTemplate
     */
    omit?: DocumentTemplateOmit<ExtArgs> | null
    /**
     * The data used to update DocumentTemplates.
     */
    data: XOR<DocumentTemplateUpdateManyMutationInput, DocumentTemplateUncheckedUpdateManyInput>
    /**
     * Filter which DocumentTemplates to update
     */
    where?: DocumentTemplateWhereInput
    /**
     * Limit how many DocumentTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentTemplate upsert
   */
  export type DocumentTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTemplate
     */
    select?: DocumentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTemplate
     */
    omit?: DocumentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentTemplate to update in case it exists.
     */
    where: DocumentTemplateWhereUniqueInput
    /**
     * In case the DocumentTemplate found by the `where` argument doesn't exist, create a new DocumentTemplate with this data.
     */
    create: XOR<DocumentTemplateCreateInput, DocumentTemplateUncheckedCreateInput>
    /**
     * In case the DocumentTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentTemplateUpdateInput, DocumentTemplateUncheckedUpdateInput>
  }

  /**
   * DocumentTemplate delete
   */
  export type DocumentTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTemplate
     */
    select?: DocumentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTemplate
     */
    omit?: DocumentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTemplateInclude<ExtArgs> | null
    /**
     * Filter which DocumentTemplate to delete.
     */
    where: DocumentTemplateWhereUniqueInput
  }

  /**
   * DocumentTemplate deleteMany
   */
  export type DocumentTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentTemplates to delete
     */
    where?: DocumentTemplateWhereInput
    /**
     * Limit how many DocumentTemplates to delete.
     */
    limit?: number
  }

  /**
   * DocumentTemplate.GeneratedDocument
   */
  export type DocumentTemplate$GeneratedDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedDocument
     */
    select?: GeneratedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedDocument
     */
    omit?: GeneratedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedDocumentInclude<ExtArgs> | null
    where?: GeneratedDocumentWhereInput
    orderBy?: GeneratedDocumentOrderByWithRelationInput | GeneratedDocumentOrderByWithRelationInput[]
    cursor?: GeneratedDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedDocumentScalarFieldEnum | GeneratedDocumentScalarFieldEnum[]
  }

  /**
   * DocumentTemplate without action
   */
  export type DocumentTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTemplate
     */
    select?: DocumentTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTemplate
     */
    omit?: DocumentTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTemplateInclude<ExtArgs> | null
  }


  /**
   * Model GeneratedDocument
   */

  export type AggregateGeneratedDocument = {
    _count: GeneratedDocumentCountAggregateOutputType | null
    _min: GeneratedDocumentMinAggregateOutputType | null
    _max: GeneratedDocumentMaxAggregateOutputType | null
  }

  export type GeneratedDocumentMinAggregateOutputType = {
    id: string | null
    filePath: string | null
    format: string | null
    templateId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type GeneratedDocumentMaxAggregateOutputType = {
    id: string | null
    filePath: string | null
    format: string | null
    templateId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type GeneratedDocumentCountAggregateOutputType = {
    id: number
    filePath: number
    format: number
    templateId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type GeneratedDocumentMinAggregateInputType = {
    id?: true
    filePath?: true
    format?: true
    templateId?: true
    userId?: true
    createdAt?: true
  }

  export type GeneratedDocumentMaxAggregateInputType = {
    id?: true
    filePath?: true
    format?: true
    templateId?: true
    userId?: true
    createdAt?: true
  }

  export type GeneratedDocumentCountAggregateInputType = {
    id?: true
    filePath?: true
    format?: true
    templateId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type GeneratedDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedDocument to aggregate.
     */
    where?: GeneratedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedDocuments to fetch.
     */
    orderBy?: GeneratedDocumentOrderByWithRelationInput | GeneratedDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeneratedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeneratedDocuments
    **/
    _count?: true | GeneratedDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneratedDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneratedDocumentMaxAggregateInputType
  }

  export type GetGeneratedDocumentAggregateType<T extends GeneratedDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneratedDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneratedDocument[P]>
      : GetScalarType<T[P], AggregateGeneratedDocument[P]>
  }




  export type GeneratedDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedDocumentWhereInput
    orderBy?: GeneratedDocumentOrderByWithAggregationInput | GeneratedDocumentOrderByWithAggregationInput[]
    by: GeneratedDocumentScalarFieldEnum[] | GeneratedDocumentScalarFieldEnum
    having?: GeneratedDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneratedDocumentCountAggregateInputType | true
    _min?: GeneratedDocumentMinAggregateInputType
    _max?: GeneratedDocumentMaxAggregateInputType
  }

  export type GeneratedDocumentGroupByOutputType = {
    id: string
    filePath: string
    format: string
    templateId: string
    userId: string
    createdAt: Date
    _count: GeneratedDocumentCountAggregateOutputType | null
    _min: GeneratedDocumentMinAggregateOutputType | null
    _max: GeneratedDocumentMaxAggregateOutputType | null
  }

  type GetGeneratedDocumentGroupByPayload<T extends GeneratedDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeneratedDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneratedDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneratedDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], GeneratedDocumentGroupByOutputType[P]>
        }
      >
    >


  export type GeneratedDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filePath?: boolean
    format?: boolean
    templateId?: boolean
    userId?: boolean
    createdAt?: boolean
    template?: boolean | DocumentTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generatedDocument"]>

  export type GeneratedDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filePath?: boolean
    format?: boolean
    templateId?: boolean
    userId?: boolean
    createdAt?: boolean
    template?: boolean | DocumentTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generatedDocument"]>

  export type GeneratedDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filePath?: boolean
    format?: boolean
    templateId?: boolean
    userId?: boolean
    createdAt?: boolean
    template?: boolean | DocumentTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generatedDocument"]>

  export type GeneratedDocumentSelectScalar = {
    id?: boolean
    filePath?: boolean
    format?: boolean
    templateId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type GeneratedDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filePath" | "format" | "templateId" | "userId" | "createdAt", ExtArgs["result"]["generatedDocument"]>
  export type GeneratedDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | DocumentTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GeneratedDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | DocumentTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GeneratedDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | DocumentTemplateDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GeneratedDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeneratedDocument"
    objects: {
      template: Prisma.$DocumentTemplatePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filePath: string
      format: string
      templateId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["generatedDocument"]>
    composites: {}
  }

  type GeneratedDocumentGetPayload<S extends boolean | null | undefined | GeneratedDocumentDefaultArgs> = $Result.GetResult<Prisma.$GeneratedDocumentPayload, S>

  type GeneratedDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GeneratedDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeneratedDocumentCountAggregateInputType | true
    }

  export interface GeneratedDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeneratedDocument'], meta: { name: 'GeneratedDocument' } }
    /**
     * Find zero or one GeneratedDocument that matches the filter.
     * @param {GeneratedDocumentFindUniqueArgs} args - Arguments to find a GeneratedDocument
     * @example
     * // Get one GeneratedDocument
     * const generatedDocument = await prisma.generatedDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeneratedDocumentFindUniqueArgs>(args: SelectSubset<T, GeneratedDocumentFindUniqueArgs<ExtArgs>>): Prisma__GeneratedDocumentClient<$Result.GetResult<Prisma.$GeneratedDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GeneratedDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeneratedDocumentFindUniqueOrThrowArgs} args - Arguments to find a GeneratedDocument
     * @example
     * // Get one GeneratedDocument
     * const generatedDocument = await prisma.generatedDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeneratedDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, GeneratedDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeneratedDocumentClient<$Result.GetResult<Prisma.$GeneratedDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeneratedDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedDocumentFindFirstArgs} args - Arguments to find a GeneratedDocument
     * @example
     * // Get one GeneratedDocument
     * const generatedDocument = await prisma.generatedDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeneratedDocumentFindFirstArgs>(args?: SelectSubset<T, GeneratedDocumentFindFirstArgs<ExtArgs>>): Prisma__GeneratedDocumentClient<$Result.GetResult<Prisma.$GeneratedDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeneratedDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedDocumentFindFirstOrThrowArgs} args - Arguments to find a GeneratedDocument
     * @example
     * // Get one GeneratedDocument
     * const generatedDocument = await prisma.generatedDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeneratedDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, GeneratedDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeneratedDocumentClient<$Result.GetResult<Prisma.$GeneratedDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GeneratedDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeneratedDocuments
     * const generatedDocuments = await prisma.generatedDocument.findMany()
     * 
     * // Get first 10 GeneratedDocuments
     * const generatedDocuments = await prisma.generatedDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generatedDocumentWithIdOnly = await prisma.generatedDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeneratedDocumentFindManyArgs>(args?: SelectSubset<T, GeneratedDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GeneratedDocument.
     * @param {GeneratedDocumentCreateArgs} args - Arguments to create a GeneratedDocument.
     * @example
     * // Create one GeneratedDocument
     * const GeneratedDocument = await prisma.generatedDocument.create({
     *   data: {
     *     // ... data to create a GeneratedDocument
     *   }
     * })
     * 
     */
    create<T extends GeneratedDocumentCreateArgs>(args: SelectSubset<T, GeneratedDocumentCreateArgs<ExtArgs>>): Prisma__GeneratedDocumentClient<$Result.GetResult<Prisma.$GeneratedDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GeneratedDocuments.
     * @param {GeneratedDocumentCreateManyArgs} args - Arguments to create many GeneratedDocuments.
     * @example
     * // Create many GeneratedDocuments
     * const generatedDocument = await prisma.generatedDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeneratedDocumentCreateManyArgs>(args?: SelectSubset<T, GeneratedDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeneratedDocuments and returns the data saved in the database.
     * @param {GeneratedDocumentCreateManyAndReturnArgs} args - Arguments to create many GeneratedDocuments.
     * @example
     * // Create many GeneratedDocuments
     * const generatedDocument = await prisma.generatedDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeneratedDocuments and only return the `id`
     * const generatedDocumentWithIdOnly = await prisma.generatedDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeneratedDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, GeneratedDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GeneratedDocument.
     * @param {GeneratedDocumentDeleteArgs} args - Arguments to delete one GeneratedDocument.
     * @example
     * // Delete one GeneratedDocument
     * const GeneratedDocument = await prisma.generatedDocument.delete({
     *   where: {
     *     // ... filter to delete one GeneratedDocument
     *   }
     * })
     * 
     */
    delete<T extends GeneratedDocumentDeleteArgs>(args: SelectSubset<T, GeneratedDocumentDeleteArgs<ExtArgs>>): Prisma__GeneratedDocumentClient<$Result.GetResult<Prisma.$GeneratedDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GeneratedDocument.
     * @param {GeneratedDocumentUpdateArgs} args - Arguments to update one GeneratedDocument.
     * @example
     * // Update one GeneratedDocument
     * const generatedDocument = await prisma.generatedDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeneratedDocumentUpdateArgs>(args: SelectSubset<T, GeneratedDocumentUpdateArgs<ExtArgs>>): Prisma__GeneratedDocumentClient<$Result.GetResult<Prisma.$GeneratedDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GeneratedDocuments.
     * @param {GeneratedDocumentDeleteManyArgs} args - Arguments to filter GeneratedDocuments to delete.
     * @example
     * // Delete a few GeneratedDocuments
     * const { count } = await prisma.generatedDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeneratedDocumentDeleteManyArgs>(args?: SelectSubset<T, GeneratedDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneratedDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeneratedDocuments
     * const generatedDocument = await prisma.generatedDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeneratedDocumentUpdateManyArgs>(args: SelectSubset<T, GeneratedDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneratedDocuments and returns the data updated in the database.
     * @param {GeneratedDocumentUpdateManyAndReturnArgs} args - Arguments to update many GeneratedDocuments.
     * @example
     * // Update many GeneratedDocuments
     * const generatedDocument = await prisma.generatedDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GeneratedDocuments and only return the `id`
     * const generatedDocumentWithIdOnly = await prisma.generatedDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GeneratedDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, GeneratedDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GeneratedDocument.
     * @param {GeneratedDocumentUpsertArgs} args - Arguments to update or create a GeneratedDocument.
     * @example
     * // Update or create a GeneratedDocument
     * const generatedDocument = await prisma.generatedDocument.upsert({
     *   create: {
     *     // ... data to create a GeneratedDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeneratedDocument we want to update
     *   }
     * })
     */
    upsert<T extends GeneratedDocumentUpsertArgs>(args: SelectSubset<T, GeneratedDocumentUpsertArgs<ExtArgs>>): Prisma__GeneratedDocumentClient<$Result.GetResult<Prisma.$GeneratedDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GeneratedDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedDocumentCountArgs} args - Arguments to filter GeneratedDocuments to count.
     * @example
     * // Count the number of GeneratedDocuments
     * const count = await prisma.generatedDocument.count({
     *   where: {
     *     // ... the filter for the GeneratedDocuments we want to count
     *   }
     * })
    **/
    count<T extends GeneratedDocumentCountArgs>(
      args?: Subset<T, GeneratedDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneratedDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeneratedDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneratedDocumentAggregateArgs>(args: Subset<T, GeneratedDocumentAggregateArgs>): Prisma.PrismaPromise<GetGeneratedDocumentAggregateType<T>>

    /**
     * Group by GeneratedDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeneratedDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneratedDocumentGroupByArgs['orderBy'] }
        : { orderBy?: GeneratedDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeneratedDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneratedDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeneratedDocument model
   */
  readonly fields: GeneratedDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeneratedDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeneratedDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends DocumentTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentTemplateDefaultArgs<ExtArgs>>): Prisma__DocumentTemplateClient<$Result.GetResult<Prisma.$DocumentTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeneratedDocument model
   */
  interface GeneratedDocumentFieldRefs {
    readonly id: FieldRef<"GeneratedDocument", 'String'>
    readonly filePath: FieldRef<"GeneratedDocument", 'String'>
    readonly format: FieldRef<"GeneratedDocument", 'String'>
    readonly templateId: FieldRef<"GeneratedDocument", 'String'>
    readonly userId: FieldRef<"GeneratedDocument", 'String'>
    readonly createdAt: FieldRef<"GeneratedDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GeneratedDocument findUnique
   */
  export type GeneratedDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedDocument
     */
    select?: GeneratedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedDocument
     */
    omit?: GeneratedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedDocument to fetch.
     */
    where: GeneratedDocumentWhereUniqueInput
  }

  /**
   * GeneratedDocument findUniqueOrThrow
   */
  export type GeneratedDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedDocument
     */
    select?: GeneratedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedDocument
     */
    omit?: GeneratedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedDocument to fetch.
     */
    where: GeneratedDocumentWhereUniqueInput
  }

  /**
   * GeneratedDocument findFirst
   */
  export type GeneratedDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedDocument
     */
    select?: GeneratedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedDocument
     */
    omit?: GeneratedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedDocument to fetch.
     */
    where?: GeneratedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedDocuments to fetch.
     */
    orderBy?: GeneratedDocumentOrderByWithRelationInput | GeneratedDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedDocuments.
     */
    cursor?: GeneratedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedDocuments.
     */
    distinct?: GeneratedDocumentScalarFieldEnum | GeneratedDocumentScalarFieldEnum[]
  }

  /**
   * GeneratedDocument findFirstOrThrow
   */
  export type GeneratedDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedDocument
     */
    select?: GeneratedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedDocument
     */
    omit?: GeneratedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedDocument to fetch.
     */
    where?: GeneratedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedDocuments to fetch.
     */
    orderBy?: GeneratedDocumentOrderByWithRelationInput | GeneratedDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedDocuments.
     */
    cursor?: GeneratedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedDocuments.
     */
    distinct?: GeneratedDocumentScalarFieldEnum | GeneratedDocumentScalarFieldEnum[]
  }

  /**
   * GeneratedDocument findMany
   */
  export type GeneratedDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedDocument
     */
    select?: GeneratedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedDocument
     */
    omit?: GeneratedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedDocuments to fetch.
     */
    where?: GeneratedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedDocuments to fetch.
     */
    orderBy?: GeneratedDocumentOrderByWithRelationInput | GeneratedDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeneratedDocuments.
     */
    cursor?: GeneratedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedDocuments.
     */
    skip?: number
    distinct?: GeneratedDocumentScalarFieldEnum | GeneratedDocumentScalarFieldEnum[]
  }

  /**
   * GeneratedDocument create
   */
  export type GeneratedDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedDocument
     */
    select?: GeneratedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedDocument
     */
    omit?: GeneratedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a GeneratedDocument.
     */
    data: XOR<GeneratedDocumentCreateInput, GeneratedDocumentUncheckedCreateInput>
  }

  /**
   * GeneratedDocument createMany
   */
  export type GeneratedDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeneratedDocuments.
     */
    data: GeneratedDocumentCreateManyInput | GeneratedDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeneratedDocument createManyAndReturn
   */
  export type GeneratedDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedDocument
     */
    select?: GeneratedDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedDocument
     */
    omit?: GeneratedDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many GeneratedDocuments.
     */
    data: GeneratedDocumentCreateManyInput | GeneratedDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneratedDocument update
   */
  export type GeneratedDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedDocument
     */
    select?: GeneratedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedDocument
     */
    omit?: GeneratedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a GeneratedDocument.
     */
    data: XOR<GeneratedDocumentUpdateInput, GeneratedDocumentUncheckedUpdateInput>
    /**
     * Choose, which GeneratedDocument to update.
     */
    where: GeneratedDocumentWhereUniqueInput
  }

  /**
   * GeneratedDocument updateMany
   */
  export type GeneratedDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeneratedDocuments.
     */
    data: XOR<GeneratedDocumentUpdateManyMutationInput, GeneratedDocumentUncheckedUpdateManyInput>
    /**
     * Filter which GeneratedDocuments to update
     */
    where?: GeneratedDocumentWhereInput
    /**
     * Limit how many GeneratedDocuments to update.
     */
    limit?: number
  }

  /**
   * GeneratedDocument updateManyAndReturn
   */
  export type GeneratedDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedDocument
     */
    select?: GeneratedDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedDocument
     */
    omit?: GeneratedDocumentOmit<ExtArgs> | null
    /**
     * The data used to update GeneratedDocuments.
     */
    data: XOR<GeneratedDocumentUpdateManyMutationInput, GeneratedDocumentUncheckedUpdateManyInput>
    /**
     * Filter which GeneratedDocuments to update
     */
    where?: GeneratedDocumentWhereInput
    /**
     * Limit how many GeneratedDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneratedDocument upsert
   */
  export type GeneratedDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedDocument
     */
    select?: GeneratedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedDocument
     */
    omit?: GeneratedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the GeneratedDocument to update in case it exists.
     */
    where: GeneratedDocumentWhereUniqueInput
    /**
     * In case the GeneratedDocument found by the `where` argument doesn't exist, create a new GeneratedDocument with this data.
     */
    create: XOR<GeneratedDocumentCreateInput, GeneratedDocumentUncheckedCreateInput>
    /**
     * In case the GeneratedDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeneratedDocumentUpdateInput, GeneratedDocumentUncheckedUpdateInput>
  }

  /**
   * GeneratedDocument delete
   */
  export type GeneratedDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedDocument
     */
    select?: GeneratedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedDocument
     */
    omit?: GeneratedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedDocumentInclude<ExtArgs> | null
    /**
     * Filter which GeneratedDocument to delete.
     */
    where: GeneratedDocumentWhereUniqueInput
  }

  /**
   * GeneratedDocument deleteMany
   */
  export type GeneratedDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedDocuments to delete
     */
    where?: GeneratedDocumentWhereInput
    /**
     * Limit how many GeneratedDocuments to delete.
     */
    limit?: number
  }

  /**
   * GeneratedDocument without action
   */
  export type GeneratedDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedDocument
     */
    select?: GeneratedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedDocument
     */
    omit?: GeneratedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedDocumentInclude<ExtArgs> | null
  }


  /**
   * Model FileFolder
   */

  export type AggregateFileFolder = {
    _count: FileFolderCountAggregateOutputType | null
    _min: FileFolderMinAggregateOutputType | null
    _max: FileFolderMaxAggregateOutputType | null
  }

  export type FileFolderMinAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
    userId: string | null
    access: string | null
    createdAt: Date | null
    accountId: string | null
    dealId: string | null
  }

  export type FileFolderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
    userId: string | null
    access: string | null
    createdAt: Date | null
    accountId: string | null
    dealId: string | null
  }

  export type FileFolderCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    userId: number
    access: number
    createdAt: number
    accountId: number
    dealId: number
    _all: number
  }


  export type FileFolderMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    userId?: true
    access?: true
    createdAt?: true
    accountId?: true
    dealId?: true
  }

  export type FileFolderMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    userId?: true
    access?: true
    createdAt?: true
    accountId?: true
    dealId?: true
  }

  export type FileFolderCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    userId?: true
    access?: true
    createdAt?: true
    accountId?: true
    dealId?: true
    _all?: true
  }

  export type FileFolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileFolder to aggregate.
     */
    where?: FileFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileFolders to fetch.
     */
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileFolders
    **/
    _count?: true | FileFolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileFolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileFolderMaxAggregateInputType
  }

  export type GetFileFolderAggregateType<T extends FileFolderAggregateArgs> = {
        [P in keyof T & keyof AggregateFileFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileFolder[P]>
      : GetScalarType<T[P], AggregateFileFolder[P]>
  }




  export type FileFolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileFolderWhereInput
    orderBy?: FileFolderOrderByWithAggregationInput | FileFolderOrderByWithAggregationInput[]
    by: FileFolderScalarFieldEnum[] | FileFolderScalarFieldEnum
    having?: FileFolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileFolderCountAggregateInputType | true
    _min?: FileFolderMinAggregateInputType
    _max?: FileFolderMaxAggregateInputType
  }

  export type FileFolderGroupByOutputType = {
    id: string
    name: string
    parentId: string | null
    userId: string
    access: string
    createdAt: Date
    accountId: string | null
    dealId: string | null
    _count: FileFolderCountAggregateOutputType | null
    _min: FileFolderMinAggregateOutputType | null
    _max: FileFolderMaxAggregateOutputType | null
  }

  type GetFileFolderGroupByPayload<T extends FileFolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileFolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileFolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileFolderGroupByOutputType[P]>
            : GetScalarType<T[P], FileFolderGroupByOutputType[P]>
        }
      >
    >


  export type FileFolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    userId?: boolean
    access?: boolean
    createdAt?: boolean
    accountId?: boolean
    dealId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    files?: boolean | FileFolder$filesArgs<ExtArgs>
    _count?: boolean | FileFolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileFolder"]>

  export type FileFolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    userId?: boolean
    access?: boolean
    createdAt?: boolean
    accountId?: boolean
    dealId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileFolder"]>

  export type FileFolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    userId?: boolean
    access?: boolean
    createdAt?: boolean
    accountId?: boolean
    dealId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileFolder"]>

  export type FileFolderSelectScalar = {
    id?: boolean
    name?: boolean
    parentId?: boolean
    userId?: boolean
    access?: boolean
    createdAt?: boolean
    accountId?: boolean
    dealId?: boolean
  }

  export type FileFolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "parentId" | "userId" | "access" | "createdAt" | "accountId" | "dealId", ExtArgs["result"]["fileFolder"]>
  export type FileFolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    files?: boolean | FileFolder$filesArgs<ExtArgs>
    _count?: boolean | FileFolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileFolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FileFolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FileFolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileFolder"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      files: Prisma.$FilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      parentId: string | null
      userId: string
      access: string
      createdAt: Date
      accountId: string | null
      dealId: string | null
    }, ExtArgs["result"]["fileFolder"]>
    composites: {}
  }

  type FileFolderGetPayload<S extends boolean | null | undefined | FileFolderDefaultArgs> = $Result.GetResult<Prisma.$FileFolderPayload, S>

  type FileFolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileFolderCountAggregateInputType | true
    }

  export interface FileFolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileFolder'], meta: { name: 'FileFolder' } }
    /**
     * Find zero or one FileFolder that matches the filter.
     * @param {FileFolderFindUniqueArgs} args - Arguments to find a FileFolder
     * @example
     * // Get one FileFolder
     * const fileFolder = await prisma.fileFolder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFolderFindUniqueArgs>(args: SelectSubset<T, FileFolderFindUniqueArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileFolder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFolderFindUniqueOrThrowArgs} args - Arguments to find a FileFolder
     * @example
     * // Get one FileFolder
     * const fileFolder = await prisma.fileFolder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFolderFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileFolder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderFindFirstArgs} args - Arguments to find a FileFolder
     * @example
     * // Get one FileFolder
     * const fileFolder = await prisma.fileFolder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFolderFindFirstArgs>(args?: SelectSubset<T, FileFolderFindFirstArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileFolder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderFindFirstOrThrowArgs} args - Arguments to find a FileFolder
     * @example
     * // Get one FileFolder
     * const fileFolder = await prisma.fileFolder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFolderFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileFolders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileFolders
     * const fileFolders = await prisma.fileFolder.findMany()
     * 
     * // Get first 10 FileFolders
     * const fileFolders = await prisma.fileFolder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileFolderWithIdOnly = await prisma.fileFolder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFolderFindManyArgs>(args?: SelectSubset<T, FileFolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileFolder.
     * @param {FileFolderCreateArgs} args - Arguments to create a FileFolder.
     * @example
     * // Create one FileFolder
     * const FileFolder = await prisma.fileFolder.create({
     *   data: {
     *     // ... data to create a FileFolder
     *   }
     * })
     * 
     */
    create<T extends FileFolderCreateArgs>(args: SelectSubset<T, FileFolderCreateArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileFolders.
     * @param {FileFolderCreateManyArgs} args - Arguments to create many FileFolders.
     * @example
     * // Create many FileFolders
     * const fileFolder = await prisma.fileFolder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileFolderCreateManyArgs>(args?: SelectSubset<T, FileFolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileFolders and returns the data saved in the database.
     * @param {FileFolderCreateManyAndReturnArgs} args - Arguments to create many FileFolders.
     * @example
     * // Create many FileFolders
     * const fileFolder = await prisma.fileFolder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileFolders and only return the `id`
     * const fileFolderWithIdOnly = await prisma.fileFolder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileFolderCreateManyAndReturnArgs>(args?: SelectSubset<T, FileFolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileFolder.
     * @param {FileFolderDeleteArgs} args - Arguments to delete one FileFolder.
     * @example
     * // Delete one FileFolder
     * const FileFolder = await prisma.fileFolder.delete({
     *   where: {
     *     // ... filter to delete one FileFolder
     *   }
     * })
     * 
     */
    delete<T extends FileFolderDeleteArgs>(args: SelectSubset<T, FileFolderDeleteArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileFolder.
     * @param {FileFolderUpdateArgs} args - Arguments to update one FileFolder.
     * @example
     * // Update one FileFolder
     * const fileFolder = await prisma.fileFolder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileFolderUpdateArgs>(args: SelectSubset<T, FileFolderUpdateArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileFolders.
     * @param {FileFolderDeleteManyArgs} args - Arguments to filter FileFolders to delete.
     * @example
     * // Delete a few FileFolders
     * const { count } = await prisma.fileFolder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileFolderDeleteManyArgs>(args?: SelectSubset<T, FileFolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileFolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileFolders
     * const fileFolder = await prisma.fileFolder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileFolderUpdateManyArgs>(args: SelectSubset<T, FileFolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileFolders and returns the data updated in the database.
     * @param {FileFolderUpdateManyAndReturnArgs} args - Arguments to update many FileFolders.
     * @example
     * // Update many FileFolders
     * const fileFolder = await prisma.fileFolder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileFolders and only return the `id`
     * const fileFolderWithIdOnly = await prisma.fileFolder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileFolderUpdateManyAndReturnArgs>(args: SelectSubset<T, FileFolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileFolder.
     * @param {FileFolderUpsertArgs} args - Arguments to update or create a FileFolder.
     * @example
     * // Update or create a FileFolder
     * const fileFolder = await prisma.fileFolder.upsert({
     *   create: {
     *     // ... data to create a FileFolder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileFolder we want to update
     *   }
     * })
     */
    upsert<T extends FileFolderUpsertArgs>(args: SelectSubset<T, FileFolderUpsertArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileFolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderCountArgs} args - Arguments to filter FileFolders to count.
     * @example
     * // Count the number of FileFolders
     * const count = await prisma.fileFolder.count({
     *   where: {
     *     // ... the filter for the FileFolders we want to count
     *   }
     * })
    **/
    count<T extends FileFolderCountArgs>(
      args?: Subset<T, FileFolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileFolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileFolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileFolderAggregateArgs>(args: Subset<T, FileFolderAggregateArgs>): Prisma.PrismaPromise<GetFileFolderAggregateType<T>>

    /**
     * Group by FileFolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileFolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileFolderGroupByArgs['orderBy'] }
        : { orderBy?: FileFolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileFolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileFolder model
   */
  readonly fields: FileFolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileFolder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileFolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    files<T extends FileFolder$filesArgs<ExtArgs> = {}>(args?: Subset<T, FileFolder$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileFolder model
   */
  interface FileFolderFieldRefs {
    readonly id: FieldRef<"FileFolder", 'String'>
    readonly name: FieldRef<"FileFolder", 'String'>
    readonly parentId: FieldRef<"FileFolder", 'String'>
    readonly userId: FieldRef<"FileFolder", 'String'>
    readonly access: FieldRef<"FileFolder", 'String'>
    readonly createdAt: FieldRef<"FileFolder", 'DateTime'>
    readonly accountId: FieldRef<"FileFolder", 'String'>
    readonly dealId: FieldRef<"FileFolder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FileFolder findUnique
   */
  export type FileFolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileFolder
     */
    omit?: FileFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolder to fetch.
     */
    where: FileFolderWhereUniqueInput
  }

  /**
   * FileFolder findUniqueOrThrow
   */
  export type FileFolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileFolder
     */
    omit?: FileFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolder to fetch.
     */
    where: FileFolderWhereUniqueInput
  }

  /**
   * FileFolder findFirst
   */
  export type FileFolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileFolder
     */
    omit?: FileFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolder to fetch.
     */
    where?: FileFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileFolders to fetch.
     */
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileFolders.
     */
    cursor?: FileFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileFolders.
     */
    distinct?: FileFolderScalarFieldEnum | FileFolderScalarFieldEnum[]
  }

  /**
   * FileFolder findFirstOrThrow
   */
  export type FileFolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileFolder
     */
    omit?: FileFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolder to fetch.
     */
    where?: FileFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileFolders to fetch.
     */
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileFolders.
     */
    cursor?: FileFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileFolders.
     */
    distinct?: FileFolderScalarFieldEnum | FileFolderScalarFieldEnum[]
  }

  /**
   * FileFolder findMany
   */
  export type FileFolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileFolder
     */
    omit?: FileFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolders to fetch.
     */
    where?: FileFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileFolders to fetch.
     */
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileFolders.
     */
    cursor?: FileFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileFolders.
     */
    skip?: number
    distinct?: FileFolderScalarFieldEnum | FileFolderScalarFieldEnum[]
  }

  /**
   * FileFolder create
   */
  export type FileFolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileFolder
     */
    omit?: FileFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * The data needed to create a FileFolder.
     */
    data: XOR<FileFolderCreateInput, FileFolderUncheckedCreateInput>
  }

  /**
   * FileFolder createMany
   */
  export type FileFolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileFolders.
     */
    data: FileFolderCreateManyInput | FileFolderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileFolder createManyAndReturn
   */
  export type FileFolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileFolder
     */
    omit?: FileFolderOmit<ExtArgs> | null
    /**
     * The data used to create many FileFolders.
     */
    data: FileFolderCreateManyInput | FileFolderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileFolder update
   */
  export type FileFolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileFolder
     */
    omit?: FileFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * The data needed to update a FileFolder.
     */
    data: XOR<FileFolderUpdateInput, FileFolderUncheckedUpdateInput>
    /**
     * Choose, which FileFolder to update.
     */
    where: FileFolderWhereUniqueInput
  }

  /**
   * FileFolder updateMany
   */
  export type FileFolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileFolders.
     */
    data: XOR<FileFolderUpdateManyMutationInput, FileFolderUncheckedUpdateManyInput>
    /**
     * Filter which FileFolders to update
     */
    where?: FileFolderWhereInput
    /**
     * Limit how many FileFolders to update.
     */
    limit?: number
  }

  /**
   * FileFolder updateManyAndReturn
   */
  export type FileFolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileFolder
     */
    omit?: FileFolderOmit<ExtArgs> | null
    /**
     * The data used to update FileFolders.
     */
    data: XOR<FileFolderUpdateManyMutationInput, FileFolderUncheckedUpdateManyInput>
    /**
     * Filter which FileFolders to update
     */
    where?: FileFolderWhereInput
    /**
     * Limit how many FileFolders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileFolder upsert
   */
  export type FileFolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileFolder
     */
    omit?: FileFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * The filter to search for the FileFolder to update in case it exists.
     */
    where: FileFolderWhereUniqueInput
    /**
     * In case the FileFolder found by the `where` argument doesn't exist, create a new FileFolder with this data.
     */
    create: XOR<FileFolderCreateInput, FileFolderUncheckedCreateInput>
    /**
     * In case the FileFolder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileFolderUpdateInput, FileFolderUncheckedUpdateInput>
  }

  /**
   * FileFolder delete
   */
  export type FileFolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileFolder
     */
    omit?: FileFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter which FileFolder to delete.
     */
    where: FileFolderWhereUniqueInput
  }

  /**
   * FileFolder deleteMany
   */
  export type FileFolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileFolders to delete
     */
    where?: FileFolderWhereInput
    /**
     * Limit how many FileFolders to delete.
     */
    limit?: number
  }

  /**
   * FileFolder.files
   */
  export type FileFolder$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * FileFolder without action
   */
  export type FileFolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileFolder
     */
    omit?: FileFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    name: string | null
    path: string | null
    size: number | null
    mimeType: string | null
    userId: string | null
    folderId: string | null
    dealId: string | null
    contactId: string | null
    taskId: string | null
    publicLink: string | null
    expiresAt: Date | null
    access: string | null
    createdAt: Date | null
    commentId: string | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    path: string | null
    size: number | null
    mimeType: string | null
    userId: string | null
    folderId: string | null
    dealId: string | null
    contactId: string | null
    taskId: string | null
    publicLink: string | null
    expiresAt: Date | null
    access: string | null
    createdAt: Date | null
    commentId: string | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    name: number
    path: number
    size: number
    mimeType: number
    userId: number
    folderId: number
    dealId: number
    contactId: number
    taskId: number
    publicLink: number
    expiresAt: number
    access: number
    createdAt: number
    commentId: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    name?: true
    path?: true
    size?: true
    mimeType?: true
    userId?: true
    folderId?: true
    dealId?: true
    contactId?: true
    taskId?: true
    publicLink?: true
    expiresAt?: true
    access?: true
    createdAt?: true
    commentId?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    name?: true
    path?: true
    size?: true
    mimeType?: true
    userId?: true
    folderId?: true
    dealId?: true
    contactId?: true
    taskId?: true
    publicLink?: true
    expiresAt?: true
    access?: true
    createdAt?: true
    commentId?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    name?: true
    path?: true
    size?: true
    mimeType?: true
    userId?: true
    folderId?: true
    dealId?: true
    contactId?: true
    taskId?: true
    publicLink?: true
    expiresAt?: true
    access?: true
    createdAt?: true
    commentId?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    name: string
    path: string
    size: number
    mimeType: string
    userId: string
    folderId: string | null
    dealId: string | null
    contactId: string | null
    taskId: string | null
    publicLink: string | null
    expiresAt: Date | null
    access: string
    createdAt: Date
    commentId: string | null
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    path?: boolean
    size?: boolean
    mimeType?: boolean
    userId?: boolean
    folderId?: boolean
    dealId?: boolean
    contactId?: boolean
    taskId?: boolean
    publicLink?: boolean
    expiresAt?: boolean
    access?: boolean
    createdAt?: boolean
    commentId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | File$folderArgs<ExtArgs>
    comment?: boolean | File$commentArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    path?: boolean
    size?: boolean
    mimeType?: boolean
    userId?: boolean
    folderId?: boolean
    dealId?: boolean
    contactId?: boolean
    taskId?: boolean
    publicLink?: boolean
    expiresAt?: boolean
    access?: boolean
    createdAt?: boolean
    commentId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | File$folderArgs<ExtArgs>
    comment?: boolean | File$commentArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    path?: boolean
    size?: boolean
    mimeType?: boolean
    userId?: boolean
    folderId?: boolean
    dealId?: boolean
    contactId?: boolean
    taskId?: boolean
    publicLink?: boolean
    expiresAt?: boolean
    access?: boolean
    createdAt?: boolean
    commentId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | File$folderArgs<ExtArgs>
    comment?: boolean | File$commentArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    name?: boolean
    path?: boolean
    size?: boolean
    mimeType?: boolean
    userId?: boolean
    folderId?: boolean
    dealId?: boolean
    contactId?: boolean
    taskId?: boolean
    publicLink?: boolean
    expiresAt?: boolean
    access?: boolean
    createdAt?: boolean
    commentId?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "path" | "size" | "mimeType" | "userId" | "folderId" | "dealId" | "contactId" | "taskId" | "publicLink" | "expiresAt" | "access" | "createdAt" | "commentId", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | File$folderArgs<ExtArgs>
    comment?: boolean | File$commentArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | File$folderArgs<ExtArgs>
    comment?: boolean | File$commentArgs<ExtArgs>
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | File$folderArgs<ExtArgs>
    comment?: boolean | File$commentArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      folder: Prisma.$FileFolderPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      path: string
      size: number
      mimeType: string
      userId: string
      folderId: string | null
      dealId: string | null
      contactId: string | null
      taskId: string | null
      publicLink: string | null
      expiresAt: Date | null
      access: string
      createdAt: Date
      commentId: string | null
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    folder<T extends File$folderArgs<ExtArgs> = {}>(args?: Subset<T, File$folderArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comment<T extends File$commentArgs<ExtArgs> = {}>(args?: Subset<T, File$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly name: FieldRef<"File", 'String'>
    readonly path: FieldRef<"File", 'String'>
    readonly size: FieldRef<"File", 'Int'>
    readonly mimeType: FieldRef<"File", 'String'>
    readonly userId: FieldRef<"File", 'String'>
    readonly folderId: FieldRef<"File", 'String'>
    readonly dealId: FieldRef<"File", 'String'>
    readonly contactId: FieldRef<"File", 'String'>
    readonly taskId: FieldRef<"File", 'String'>
    readonly publicLink: FieldRef<"File", 'String'>
    readonly expiresAt: FieldRef<"File", 'DateTime'>
    readonly access: FieldRef<"File", 'String'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
    readonly commentId: FieldRef<"File", 'String'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File.folder
   */
  export type File$folderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileFolder
     */
    omit?: FileFolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    where?: FileFolderWhereInput
  }

  /**
   * File.comment
   */
  export type File$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model SettingOption
   */

  export type AggregateSettingOption = {
    _count: SettingOptionCountAggregateOutputType | null
    _avg: SettingOptionAvgAggregateOutputType | null
    _sum: SettingOptionSumAggregateOutputType | null
    _min: SettingOptionMinAggregateOutputType | null
    _max: SettingOptionMaxAggregateOutputType | null
  }

  export type SettingOptionAvgAggregateOutputType = {
    position: number | null
  }

  export type SettingOptionSumAggregateOutputType = {
    position: number | null
  }

  export type SettingOptionMinAggregateOutputType = {
    id: string | null
    category: string | null
    label: string | null
    value: string | null
    position: number | null
    createdAt: Date | null
  }

  export type SettingOptionMaxAggregateOutputType = {
    id: string | null
    category: string | null
    label: string | null
    value: string | null
    position: number | null
    createdAt: Date | null
  }

  export type SettingOptionCountAggregateOutputType = {
    id: number
    category: number
    label: number
    value: number
    position: number
    createdAt: number
    _all: number
  }


  export type SettingOptionAvgAggregateInputType = {
    position?: true
  }

  export type SettingOptionSumAggregateInputType = {
    position?: true
  }

  export type SettingOptionMinAggregateInputType = {
    id?: true
    category?: true
    label?: true
    value?: true
    position?: true
    createdAt?: true
  }

  export type SettingOptionMaxAggregateInputType = {
    id?: true
    category?: true
    label?: true
    value?: true
    position?: true
    createdAt?: true
  }

  export type SettingOptionCountAggregateInputType = {
    id?: true
    category?: true
    label?: true
    value?: true
    position?: true
    createdAt?: true
    _all?: true
  }

  export type SettingOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingOption to aggregate.
     */
    where?: SettingOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingOptions to fetch.
     */
    orderBy?: SettingOptionOrderByWithRelationInput | SettingOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SettingOptions
    **/
    _count?: true | SettingOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingOptionMaxAggregateInputType
  }

  export type GetSettingOptionAggregateType<T extends SettingOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSettingOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettingOption[P]>
      : GetScalarType<T[P], AggregateSettingOption[P]>
  }




  export type SettingOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingOptionWhereInput
    orderBy?: SettingOptionOrderByWithAggregationInput | SettingOptionOrderByWithAggregationInput[]
    by: SettingOptionScalarFieldEnum[] | SettingOptionScalarFieldEnum
    having?: SettingOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingOptionCountAggregateInputType | true
    _avg?: SettingOptionAvgAggregateInputType
    _sum?: SettingOptionSumAggregateInputType
    _min?: SettingOptionMinAggregateInputType
    _max?: SettingOptionMaxAggregateInputType
  }

  export type SettingOptionGroupByOutputType = {
    id: string
    category: string
    label: string
    value: string
    position: number
    createdAt: Date
    _count: SettingOptionCountAggregateOutputType | null
    _avg: SettingOptionAvgAggregateOutputType | null
    _sum: SettingOptionSumAggregateOutputType | null
    _min: SettingOptionMinAggregateOutputType | null
    _max: SettingOptionMaxAggregateOutputType | null
  }

  type GetSettingOptionGroupByPayload<T extends SettingOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingOptionGroupByOutputType[P]>
            : GetScalarType<T[P], SettingOptionGroupByOutputType[P]>
        }
      >
    >


  export type SettingOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    label?: boolean
    value?: boolean
    position?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["settingOption"]>

  export type SettingOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    label?: boolean
    value?: boolean
    position?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["settingOption"]>

  export type SettingOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    label?: boolean
    value?: boolean
    position?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["settingOption"]>

  export type SettingOptionSelectScalar = {
    id?: boolean
    category?: boolean
    label?: boolean
    value?: boolean
    position?: boolean
    createdAt?: boolean
  }

  export type SettingOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "label" | "value" | "position" | "createdAt", ExtArgs["result"]["settingOption"]>

  export type $SettingOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SettingOption"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      label: string
      value: string
      position: number
      createdAt: Date
    }, ExtArgs["result"]["settingOption"]>
    composites: {}
  }

  type SettingOptionGetPayload<S extends boolean | null | undefined | SettingOptionDefaultArgs> = $Result.GetResult<Prisma.$SettingOptionPayload, S>

  type SettingOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingOptionCountAggregateInputType | true
    }

  export interface SettingOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SettingOption'], meta: { name: 'SettingOption' } }
    /**
     * Find zero or one SettingOption that matches the filter.
     * @param {SettingOptionFindUniqueArgs} args - Arguments to find a SettingOption
     * @example
     * // Get one SettingOption
     * const settingOption = await prisma.settingOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingOptionFindUniqueArgs>(args: SelectSubset<T, SettingOptionFindUniqueArgs<ExtArgs>>): Prisma__SettingOptionClient<$Result.GetResult<Prisma.$SettingOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SettingOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingOptionFindUniqueOrThrowArgs} args - Arguments to find a SettingOption
     * @example
     * // Get one SettingOption
     * const settingOption = await prisma.settingOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingOptionClient<$Result.GetResult<Prisma.$SettingOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SettingOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingOptionFindFirstArgs} args - Arguments to find a SettingOption
     * @example
     * // Get one SettingOption
     * const settingOption = await prisma.settingOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingOptionFindFirstArgs>(args?: SelectSubset<T, SettingOptionFindFirstArgs<ExtArgs>>): Prisma__SettingOptionClient<$Result.GetResult<Prisma.$SettingOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SettingOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingOptionFindFirstOrThrowArgs} args - Arguments to find a SettingOption
     * @example
     * // Get one SettingOption
     * const settingOption = await prisma.settingOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingOptionClient<$Result.GetResult<Prisma.$SettingOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SettingOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SettingOptions
     * const settingOptions = await prisma.settingOption.findMany()
     * 
     * // Get first 10 SettingOptions
     * const settingOptions = await prisma.settingOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingOptionWithIdOnly = await prisma.settingOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingOptionFindManyArgs>(args?: SelectSubset<T, SettingOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SettingOption.
     * @param {SettingOptionCreateArgs} args - Arguments to create a SettingOption.
     * @example
     * // Create one SettingOption
     * const SettingOption = await prisma.settingOption.create({
     *   data: {
     *     // ... data to create a SettingOption
     *   }
     * })
     * 
     */
    create<T extends SettingOptionCreateArgs>(args: SelectSubset<T, SettingOptionCreateArgs<ExtArgs>>): Prisma__SettingOptionClient<$Result.GetResult<Prisma.$SettingOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SettingOptions.
     * @param {SettingOptionCreateManyArgs} args - Arguments to create many SettingOptions.
     * @example
     * // Create many SettingOptions
     * const settingOption = await prisma.settingOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingOptionCreateManyArgs>(args?: SelectSubset<T, SettingOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SettingOptions and returns the data saved in the database.
     * @param {SettingOptionCreateManyAndReturnArgs} args - Arguments to create many SettingOptions.
     * @example
     * // Create many SettingOptions
     * const settingOption = await prisma.settingOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SettingOptions and only return the `id`
     * const settingOptionWithIdOnly = await prisma.settingOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SettingOption.
     * @param {SettingOptionDeleteArgs} args - Arguments to delete one SettingOption.
     * @example
     * // Delete one SettingOption
     * const SettingOption = await prisma.settingOption.delete({
     *   where: {
     *     // ... filter to delete one SettingOption
     *   }
     * })
     * 
     */
    delete<T extends SettingOptionDeleteArgs>(args: SelectSubset<T, SettingOptionDeleteArgs<ExtArgs>>): Prisma__SettingOptionClient<$Result.GetResult<Prisma.$SettingOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SettingOption.
     * @param {SettingOptionUpdateArgs} args - Arguments to update one SettingOption.
     * @example
     * // Update one SettingOption
     * const settingOption = await prisma.settingOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingOptionUpdateArgs>(args: SelectSubset<T, SettingOptionUpdateArgs<ExtArgs>>): Prisma__SettingOptionClient<$Result.GetResult<Prisma.$SettingOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SettingOptions.
     * @param {SettingOptionDeleteManyArgs} args - Arguments to filter SettingOptions to delete.
     * @example
     * // Delete a few SettingOptions
     * const { count } = await prisma.settingOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingOptionDeleteManyArgs>(args?: SelectSubset<T, SettingOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SettingOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SettingOptions
     * const settingOption = await prisma.settingOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingOptionUpdateManyArgs>(args: SelectSubset<T, SettingOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SettingOptions and returns the data updated in the database.
     * @param {SettingOptionUpdateManyAndReturnArgs} args - Arguments to update many SettingOptions.
     * @example
     * // Update many SettingOptions
     * const settingOption = await prisma.settingOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SettingOptions and only return the `id`
     * const settingOptionWithIdOnly = await prisma.settingOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SettingOption.
     * @param {SettingOptionUpsertArgs} args - Arguments to update or create a SettingOption.
     * @example
     * // Update or create a SettingOption
     * const settingOption = await prisma.settingOption.upsert({
     *   create: {
     *     // ... data to create a SettingOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SettingOption we want to update
     *   }
     * })
     */
    upsert<T extends SettingOptionUpsertArgs>(args: SelectSubset<T, SettingOptionUpsertArgs<ExtArgs>>): Prisma__SettingOptionClient<$Result.GetResult<Prisma.$SettingOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SettingOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingOptionCountArgs} args - Arguments to filter SettingOptions to count.
     * @example
     * // Count the number of SettingOptions
     * const count = await prisma.settingOption.count({
     *   where: {
     *     // ... the filter for the SettingOptions we want to count
     *   }
     * })
    **/
    count<T extends SettingOptionCountArgs>(
      args?: Subset<T, SettingOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SettingOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingOptionAggregateArgs>(args: Subset<T, SettingOptionAggregateArgs>): Prisma.PrismaPromise<GetSettingOptionAggregateType<T>>

    /**
     * Group by SettingOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingOptionGroupByArgs['orderBy'] }
        : { orderBy?: SettingOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SettingOption model
   */
  readonly fields: SettingOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SettingOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SettingOption model
   */
  interface SettingOptionFieldRefs {
    readonly id: FieldRef<"SettingOption", 'String'>
    readonly category: FieldRef<"SettingOption", 'String'>
    readonly label: FieldRef<"SettingOption", 'String'>
    readonly value: FieldRef<"SettingOption", 'String'>
    readonly position: FieldRef<"SettingOption", 'Int'>
    readonly createdAt: FieldRef<"SettingOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SettingOption findUnique
   */
  export type SettingOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingOption
     */
    select?: SettingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingOption
     */
    omit?: SettingOptionOmit<ExtArgs> | null
    /**
     * Filter, which SettingOption to fetch.
     */
    where: SettingOptionWhereUniqueInput
  }

  /**
   * SettingOption findUniqueOrThrow
   */
  export type SettingOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingOption
     */
    select?: SettingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingOption
     */
    omit?: SettingOptionOmit<ExtArgs> | null
    /**
     * Filter, which SettingOption to fetch.
     */
    where: SettingOptionWhereUniqueInput
  }

  /**
   * SettingOption findFirst
   */
  export type SettingOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingOption
     */
    select?: SettingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingOption
     */
    omit?: SettingOptionOmit<ExtArgs> | null
    /**
     * Filter, which SettingOption to fetch.
     */
    where?: SettingOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingOptions to fetch.
     */
    orderBy?: SettingOptionOrderByWithRelationInput | SettingOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingOptions.
     */
    cursor?: SettingOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingOptions.
     */
    distinct?: SettingOptionScalarFieldEnum | SettingOptionScalarFieldEnum[]
  }

  /**
   * SettingOption findFirstOrThrow
   */
  export type SettingOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingOption
     */
    select?: SettingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingOption
     */
    omit?: SettingOptionOmit<ExtArgs> | null
    /**
     * Filter, which SettingOption to fetch.
     */
    where?: SettingOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingOptions to fetch.
     */
    orderBy?: SettingOptionOrderByWithRelationInput | SettingOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingOptions.
     */
    cursor?: SettingOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingOptions.
     */
    distinct?: SettingOptionScalarFieldEnum | SettingOptionScalarFieldEnum[]
  }

  /**
   * SettingOption findMany
   */
  export type SettingOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingOption
     */
    select?: SettingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingOption
     */
    omit?: SettingOptionOmit<ExtArgs> | null
    /**
     * Filter, which SettingOptions to fetch.
     */
    where?: SettingOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingOptions to fetch.
     */
    orderBy?: SettingOptionOrderByWithRelationInput | SettingOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SettingOptions.
     */
    cursor?: SettingOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingOptions.
     */
    skip?: number
    distinct?: SettingOptionScalarFieldEnum | SettingOptionScalarFieldEnum[]
  }

  /**
   * SettingOption create
   */
  export type SettingOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingOption
     */
    select?: SettingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingOption
     */
    omit?: SettingOptionOmit<ExtArgs> | null
    /**
     * The data needed to create a SettingOption.
     */
    data: XOR<SettingOptionCreateInput, SettingOptionUncheckedCreateInput>
  }

  /**
   * SettingOption createMany
   */
  export type SettingOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SettingOptions.
     */
    data: SettingOptionCreateManyInput | SettingOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SettingOption createManyAndReturn
   */
  export type SettingOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingOption
     */
    select?: SettingOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SettingOption
     */
    omit?: SettingOptionOmit<ExtArgs> | null
    /**
     * The data used to create many SettingOptions.
     */
    data: SettingOptionCreateManyInput | SettingOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SettingOption update
   */
  export type SettingOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingOption
     */
    select?: SettingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingOption
     */
    omit?: SettingOptionOmit<ExtArgs> | null
    /**
     * The data needed to update a SettingOption.
     */
    data: XOR<SettingOptionUpdateInput, SettingOptionUncheckedUpdateInput>
    /**
     * Choose, which SettingOption to update.
     */
    where: SettingOptionWhereUniqueInput
  }

  /**
   * SettingOption updateMany
   */
  export type SettingOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SettingOptions.
     */
    data: XOR<SettingOptionUpdateManyMutationInput, SettingOptionUncheckedUpdateManyInput>
    /**
     * Filter which SettingOptions to update
     */
    where?: SettingOptionWhereInput
    /**
     * Limit how many SettingOptions to update.
     */
    limit?: number
  }

  /**
   * SettingOption updateManyAndReturn
   */
  export type SettingOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingOption
     */
    select?: SettingOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SettingOption
     */
    omit?: SettingOptionOmit<ExtArgs> | null
    /**
     * The data used to update SettingOptions.
     */
    data: XOR<SettingOptionUpdateManyMutationInput, SettingOptionUncheckedUpdateManyInput>
    /**
     * Filter which SettingOptions to update
     */
    where?: SettingOptionWhereInput
    /**
     * Limit how many SettingOptions to update.
     */
    limit?: number
  }

  /**
   * SettingOption upsert
   */
  export type SettingOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingOption
     */
    select?: SettingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingOption
     */
    omit?: SettingOptionOmit<ExtArgs> | null
    /**
     * The filter to search for the SettingOption to update in case it exists.
     */
    where: SettingOptionWhereUniqueInput
    /**
     * In case the SettingOption found by the `where` argument doesn't exist, create a new SettingOption with this data.
     */
    create: XOR<SettingOptionCreateInput, SettingOptionUncheckedCreateInput>
    /**
     * In case the SettingOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingOptionUpdateInput, SettingOptionUncheckedUpdateInput>
  }

  /**
   * SettingOption delete
   */
  export type SettingOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingOption
     */
    select?: SettingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingOption
     */
    omit?: SettingOptionOmit<ExtArgs> | null
    /**
     * Filter which SettingOption to delete.
     */
    where: SettingOptionWhereUniqueInput
  }

  /**
   * SettingOption deleteMany
   */
  export type SettingOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingOptions to delete
     */
    where?: SettingOptionWhereInput
    /**
     * Limit how many SettingOptions to delete.
     */
    limit?: number
  }

  /**
   * SettingOption without action
   */
  export type SettingOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingOption
     */
    select?: SettingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingOption
     */
    omit?: SettingOptionOmit<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: string
    key: string
    value: string
    createdAt: Date
    updatedAt: Date
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["systemSetting"]>

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'String'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
    readonly createdAt: FieldRef<"SystemSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting createManyAndReturn
   */
  export type SystemSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting updateManyAndReturn
   */
  export type SystemSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
  }


  /**
   * Model DealTag
   */

  export type AggregateDealTag = {
    _count: DealTagCountAggregateOutputType | null
    _min: DealTagMinAggregateOutputType | null
    _max: DealTagMaxAggregateOutputType | null
  }

  export type DealTagMinAggregateOutputType = {
    dealId: string | null
    tagId: string | null
  }

  export type DealTagMaxAggregateOutputType = {
    dealId: string | null
    tagId: string | null
  }

  export type DealTagCountAggregateOutputType = {
    dealId: number
    tagId: number
    _all: number
  }


  export type DealTagMinAggregateInputType = {
    dealId?: true
    tagId?: true
  }

  export type DealTagMaxAggregateInputType = {
    dealId?: true
    tagId?: true
  }

  export type DealTagCountAggregateInputType = {
    dealId?: true
    tagId?: true
    _all?: true
  }

  export type DealTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DealTag to aggregate.
     */
    where?: DealTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealTags to fetch.
     */
    orderBy?: DealTagOrderByWithRelationInput | DealTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DealTags
    **/
    _count?: true | DealTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealTagMaxAggregateInputType
  }

  export type GetDealTagAggregateType<T extends DealTagAggregateArgs> = {
        [P in keyof T & keyof AggregateDealTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDealTag[P]>
      : GetScalarType<T[P], AggregateDealTag[P]>
  }




  export type DealTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealTagWhereInput
    orderBy?: DealTagOrderByWithAggregationInput | DealTagOrderByWithAggregationInput[]
    by: DealTagScalarFieldEnum[] | DealTagScalarFieldEnum
    having?: DealTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealTagCountAggregateInputType | true
    _min?: DealTagMinAggregateInputType
    _max?: DealTagMaxAggregateInputType
  }

  export type DealTagGroupByOutputType = {
    dealId: string
    tagId: string
    _count: DealTagCountAggregateOutputType | null
    _min: DealTagMinAggregateOutputType | null
    _max: DealTagMaxAggregateOutputType | null
  }

  type GetDealTagGroupByPayload<T extends DealTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealTagGroupByOutputType[P]>
            : GetScalarType<T[P], DealTagGroupByOutputType[P]>
        }
      >
    >


  export type DealTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dealId?: boolean
    tagId?: boolean
    deal?: boolean | DealDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dealTag"]>

  export type DealTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dealId?: boolean
    tagId?: boolean
    deal?: boolean | DealDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dealTag"]>

  export type DealTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dealId?: boolean
    tagId?: boolean
    deal?: boolean | DealDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dealTag"]>

  export type DealTagSelectScalar = {
    dealId?: boolean
    tagId?: boolean
  }

  export type DealTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"dealId" | "tagId", ExtArgs["result"]["dealTag"]>
  export type DealTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deal?: boolean | DealDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type DealTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deal?: boolean | DealDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type DealTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deal?: boolean | DealDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $DealTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DealTag"
    objects: {
      deal: Prisma.$DealPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      dealId: string
      tagId: string
    }, ExtArgs["result"]["dealTag"]>
    composites: {}
  }

  type DealTagGetPayload<S extends boolean | null | undefined | DealTagDefaultArgs> = $Result.GetResult<Prisma.$DealTagPayload, S>

  type DealTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DealTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DealTagCountAggregateInputType | true
    }

  export interface DealTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DealTag'], meta: { name: 'DealTag' } }
    /**
     * Find zero or one DealTag that matches the filter.
     * @param {DealTagFindUniqueArgs} args - Arguments to find a DealTag
     * @example
     * // Get one DealTag
     * const dealTag = await prisma.dealTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DealTagFindUniqueArgs>(args: SelectSubset<T, DealTagFindUniqueArgs<ExtArgs>>): Prisma__DealTagClient<$Result.GetResult<Prisma.$DealTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DealTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DealTagFindUniqueOrThrowArgs} args - Arguments to find a DealTag
     * @example
     * // Get one DealTag
     * const dealTag = await prisma.dealTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DealTagFindUniqueOrThrowArgs>(args: SelectSubset<T, DealTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DealTagClient<$Result.GetResult<Prisma.$DealTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DealTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealTagFindFirstArgs} args - Arguments to find a DealTag
     * @example
     * // Get one DealTag
     * const dealTag = await prisma.dealTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DealTagFindFirstArgs>(args?: SelectSubset<T, DealTagFindFirstArgs<ExtArgs>>): Prisma__DealTagClient<$Result.GetResult<Prisma.$DealTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DealTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealTagFindFirstOrThrowArgs} args - Arguments to find a DealTag
     * @example
     * // Get one DealTag
     * const dealTag = await prisma.dealTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DealTagFindFirstOrThrowArgs>(args?: SelectSubset<T, DealTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__DealTagClient<$Result.GetResult<Prisma.$DealTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DealTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DealTags
     * const dealTags = await prisma.dealTag.findMany()
     * 
     * // Get first 10 DealTags
     * const dealTags = await prisma.dealTag.findMany({ take: 10 })
     * 
     * // Only select the `dealId`
     * const dealTagWithDealIdOnly = await prisma.dealTag.findMany({ select: { dealId: true } })
     * 
     */
    findMany<T extends DealTagFindManyArgs>(args?: SelectSubset<T, DealTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DealTag.
     * @param {DealTagCreateArgs} args - Arguments to create a DealTag.
     * @example
     * // Create one DealTag
     * const DealTag = await prisma.dealTag.create({
     *   data: {
     *     // ... data to create a DealTag
     *   }
     * })
     * 
     */
    create<T extends DealTagCreateArgs>(args: SelectSubset<T, DealTagCreateArgs<ExtArgs>>): Prisma__DealTagClient<$Result.GetResult<Prisma.$DealTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DealTags.
     * @param {DealTagCreateManyArgs} args - Arguments to create many DealTags.
     * @example
     * // Create many DealTags
     * const dealTag = await prisma.dealTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DealTagCreateManyArgs>(args?: SelectSubset<T, DealTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DealTags and returns the data saved in the database.
     * @param {DealTagCreateManyAndReturnArgs} args - Arguments to create many DealTags.
     * @example
     * // Create many DealTags
     * const dealTag = await prisma.dealTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DealTags and only return the `dealId`
     * const dealTagWithDealIdOnly = await prisma.dealTag.createManyAndReturn({
     *   select: { dealId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DealTagCreateManyAndReturnArgs>(args?: SelectSubset<T, DealTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DealTag.
     * @param {DealTagDeleteArgs} args - Arguments to delete one DealTag.
     * @example
     * // Delete one DealTag
     * const DealTag = await prisma.dealTag.delete({
     *   where: {
     *     // ... filter to delete one DealTag
     *   }
     * })
     * 
     */
    delete<T extends DealTagDeleteArgs>(args: SelectSubset<T, DealTagDeleteArgs<ExtArgs>>): Prisma__DealTagClient<$Result.GetResult<Prisma.$DealTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DealTag.
     * @param {DealTagUpdateArgs} args - Arguments to update one DealTag.
     * @example
     * // Update one DealTag
     * const dealTag = await prisma.dealTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DealTagUpdateArgs>(args: SelectSubset<T, DealTagUpdateArgs<ExtArgs>>): Prisma__DealTagClient<$Result.GetResult<Prisma.$DealTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DealTags.
     * @param {DealTagDeleteManyArgs} args - Arguments to filter DealTags to delete.
     * @example
     * // Delete a few DealTags
     * const { count } = await prisma.dealTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DealTagDeleteManyArgs>(args?: SelectSubset<T, DealTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DealTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DealTags
     * const dealTag = await prisma.dealTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DealTagUpdateManyArgs>(args: SelectSubset<T, DealTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DealTags and returns the data updated in the database.
     * @param {DealTagUpdateManyAndReturnArgs} args - Arguments to update many DealTags.
     * @example
     * // Update many DealTags
     * const dealTag = await prisma.dealTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DealTags and only return the `dealId`
     * const dealTagWithDealIdOnly = await prisma.dealTag.updateManyAndReturn({
     *   select: { dealId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DealTagUpdateManyAndReturnArgs>(args: SelectSubset<T, DealTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DealTag.
     * @param {DealTagUpsertArgs} args - Arguments to update or create a DealTag.
     * @example
     * // Update or create a DealTag
     * const dealTag = await prisma.dealTag.upsert({
     *   create: {
     *     // ... data to create a DealTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DealTag we want to update
     *   }
     * })
     */
    upsert<T extends DealTagUpsertArgs>(args: SelectSubset<T, DealTagUpsertArgs<ExtArgs>>): Prisma__DealTagClient<$Result.GetResult<Prisma.$DealTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DealTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealTagCountArgs} args - Arguments to filter DealTags to count.
     * @example
     * // Count the number of DealTags
     * const count = await prisma.dealTag.count({
     *   where: {
     *     // ... the filter for the DealTags we want to count
     *   }
     * })
    **/
    count<T extends DealTagCountArgs>(
      args?: Subset<T, DealTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DealTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealTagAggregateArgs>(args: Subset<T, DealTagAggregateArgs>): Prisma.PrismaPromise<GetDealTagAggregateType<T>>

    /**
     * Group by DealTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealTagGroupByArgs['orderBy'] }
        : { orderBy?: DealTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DealTag model
   */
  readonly fields: DealTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DealTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deal<T extends DealDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DealDefaultArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DealTag model
   */
  interface DealTagFieldRefs {
    readonly dealId: FieldRef<"DealTag", 'String'>
    readonly tagId: FieldRef<"DealTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DealTag findUnique
   */
  export type DealTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealTag
     */
    select?: DealTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealTag
     */
    omit?: DealTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealTagInclude<ExtArgs> | null
    /**
     * Filter, which DealTag to fetch.
     */
    where: DealTagWhereUniqueInput
  }

  /**
   * DealTag findUniqueOrThrow
   */
  export type DealTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealTag
     */
    select?: DealTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealTag
     */
    omit?: DealTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealTagInclude<ExtArgs> | null
    /**
     * Filter, which DealTag to fetch.
     */
    where: DealTagWhereUniqueInput
  }

  /**
   * DealTag findFirst
   */
  export type DealTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealTag
     */
    select?: DealTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealTag
     */
    omit?: DealTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealTagInclude<ExtArgs> | null
    /**
     * Filter, which DealTag to fetch.
     */
    where?: DealTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealTags to fetch.
     */
    orderBy?: DealTagOrderByWithRelationInput | DealTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DealTags.
     */
    cursor?: DealTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DealTags.
     */
    distinct?: DealTagScalarFieldEnum | DealTagScalarFieldEnum[]
  }

  /**
   * DealTag findFirstOrThrow
   */
  export type DealTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealTag
     */
    select?: DealTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealTag
     */
    omit?: DealTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealTagInclude<ExtArgs> | null
    /**
     * Filter, which DealTag to fetch.
     */
    where?: DealTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealTags to fetch.
     */
    orderBy?: DealTagOrderByWithRelationInput | DealTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DealTags.
     */
    cursor?: DealTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DealTags.
     */
    distinct?: DealTagScalarFieldEnum | DealTagScalarFieldEnum[]
  }

  /**
   * DealTag findMany
   */
  export type DealTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealTag
     */
    select?: DealTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealTag
     */
    omit?: DealTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealTagInclude<ExtArgs> | null
    /**
     * Filter, which DealTags to fetch.
     */
    where?: DealTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealTags to fetch.
     */
    orderBy?: DealTagOrderByWithRelationInput | DealTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DealTags.
     */
    cursor?: DealTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealTags.
     */
    skip?: number
    distinct?: DealTagScalarFieldEnum | DealTagScalarFieldEnum[]
  }

  /**
   * DealTag create
   */
  export type DealTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealTag
     */
    select?: DealTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealTag
     */
    omit?: DealTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealTagInclude<ExtArgs> | null
    /**
     * The data needed to create a DealTag.
     */
    data: XOR<DealTagCreateInput, DealTagUncheckedCreateInput>
  }

  /**
   * DealTag createMany
   */
  export type DealTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DealTags.
     */
    data: DealTagCreateManyInput | DealTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DealTag createManyAndReturn
   */
  export type DealTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealTag
     */
    select?: DealTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DealTag
     */
    omit?: DealTagOmit<ExtArgs> | null
    /**
     * The data used to create many DealTags.
     */
    data: DealTagCreateManyInput | DealTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DealTag update
   */
  export type DealTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealTag
     */
    select?: DealTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealTag
     */
    omit?: DealTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealTagInclude<ExtArgs> | null
    /**
     * The data needed to update a DealTag.
     */
    data: XOR<DealTagUpdateInput, DealTagUncheckedUpdateInput>
    /**
     * Choose, which DealTag to update.
     */
    where: DealTagWhereUniqueInput
  }

  /**
   * DealTag updateMany
   */
  export type DealTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DealTags.
     */
    data: XOR<DealTagUpdateManyMutationInput, DealTagUncheckedUpdateManyInput>
    /**
     * Filter which DealTags to update
     */
    where?: DealTagWhereInput
    /**
     * Limit how many DealTags to update.
     */
    limit?: number
  }

  /**
   * DealTag updateManyAndReturn
   */
  export type DealTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealTag
     */
    select?: DealTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DealTag
     */
    omit?: DealTagOmit<ExtArgs> | null
    /**
     * The data used to update DealTags.
     */
    data: XOR<DealTagUpdateManyMutationInput, DealTagUncheckedUpdateManyInput>
    /**
     * Filter which DealTags to update
     */
    where?: DealTagWhereInput
    /**
     * Limit how many DealTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DealTag upsert
   */
  export type DealTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealTag
     */
    select?: DealTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealTag
     */
    omit?: DealTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealTagInclude<ExtArgs> | null
    /**
     * The filter to search for the DealTag to update in case it exists.
     */
    where: DealTagWhereUniqueInput
    /**
     * In case the DealTag found by the `where` argument doesn't exist, create a new DealTag with this data.
     */
    create: XOR<DealTagCreateInput, DealTagUncheckedCreateInput>
    /**
     * In case the DealTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealTagUpdateInput, DealTagUncheckedUpdateInput>
  }

  /**
   * DealTag delete
   */
  export type DealTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealTag
     */
    select?: DealTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealTag
     */
    omit?: DealTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealTagInclude<ExtArgs> | null
    /**
     * Filter which DealTag to delete.
     */
    where: DealTagWhereUniqueInput
  }

  /**
   * DealTag deleteMany
   */
  export type DealTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DealTags to delete
     */
    where?: DealTagWhereInput
    /**
     * Limit how many DealTags to delete.
     */
    limit?: number
  }

  /**
   * DealTag without action
   */
  export type DealTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealTag
     */
    select?: DealTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealTag
     */
    omit?: DealTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealTagInclude<ExtArgs> | null
  }


  /**
   * Model ContactTag
   */

  export type AggregateContactTag = {
    _count: ContactTagCountAggregateOutputType | null
    _min: ContactTagMinAggregateOutputType | null
    _max: ContactTagMaxAggregateOutputType | null
  }

  export type ContactTagMinAggregateOutputType = {
    contactId: string | null
    tagId: string | null
  }

  export type ContactTagMaxAggregateOutputType = {
    contactId: string | null
    tagId: string | null
  }

  export type ContactTagCountAggregateOutputType = {
    contactId: number
    tagId: number
    _all: number
  }


  export type ContactTagMinAggregateInputType = {
    contactId?: true
    tagId?: true
  }

  export type ContactTagMaxAggregateInputType = {
    contactId?: true
    tagId?: true
  }

  export type ContactTagCountAggregateInputType = {
    contactId?: true
    tagId?: true
    _all?: true
  }

  export type ContactTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactTag to aggregate.
     */
    where?: ContactTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTags to fetch.
     */
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactTags
    **/
    _count?: true | ContactTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactTagMaxAggregateInputType
  }

  export type GetContactTagAggregateType<T extends ContactTagAggregateArgs> = {
        [P in keyof T & keyof AggregateContactTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactTag[P]>
      : GetScalarType<T[P], AggregateContactTag[P]>
  }




  export type ContactTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTagWhereInput
    orderBy?: ContactTagOrderByWithAggregationInput | ContactTagOrderByWithAggregationInput[]
    by: ContactTagScalarFieldEnum[] | ContactTagScalarFieldEnum
    having?: ContactTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactTagCountAggregateInputType | true
    _min?: ContactTagMinAggregateInputType
    _max?: ContactTagMaxAggregateInputType
  }

  export type ContactTagGroupByOutputType = {
    contactId: string
    tagId: string
    _count: ContactTagCountAggregateOutputType | null
    _min: ContactTagMinAggregateOutputType | null
    _max: ContactTagMaxAggregateOutputType | null
  }

  type GetContactTagGroupByPayload<T extends ContactTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactTagGroupByOutputType[P]>
            : GetScalarType<T[P], ContactTagGroupByOutputType[P]>
        }
      >
    >


  export type ContactTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    tagId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTag"]>

  export type ContactTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    tagId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTag"]>

  export type ContactTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    tagId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTag"]>

  export type ContactTagSelectScalar = {
    contactId?: boolean
    tagId?: boolean
  }

  export type ContactTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"contactId" | "tagId", ExtArgs["result"]["contactTag"]>
  export type ContactTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ContactTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ContactTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $ContactTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactTag"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      contactId: string
      tagId: string
    }, ExtArgs["result"]["contactTag"]>
    composites: {}
  }

  type ContactTagGetPayload<S extends boolean | null | undefined | ContactTagDefaultArgs> = $Result.GetResult<Prisma.$ContactTagPayload, S>

  type ContactTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactTagCountAggregateInputType | true
    }

  export interface ContactTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactTag'], meta: { name: 'ContactTag' } }
    /**
     * Find zero or one ContactTag that matches the filter.
     * @param {ContactTagFindUniqueArgs} args - Arguments to find a ContactTag
     * @example
     * // Get one ContactTag
     * const contactTag = await prisma.contactTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactTagFindUniqueArgs>(args: SelectSubset<T, ContactTagFindUniqueArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactTagFindUniqueOrThrowArgs} args - Arguments to find a ContactTag
     * @example
     * // Get one ContactTag
     * const contactTag = await prisma.contactTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagFindFirstArgs} args - Arguments to find a ContactTag
     * @example
     * // Get one ContactTag
     * const contactTag = await prisma.contactTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactTagFindFirstArgs>(args?: SelectSubset<T, ContactTagFindFirstArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagFindFirstOrThrowArgs} args - Arguments to find a ContactTag
     * @example
     * // Get one ContactTag
     * const contactTag = await prisma.contactTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactTags
     * const contactTags = await prisma.contactTag.findMany()
     * 
     * // Get first 10 ContactTags
     * const contactTags = await prisma.contactTag.findMany({ take: 10 })
     * 
     * // Only select the `contactId`
     * const contactTagWithContactIdOnly = await prisma.contactTag.findMany({ select: { contactId: true } })
     * 
     */
    findMany<T extends ContactTagFindManyArgs>(args?: SelectSubset<T, ContactTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactTag.
     * @param {ContactTagCreateArgs} args - Arguments to create a ContactTag.
     * @example
     * // Create one ContactTag
     * const ContactTag = await prisma.contactTag.create({
     *   data: {
     *     // ... data to create a ContactTag
     *   }
     * })
     * 
     */
    create<T extends ContactTagCreateArgs>(args: SelectSubset<T, ContactTagCreateArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactTags.
     * @param {ContactTagCreateManyArgs} args - Arguments to create many ContactTags.
     * @example
     * // Create many ContactTags
     * const contactTag = await prisma.contactTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactTagCreateManyArgs>(args?: SelectSubset<T, ContactTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactTags and returns the data saved in the database.
     * @param {ContactTagCreateManyAndReturnArgs} args - Arguments to create many ContactTags.
     * @example
     * // Create many ContactTags
     * const contactTag = await prisma.contactTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactTags and only return the `contactId`
     * const contactTagWithContactIdOnly = await prisma.contactTag.createManyAndReturn({
     *   select: { contactId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactTag.
     * @param {ContactTagDeleteArgs} args - Arguments to delete one ContactTag.
     * @example
     * // Delete one ContactTag
     * const ContactTag = await prisma.contactTag.delete({
     *   where: {
     *     // ... filter to delete one ContactTag
     *   }
     * })
     * 
     */
    delete<T extends ContactTagDeleteArgs>(args: SelectSubset<T, ContactTagDeleteArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactTag.
     * @param {ContactTagUpdateArgs} args - Arguments to update one ContactTag.
     * @example
     * // Update one ContactTag
     * const contactTag = await prisma.contactTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactTagUpdateArgs>(args: SelectSubset<T, ContactTagUpdateArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactTags.
     * @param {ContactTagDeleteManyArgs} args - Arguments to filter ContactTags to delete.
     * @example
     * // Delete a few ContactTags
     * const { count } = await prisma.contactTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactTagDeleteManyArgs>(args?: SelectSubset<T, ContactTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactTags
     * const contactTag = await prisma.contactTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactTagUpdateManyArgs>(args: SelectSubset<T, ContactTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactTags and returns the data updated in the database.
     * @param {ContactTagUpdateManyAndReturnArgs} args - Arguments to update many ContactTags.
     * @example
     * // Update many ContactTags
     * const contactTag = await prisma.contactTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactTags and only return the `contactId`
     * const contactTagWithContactIdOnly = await prisma.contactTag.updateManyAndReturn({
     *   select: { contactId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactTagUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactTag.
     * @param {ContactTagUpsertArgs} args - Arguments to update or create a ContactTag.
     * @example
     * // Update or create a ContactTag
     * const contactTag = await prisma.contactTag.upsert({
     *   create: {
     *     // ... data to create a ContactTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactTag we want to update
     *   }
     * })
     */
    upsert<T extends ContactTagUpsertArgs>(args: SelectSubset<T, ContactTagUpsertArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagCountArgs} args - Arguments to filter ContactTags to count.
     * @example
     * // Count the number of ContactTags
     * const count = await prisma.contactTag.count({
     *   where: {
     *     // ... the filter for the ContactTags we want to count
     *   }
     * })
    **/
    count<T extends ContactTagCountArgs>(
      args?: Subset<T, ContactTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactTagAggregateArgs>(args: Subset<T, ContactTagAggregateArgs>): Prisma.PrismaPromise<GetContactTagAggregateType<T>>

    /**
     * Group by ContactTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactTagGroupByArgs['orderBy'] }
        : { orderBy?: ContactTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactTag model
   */
  readonly fields: ContactTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactTag model
   */
  interface ContactTagFieldRefs {
    readonly contactId: FieldRef<"ContactTag", 'String'>
    readonly tagId: FieldRef<"ContactTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContactTag findUnique
   */
  export type ContactTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTag to fetch.
     */
    where: ContactTagWhereUniqueInput
  }

  /**
   * ContactTag findUniqueOrThrow
   */
  export type ContactTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTag to fetch.
     */
    where: ContactTagWhereUniqueInput
  }

  /**
   * ContactTag findFirst
   */
  export type ContactTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTag to fetch.
     */
    where?: ContactTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTags to fetch.
     */
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactTags.
     */
    cursor?: ContactTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactTags.
     */
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * ContactTag findFirstOrThrow
   */
  export type ContactTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTag to fetch.
     */
    where?: ContactTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTags to fetch.
     */
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactTags.
     */
    cursor?: ContactTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactTags.
     */
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * ContactTag findMany
   */
  export type ContactTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTags to fetch.
     */
    where?: ContactTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTags to fetch.
     */
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactTags.
     */
    cursor?: ContactTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTags.
     */
    skip?: number
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * ContactTag create
   */
  export type ContactTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactTag.
     */
    data: XOR<ContactTagCreateInput, ContactTagUncheckedCreateInput>
  }

  /**
   * ContactTag createMany
   */
  export type ContactTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactTags.
     */
    data: ContactTagCreateManyInput | ContactTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactTag createManyAndReturn
   */
  export type ContactTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * The data used to create many ContactTags.
     */
    data: ContactTagCreateManyInput | ContactTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactTag update
   */
  export type ContactTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactTag.
     */
    data: XOR<ContactTagUpdateInput, ContactTagUncheckedUpdateInput>
    /**
     * Choose, which ContactTag to update.
     */
    where: ContactTagWhereUniqueInput
  }

  /**
   * ContactTag updateMany
   */
  export type ContactTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactTags.
     */
    data: XOR<ContactTagUpdateManyMutationInput, ContactTagUncheckedUpdateManyInput>
    /**
     * Filter which ContactTags to update
     */
    where?: ContactTagWhereInput
    /**
     * Limit how many ContactTags to update.
     */
    limit?: number
  }

  /**
   * ContactTag updateManyAndReturn
   */
  export type ContactTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * The data used to update ContactTags.
     */
    data: XOR<ContactTagUpdateManyMutationInput, ContactTagUncheckedUpdateManyInput>
    /**
     * Filter which ContactTags to update
     */
    where?: ContactTagWhereInput
    /**
     * Limit how many ContactTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactTag upsert
   */
  export type ContactTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactTag to update in case it exists.
     */
    where: ContactTagWhereUniqueInput
    /**
     * In case the ContactTag found by the `where` argument doesn't exist, create a new ContactTag with this data.
     */
    create: XOR<ContactTagCreateInput, ContactTagUncheckedCreateInput>
    /**
     * In case the ContactTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactTagUpdateInput, ContactTagUncheckedUpdateInput>
  }

  /**
   * ContactTag delete
   */
  export type ContactTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter which ContactTag to delete.
     */
    where: ContactTagWhereUniqueInput
  }

  /**
   * ContactTag deleteMany
   */
  export type ContactTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactTags to delete
     */
    where?: ContactTagWhereInput
    /**
     * Limit how many ContactTags to delete.
     */
    limit?: number
  }

  /**
   * ContactTag without action
   */
  export type ContactTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    label: string | null
    color: string | null
    createdAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    label: string | null
    color: string | null
    createdAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    label: number
    color: number
    createdAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    label?: true
    color?: true
    createdAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    label?: true
    color?: true
    createdAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    label?: true
    color?: true
    createdAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    label: string
    color: string
    createdAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    color?: boolean
    createdAt?: boolean
    DealTags?: boolean | Tag$DealTagsArgs<ExtArgs>
    ContactTags?: boolean | Tag$ContactTagsArgs<ExtArgs>
    activities?: boolean | Tag$activitiesArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    color?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    color?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    label?: boolean
    color?: boolean
    createdAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "color" | "createdAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DealTags?: boolean | Tag$DealTagsArgs<ExtArgs>
    ContactTags?: boolean | Tag$ContactTagsArgs<ExtArgs>
    activities?: boolean | Tag$activitiesArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      DealTags: Prisma.$DealTagPayload<ExtArgs>[]
      ContactTags: Prisma.$ContactTagPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      color: string
      createdAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DealTags<T extends Tag$DealTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$DealTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ContactTags<T extends Tag$ContactTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$ContactTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends Tag$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly label: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.DealTags
   */
  export type Tag$DealTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealTag
     */
    select?: DealTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealTag
     */
    omit?: DealTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealTagInclude<ExtArgs> | null
    where?: DealTagWhereInput
    orderBy?: DealTagOrderByWithRelationInput | DealTagOrderByWithRelationInput[]
    cursor?: DealTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealTagScalarFieldEnum | DealTagScalarFieldEnum[]
  }

  /**
   * Tag.ContactTags
   */
  export type Tag$ContactTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    where?: ContactTagWhereInput
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    cursor?: ContactTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * Tag.activities
   */
  export type Tag$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  export type WebhookMinAggregateOutputType = {
    id: string | null
    url: string | null
    event: string | null
    enabled: boolean | null
    createdAt: Date | null
  }

  export type WebhookMaxAggregateOutputType = {
    id: string | null
    url: string | null
    event: string | null
    enabled: boolean | null
    createdAt: Date | null
  }

  export type WebhookCountAggregateOutputType = {
    id: number
    url: number
    event: number
    enabled: number
    createdAt: number
    _all: number
  }


  export type WebhookMinAggregateInputType = {
    id?: true
    url?: true
    event?: true
    enabled?: true
    createdAt?: true
  }

  export type WebhookMaxAggregateInputType = {
    id?: true
    url?: true
    event?: true
    enabled?: true
    createdAt?: true
  }

  export type WebhookCountAggregateInputType = {
    id?: true
    url?: true
    event?: true
    enabled?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Webhooks
    **/
    _count?: true | WebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookMaxAggregateInputType
  }

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>
  }




  export type WebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[]
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum
    having?: WebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookCountAggregateInputType | true
    _min?: WebhookMinAggregateInputType
    _max?: WebhookMaxAggregateInputType
  }

  export type WebhookGroupByOutputType = {
    id: string
    url: string
    event: string
    enabled: boolean
    createdAt: Date
    _count: WebhookCountAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    event?: boolean
    enabled?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    event?: boolean
    enabled?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    event?: boolean
    enabled?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectScalar = {
    id?: boolean
    url?: boolean
    event?: boolean
    enabled?: boolean
    createdAt?: boolean
  }

  export type WebhookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "event" | "enabled" | "createdAt", ExtArgs["result"]["webhook"]>

  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Webhook"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      event: string
      enabled: boolean
      createdAt: Date
    }, ExtArgs["result"]["webhook"]>
    composites: {}
  }

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> = $Result.GetResult<Prisma.$WebhookPayload, S>

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookCountAggregateInputType | true
    }

  export interface WebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook'], meta: { name: 'Webhook' } }
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookFindManyArgs>(args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     * 
     */
    create<T extends WebhookCreateArgs>(args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookCreateManyArgs>(args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Webhooks and returns the data saved in the database.
     * @param {WebhookCreateManyAndReturnArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeleteArgs>(args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookUpdateArgs>(args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeleteManyArgs>(args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookUpdateManyArgs>(args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks and returns the data updated in the database.
     * @param {WebhookUpdateManyAndReturnArgs} args - Arguments to update many Webhooks.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookAggregateArgs>(args: Subset<T, WebhookAggregateArgs>): Prisma.PrismaPromise<GetWebhookAggregateType<T>>

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Webhook model
   */
  readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Webhook model
   */
  interface WebhookFieldRefs {
    readonly id: FieldRef<"Webhook", 'String'>
    readonly url: FieldRef<"Webhook", 'String'>
    readonly event: FieldRef<"Webhook", 'String'>
    readonly enabled: FieldRef<"Webhook", 'Boolean'>
    readonly createdAt: FieldRef<"Webhook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
  }

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook createManyAndReturn
   */
  export type WebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
  }

  /**
   * Webhook updateManyAndReturn
   */
  export type WebhookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
  }

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
  }

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to delete.
     */
    limit?: number
  }

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
  }


  /**
   * Model SharedAccess
   */

  export type AggregateSharedAccess = {
    _count: SharedAccessCountAggregateOutputType | null
    _min: SharedAccessMinAggregateOutputType | null
    _max: SharedAccessMaxAggregateOutputType | null
  }

  export type SharedAccessMinAggregateOutputType = {
    id: string | null
    userId: string | null
    entityId: string | null
    entity: string | null
    canEdit: boolean | null
    createdAt: Date | null
  }

  export type SharedAccessMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    entityId: string | null
    entity: string | null
    canEdit: boolean | null
    createdAt: Date | null
  }

  export type SharedAccessCountAggregateOutputType = {
    id: number
    userId: number
    entityId: number
    entity: number
    canEdit: number
    createdAt: number
    _all: number
  }


  export type SharedAccessMinAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
    entity?: true
    canEdit?: true
    createdAt?: true
  }

  export type SharedAccessMaxAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
    entity?: true
    canEdit?: true
    createdAt?: true
  }

  export type SharedAccessCountAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
    entity?: true
    canEdit?: true
    createdAt?: true
    _all?: true
  }

  export type SharedAccessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedAccess to aggregate.
     */
    where?: SharedAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAccesses to fetch.
     */
    orderBy?: SharedAccessOrderByWithRelationInput | SharedAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharedAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharedAccesses
    **/
    _count?: true | SharedAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharedAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharedAccessMaxAggregateInputType
  }

  export type GetSharedAccessAggregateType<T extends SharedAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateSharedAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharedAccess[P]>
      : GetScalarType<T[P], AggregateSharedAccess[P]>
  }




  export type SharedAccessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedAccessWhereInput
    orderBy?: SharedAccessOrderByWithAggregationInput | SharedAccessOrderByWithAggregationInput[]
    by: SharedAccessScalarFieldEnum[] | SharedAccessScalarFieldEnum
    having?: SharedAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharedAccessCountAggregateInputType | true
    _min?: SharedAccessMinAggregateInputType
    _max?: SharedAccessMaxAggregateInputType
  }

  export type SharedAccessGroupByOutputType = {
    id: string
    userId: string
    entityId: string
    entity: string
    canEdit: boolean
    createdAt: Date
    _count: SharedAccessCountAggregateOutputType | null
    _min: SharedAccessMinAggregateOutputType | null
    _max: SharedAccessMaxAggregateOutputType | null
  }

  type GetSharedAccessGroupByPayload<T extends SharedAccessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SharedAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharedAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharedAccessGroupByOutputType[P]>
            : GetScalarType<T[P], SharedAccessGroupByOutputType[P]>
        }
      >
    >


  export type SharedAccessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entityId?: boolean
    entity?: boolean
    canEdit?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedAccess"]>

  export type SharedAccessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entityId?: boolean
    entity?: boolean
    canEdit?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedAccess"]>

  export type SharedAccessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entityId?: boolean
    entity?: boolean
    canEdit?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedAccess"]>

  export type SharedAccessSelectScalar = {
    id?: boolean
    userId?: boolean
    entityId?: boolean
    entity?: boolean
    canEdit?: boolean
    createdAt?: boolean
  }

  export type SharedAccessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "entityId" | "entity" | "canEdit" | "createdAt", ExtArgs["result"]["sharedAccess"]>
  export type SharedAccessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SharedAccessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SharedAccessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SharedAccessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SharedAccess"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      entityId: string
      entity: string
      canEdit: boolean
      createdAt: Date
    }, ExtArgs["result"]["sharedAccess"]>
    composites: {}
  }

  type SharedAccessGetPayload<S extends boolean | null | undefined | SharedAccessDefaultArgs> = $Result.GetResult<Prisma.$SharedAccessPayload, S>

  type SharedAccessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SharedAccessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SharedAccessCountAggregateInputType | true
    }

  export interface SharedAccessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SharedAccess'], meta: { name: 'SharedAccess' } }
    /**
     * Find zero or one SharedAccess that matches the filter.
     * @param {SharedAccessFindUniqueArgs} args - Arguments to find a SharedAccess
     * @example
     * // Get one SharedAccess
     * const sharedAccess = await prisma.sharedAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SharedAccessFindUniqueArgs>(args: SelectSubset<T, SharedAccessFindUniqueArgs<ExtArgs>>): Prisma__SharedAccessClient<$Result.GetResult<Prisma.$SharedAccessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SharedAccess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SharedAccessFindUniqueOrThrowArgs} args - Arguments to find a SharedAccess
     * @example
     * // Get one SharedAccess
     * const sharedAccess = await prisma.sharedAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SharedAccessFindUniqueOrThrowArgs>(args: SelectSubset<T, SharedAccessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SharedAccessClient<$Result.GetResult<Prisma.$SharedAccessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharedAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccessFindFirstArgs} args - Arguments to find a SharedAccess
     * @example
     * // Get one SharedAccess
     * const sharedAccess = await prisma.sharedAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SharedAccessFindFirstArgs>(args?: SelectSubset<T, SharedAccessFindFirstArgs<ExtArgs>>): Prisma__SharedAccessClient<$Result.GetResult<Prisma.$SharedAccessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharedAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccessFindFirstOrThrowArgs} args - Arguments to find a SharedAccess
     * @example
     * // Get one SharedAccess
     * const sharedAccess = await prisma.sharedAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SharedAccessFindFirstOrThrowArgs>(args?: SelectSubset<T, SharedAccessFindFirstOrThrowArgs<ExtArgs>>): Prisma__SharedAccessClient<$Result.GetResult<Prisma.$SharedAccessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SharedAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharedAccesses
     * const sharedAccesses = await prisma.sharedAccess.findMany()
     * 
     * // Get first 10 SharedAccesses
     * const sharedAccesses = await prisma.sharedAccess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharedAccessWithIdOnly = await prisma.sharedAccess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SharedAccessFindManyArgs>(args?: SelectSubset<T, SharedAccessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SharedAccess.
     * @param {SharedAccessCreateArgs} args - Arguments to create a SharedAccess.
     * @example
     * // Create one SharedAccess
     * const SharedAccess = await prisma.sharedAccess.create({
     *   data: {
     *     // ... data to create a SharedAccess
     *   }
     * })
     * 
     */
    create<T extends SharedAccessCreateArgs>(args: SelectSubset<T, SharedAccessCreateArgs<ExtArgs>>): Prisma__SharedAccessClient<$Result.GetResult<Prisma.$SharedAccessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SharedAccesses.
     * @param {SharedAccessCreateManyArgs} args - Arguments to create many SharedAccesses.
     * @example
     * // Create many SharedAccesses
     * const sharedAccess = await prisma.sharedAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SharedAccessCreateManyArgs>(args?: SelectSubset<T, SharedAccessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SharedAccesses and returns the data saved in the database.
     * @param {SharedAccessCreateManyAndReturnArgs} args - Arguments to create many SharedAccesses.
     * @example
     * // Create many SharedAccesses
     * const sharedAccess = await prisma.sharedAccess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SharedAccesses and only return the `id`
     * const sharedAccessWithIdOnly = await prisma.sharedAccess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SharedAccessCreateManyAndReturnArgs>(args?: SelectSubset<T, SharedAccessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SharedAccess.
     * @param {SharedAccessDeleteArgs} args - Arguments to delete one SharedAccess.
     * @example
     * // Delete one SharedAccess
     * const SharedAccess = await prisma.sharedAccess.delete({
     *   where: {
     *     // ... filter to delete one SharedAccess
     *   }
     * })
     * 
     */
    delete<T extends SharedAccessDeleteArgs>(args: SelectSubset<T, SharedAccessDeleteArgs<ExtArgs>>): Prisma__SharedAccessClient<$Result.GetResult<Prisma.$SharedAccessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SharedAccess.
     * @param {SharedAccessUpdateArgs} args - Arguments to update one SharedAccess.
     * @example
     * // Update one SharedAccess
     * const sharedAccess = await prisma.sharedAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SharedAccessUpdateArgs>(args: SelectSubset<T, SharedAccessUpdateArgs<ExtArgs>>): Prisma__SharedAccessClient<$Result.GetResult<Prisma.$SharedAccessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SharedAccesses.
     * @param {SharedAccessDeleteManyArgs} args - Arguments to filter SharedAccesses to delete.
     * @example
     * // Delete a few SharedAccesses
     * const { count } = await prisma.sharedAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SharedAccessDeleteManyArgs>(args?: SelectSubset<T, SharedAccessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharedAccesses
     * const sharedAccess = await prisma.sharedAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SharedAccessUpdateManyArgs>(args: SelectSubset<T, SharedAccessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedAccesses and returns the data updated in the database.
     * @param {SharedAccessUpdateManyAndReturnArgs} args - Arguments to update many SharedAccesses.
     * @example
     * // Update many SharedAccesses
     * const sharedAccess = await prisma.sharedAccess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SharedAccesses and only return the `id`
     * const sharedAccessWithIdOnly = await prisma.sharedAccess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SharedAccessUpdateManyAndReturnArgs>(args: SelectSubset<T, SharedAccessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SharedAccess.
     * @param {SharedAccessUpsertArgs} args - Arguments to update or create a SharedAccess.
     * @example
     * // Update or create a SharedAccess
     * const sharedAccess = await prisma.sharedAccess.upsert({
     *   create: {
     *     // ... data to create a SharedAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharedAccess we want to update
     *   }
     * })
     */
    upsert<T extends SharedAccessUpsertArgs>(args: SelectSubset<T, SharedAccessUpsertArgs<ExtArgs>>): Prisma__SharedAccessClient<$Result.GetResult<Prisma.$SharedAccessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SharedAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccessCountArgs} args - Arguments to filter SharedAccesses to count.
     * @example
     * // Count the number of SharedAccesses
     * const count = await prisma.sharedAccess.count({
     *   where: {
     *     // ... the filter for the SharedAccesses we want to count
     *   }
     * })
    **/
    count<T extends SharedAccessCountArgs>(
      args?: Subset<T, SharedAccessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharedAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharedAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharedAccessAggregateArgs>(args: Subset<T, SharedAccessAggregateArgs>): Prisma.PrismaPromise<GetSharedAccessAggregateType<T>>

    /**
     * Group by SharedAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharedAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharedAccessGroupByArgs['orderBy'] }
        : { orderBy?: SharedAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharedAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharedAccessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SharedAccess model
   */
  readonly fields: SharedAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SharedAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SharedAccessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SharedAccess model
   */
  interface SharedAccessFieldRefs {
    readonly id: FieldRef<"SharedAccess", 'String'>
    readonly userId: FieldRef<"SharedAccess", 'String'>
    readonly entityId: FieldRef<"SharedAccess", 'String'>
    readonly entity: FieldRef<"SharedAccess", 'String'>
    readonly canEdit: FieldRef<"SharedAccess", 'Boolean'>
    readonly createdAt: FieldRef<"SharedAccess", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SharedAccess findUnique
   */
  export type SharedAccessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccess
     */
    select?: SharedAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccess
     */
    omit?: SharedAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccessInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccess to fetch.
     */
    where: SharedAccessWhereUniqueInput
  }

  /**
   * SharedAccess findUniqueOrThrow
   */
  export type SharedAccessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccess
     */
    select?: SharedAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccess
     */
    omit?: SharedAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccessInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccess to fetch.
     */
    where: SharedAccessWhereUniqueInput
  }

  /**
   * SharedAccess findFirst
   */
  export type SharedAccessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccess
     */
    select?: SharedAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccess
     */
    omit?: SharedAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccessInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccess to fetch.
     */
    where?: SharedAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAccesses to fetch.
     */
    orderBy?: SharedAccessOrderByWithRelationInput | SharedAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedAccesses.
     */
    cursor?: SharedAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedAccesses.
     */
    distinct?: SharedAccessScalarFieldEnum | SharedAccessScalarFieldEnum[]
  }

  /**
   * SharedAccess findFirstOrThrow
   */
  export type SharedAccessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccess
     */
    select?: SharedAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccess
     */
    omit?: SharedAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccessInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccess to fetch.
     */
    where?: SharedAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAccesses to fetch.
     */
    orderBy?: SharedAccessOrderByWithRelationInput | SharedAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedAccesses.
     */
    cursor?: SharedAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedAccesses.
     */
    distinct?: SharedAccessScalarFieldEnum | SharedAccessScalarFieldEnum[]
  }

  /**
   * SharedAccess findMany
   */
  export type SharedAccessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccess
     */
    select?: SharedAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccess
     */
    omit?: SharedAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccessInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccesses to fetch.
     */
    where?: SharedAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAccesses to fetch.
     */
    orderBy?: SharedAccessOrderByWithRelationInput | SharedAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharedAccesses.
     */
    cursor?: SharedAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAccesses.
     */
    skip?: number
    distinct?: SharedAccessScalarFieldEnum | SharedAccessScalarFieldEnum[]
  }

  /**
   * SharedAccess create
   */
  export type SharedAccessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccess
     */
    select?: SharedAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccess
     */
    omit?: SharedAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccessInclude<ExtArgs> | null
    /**
     * The data needed to create a SharedAccess.
     */
    data: XOR<SharedAccessCreateInput, SharedAccessUncheckedCreateInput>
  }

  /**
   * SharedAccess createMany
   */
  export type SharedAccessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SharedAccesses.
     */
    data: SharedAccessCreateManyInput | SharedAccessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharedAccess createManyAndReturn
   */
  export type SharedAccessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccess
     */
    select?: SharedAccessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccess
     */
    omit?: SharedAccessOmit<ExtArgs> | null
    /**
     * The data used to create many SharedAccesses.
     */
    data: SharedAccessCreateManyInput | SharedAccessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharedAccess update
   */
  export type SharedAccessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccess
     */
    select?: SharedAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccess
     */
    omit?: SharedAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccessInclude<ExtArgs> | null
    /**
     * The data needed to update a SharedAccess.
     */
    data: XOR<SharedAccessUpdateInput, SharedAccessUncheckedUpdateInput>
    /**
     * Choose, which SharedAccess to update.
     */
    where: SharedAccessWhereUniqueInput
  }

  /**
   * SharedAccess updateMany
   */
  export type SharedAccessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SharedAccesses.
     */
    data: XOR<SharedAccessUpdateManyMutationInput, SharedAccessUncheckedUpdateManyInput>
    /**
     * Filter which SharedAccesses to update
     */
    where?: SharedAccessWhereInput
    /**
     * Limit how many SharedAccesses to update.
     */
    limit?: number
  }

  /**
   * SharedAccess updateManyAndReturn
   */
  export type SharedAccessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccess
     */
    select?: SharedAccessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccess
     */
    omit?: SharedAccessOmit<ExtArgs> | null
    /**
     * The data used to update SharedAccesses.
     */
    data: XOR<SharedAccessUpdateManyMutationInput, SharedAccessUncheckedUpdateManyInput>
    /**
     * Filter which SharedAccesses to update
     */
    where?: SharedAccessWhereInput
    /**
     * Limit how many SharedAccesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharedAccess upsert
   */
  export type SharedAccessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccess
     */
    select?: SharedAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccess
     */
    omit?: SharedAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccessInclude<ExtArgs> | null
    /**
     * The filter to search for the SharedAccess to update in case it exists.
     */
    where: SharedAccessWhereUniqueInput
    /**
     * In case the SharedAccess found by the `where` argument doesn't exist, create a new SharedAccess with this data.
     */
    create: XOR<SharedAccessCreateInput, SharedAccessUncheckedCreateInput>
    /**
     * In case the SharedAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharedAccessUpdateInput, SharedAccessUncheckedUpdateInput>
  }

  /**
   * SharedAccess delete
   */
  export type SharedAccessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccess
     */
    select?: SharedAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccess
     */
    omit?: SharedAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccessInclude<ExtArgs> | null
    /**
     * Filter which SharedAccess to delete.
     */
    where: SharedAccessWhereUniqueInput
  }

  /**
   * SharedAccess deleteMany
   */
  export type SharedAccessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedAccesses to delete
     */
    where?: SharedAccessWhereInput
    /**
     * Limit how many SharedAccesses to delete.
     */
    limit?: number
  }

  /**
   * SharedAccess without action
   */
  export type SharedAccessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccess
     */
    select?: SharedAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccess
     */
    omit?: SharedAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccessInclude<ExtArgs> | null
  }


  /**
   * Model AutomationRule
   */

  export type AggregateAutomationRule = {
    _count: AutomationRuleCountAggregateOutputType | null
    _min: AutomationRuleMinAggregateOutputType | null
    _max: AutomationRuleMaxAggregateOutputType | null
  }

  export type AutomationRuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    entity: string | null
    trigger: string | null
    field: string | null
    enabled: boolean | null
    createdAt: Date | null
  }

  export type AutomationRuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    entity: string | null
    trigger: string | null
    field: string | null
    enabled: boolean | null
    createdAt: Date | null
  }

  export type AutomationRuleCountAggregateOutputType = {
    id: number
    name: number
    entity: number
    trigger: number
    field: number
    condition: number
    action: number
    enabled: number
    createdAt: number
    _all: number
  }


  export type AutomationRuleMinAggregateInputType = {
    id?: true
    name?: true
    entity?: true
    trigger?: true
    field?: true
    enabled?: true
    createdAt?: true
  }

  export type AutomationRuleMaxAggregateInputType = {
    id?: true
    name?: true
    entity?: true
    trigger?: true
    field?: true
    enabled?: true
    createdAt?: true
  }

  export type AutomationRuleCountAggregateInputType = {
    id?: true
    name?: true
    entity?: true
    trigger?: true
    field?: true
    condition?: true
    action?: true
    enabled?: true
    createdAt?: true
    _all?: true
  }

  export type AutomationRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationRule to aggregate.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationRules
    **/
    _count?: true | AutomationRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationRuleMaxAggregateInputType
  }

  export type GetAutomationRuleAggregateType<T extends AutomationRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationRule[P]>
      : GetScalarType<T[P], AggregateAutomationRule[P]>
  }




  export type AutomationRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationRuleWhereInput
    orderBy?: AutomationRuleOrderByWithAggregationInput | AutomationRuleOrderByWithAggregationInput[]
    by: AutomationRuleScalarFieldEnum[] | AutomationRuleScalarFieldEnum
    having?: AutomationRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationRuleCountAggregateInputType | true
    _min?: AutomationRuleMinAggregateInputType
    _max?: AutomationRuleMaxAggregateInputType
  }

  export type AutomationRuleGroupByOutputType = {
    id: string
    name: string
    entity: string
    trigger: string
    field: string | null
    condition: JsonValue
    action: JsonValue
    enabled: boolean
    createdAt: Date
    _count: AutomationRuleCountAggregateOutputType | null
    _min: AutomationRuleMinAggregateOutputType | null
    _max: AutomationRuleMaxAggregateOutputType | null
  }

  type GetAutomationRuleGroupByPayload<T extends AutomationRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationRuleGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationRuleGroupByOutputType[P]>
        }
      >
    >


  export type AutomationRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    entity?: boolean
    trigger?: boolean
    field?: boolean
    condition?: boolean
    action?: boolean
    enabled?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["automationRule"]>

  export type AutomationRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    entity?: boolean
    trigger?: boolean
    field?: boolean
    condition?: boolean
    action?: boolean
    enabled?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["automationRule"]>

  export type AutomationRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    entity?: boolean
    trigger?: boolean
    field?: boolean
    condition?: boolean
    action?: boolean
    enabled?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["automationRule"]>

  export type AutomationRuleSelectScalar = {
    id?: boolean
    name?: boolean
    entity?: boolean
    trigger?: boolean
    field?: boolean
    condition?: boolean
    action?: boolean
    enabled?: boolean
    createdAt?: boolean
  }

  export type AutomationRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "entity" | "trigger" | "field" | "condition" | "action" | "enabled" | "createdAt", ExtArgs["result"]["automationRule"]>

  export type $AutomationRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationRule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      entity: string
      trigger: string
      field: string | null
      condition: Prisma.JsonValue
      action: Prisma.JsonValue
      enabled: boolean
      createdAt: Date
    }, ExtArgs["result"]["automationRule"]>
    composites: {}
  }

  type AutomationRuleGetPayload<S extends boolean | null | undefined | AutomationRuleDefaultArgs> = $Result.GetResult<Prisma.$AutomationRulePayload, S>

  type AutomationRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutomationRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutomationRuleCountAggregateInputType | true
    }

  export interface AutomationRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationRule'], meta: { name: 'AutomationRule' } }
    /**
     * Find zero or one AutomationRule that matches the filter.
     * @param {AutomationRuleFindUniqueArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationRuleFindUniqueArgs>(args: SelectSubset<T, AutomationRuleFindUniqueArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutomationRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutomationRuleFindUniqueOrThrowArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleFindFirstArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationRuleFindFirstArgs>(args?: SelectSubset<T, AutomationRuleFindFirstArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleFindFirstOrThrowArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutomationRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationRules
     * const automationRules = await prisma.automationRule.findMany()
     * 
     * // Get first 10 AutomationRules
     * const automationRules = await prisma.automationRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationRuleWithIdOnly = await prisma.automationRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationRuleFindManyArgs>(args?: SelectSubset<T, AutomationRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutomationRule.
     * @param {AutomationRuleCreateArgs} args - Arguments to create a AutomationRule.
     * @example
     * // Create one AutomationRule
     * const AutomationRule = await prisma.automationRule.create({
     *   data: {
     *     // ... data to create a AutomationRule
     *   }
     * })
     * 
     */
    create<T extends AutomationRuleCreateArgs>(args: SelectSubset<T, AutomationRuleCreateArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutomationRules.
     * @param {AutomationRuleCreateManyArgs} args - Arguments to create many AutomationRules.
     * @example
     * // Create many AutomationRules
     * const automationRule = await prisma.automationRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationRuleCreateManyArgs>(args?: SelectSubset<T, AutomationRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationRules and returns the data saved in the database.
     * @param {AutomationRuleCreateManyAndReturnArgs} args - Arguments to create many AutomationRules.
     * @example
     * // Create many AutomationRules
     * const automationRule = await prisma.automationRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationRules and only return the `id`
     * const automationRuleWithIdOnly = await prisma.automationRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AutomationRule.
     * @param {AutomationRuleDeleteArgs} args - Arguments to delete one AutomationRule.
     * @example
     * // Delete one AutomationRule
     * const AutomationRule = await prisma.automationRule.delete({
     *   where: {
     *     // ... filter to delete one AutomationRule
     *   }
     * })
     * 
     */
    delete<T extends AutomationRuleDeleteArgs>(args: SelectSubset<T, AutomationRuleDeleteArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutomationRule.
     * @param {AutomationRuleUpdateArgs} args - Arguments to update one AutomationRule.
     * @example
     * // Update one AutomationRule
     * const automationRule = await prisma.automationRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationRuleUpdateArgs>(args: SelectSubset<T, AutomationRuleUpdateArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutomationRules.
     * @param {AutomationRuleDeleteManyArgs} args - Arguments to filter AutomationRules to delete.
     * @example
     * // Delete a few AutomationRules
     * const { count } = await prisma.automationRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationRuleDeleteManyArgs>(args?: SelectSubset<T, AutomationRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationRules
     * const automationRule = await prisma.automationRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationRuleUpdateManyArgs>(args: SelectSubset<T, AutomationRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationRules and returns the data updated in the database.
     * @param {AutomationRuleUpdateManyAndReturnArgs} args - Arguments to update many AutomationRules.
     * @example
     * // Update many AutomationRules
     * const automationRule = await prisma.automationRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AutomationRules and only return the `id`
     * const automationRuleWithIdOnly = await prisma.automationRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutomationRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, AutomationRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AutomationRule.
     * @param {AutomationRuleUpsertArgs} args - Arguments to update or create a AutomationRule.
     * @example
     * // Update or create a AutomationRule
     * const automationRule = await prisma.automationRule.upsert({
     *   create: {
     *     // ... data to create a AutomationRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationRule we want to update
     *   }
     * })
     */
    upsert<T extends AutomationRuleUpsertArgs>(args: SelectSubset<T, AutomationRuleUpsertArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AutomationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleCountArgs} args - Arguments to filter AutomationRules to count.
     * @example
     * // Count the number of AutomationRules
     * const count = await prisma.automationRule.count({
     *   where: {
     *     // ... the filter for the AutomationRules we want to count
     *   }
     * })
    **/
    count<T extends AutomationRuleCountArgs>(
      args?: Subset<T, AutomationRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationRuleAggregateArgs>(args: Subset<T, AutomationRuleAggregateArgs>): Prisma.PrismaPromise<GetAutomationRuleAggregateType<T>>

    /**
     * Group by AutomationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationRuleGroupByArgs['orderBy'] }
        : { orderBy?: AutomationRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationRule model
   */
  readonly fields: AutomationRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationRule model
   */
  interface AutomationRuleFieldRefs {
    readonly id: FieldRef<"AutomationRule", 'String'>
    readonly name: FieldRef<"AutomationRule", 'String'>
    readonly entity: FieldRef<"AutomationRule", 'String'>
    readonly trigger: FieldRef<"AutomationRule", 'String'>
    readonly field: FieldRef<"AutomationRule", 'String'>
    readonly condition: FieldRef<"AutomationRule", 'Json'>
    readonly action: FieldRef<"AutomationRule", 'Json'>
    readonly enabled: FieldRef<"AutomationRule", 'Boolean'>
    readonly createdAt: FieldRef<"AutomationRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutomationRule findUnique
   */
  export type AutomationRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule findUniqueOrThrow
   */
  export type AutomationRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule findFirst
   */
  export type AutomationRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationRules.
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationRules.
     */
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * AutomationRule findFirstOrThrow
   */
  export type AutomationRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationRules.
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationRules.
     */
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * AutomationRule findMany
   */
  export type AutomationRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Filter, which AutomationRules to fetch.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationRules.
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * AutomationRule create
   */
  export type AutomationRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * The data needed to create a AutomationRule.
     */
    data: XOR<AutomationRuleCreateInput, AutomationRuleUncheckedCreateInput>
  }

  /**
   * AutomationRule createMany
   */
  export type AutomationRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationRules.
     */
    data: AutomationRuleCreateManyInput | AutomationRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationRule createManyAndReturn
   */
  export type AutomationRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * The data used to create many AutomationRules.
     */
    data: AutomationRuleCreateManyInput | AutomationRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationRule update
   */
  export type AutomationRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * The data needed to update a AutomationRule.
     */
    data: XOR<AutomationRuleUpdateInput, AutomationRuleUncheckedUpdateInput>
    /**
     * Choose, which AutomationRule to update.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule updateMany
   */
  export type AutomationRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationRules.
     */
    data: XOR<AutomationRuleUpdateManyMutationInput, AutomationRuleUncheckedUpdateManyInput>
    /**
     * Filter which AutomationRules to update
     */
    where?: AutomationRuleWhereInput
    /**
     * Limit how many AutomationRules to update.
     */
    limit?: number
  }

  /**
   * AutomationRule updateManyAndReturn
   */
  export type AutomationRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * The data used to update AutomationRules.
     */
    data: XOR<AutomationRuleUpdateManyMutationInput, AutomationRuleUncheckedUpdateManyInput>
    /**
     * Filter which AutomationRules to update
     */
    where?: AutomationRuleWhereInput
    /**
     * Limit how many AutomationRules to update.
     */
    limit?: number
  }

  /**
   * AutomationRule upsert
   */
  export type AutomationRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * The filter to search for the AutomationRule to update in case it exists.
     */
    where: AutomationRuleWhereUniqueInput
    /**
     * In case the AutomationRule found by the `where` argument doesn't exist, create a new AutomationRule with this data.
     */
    create: XOR<AutomationRuleCreateInput, AutomationRuleUncheckedCreateInput>
    /**
     * In case the AutomationRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationRuleUpdateInput, AutomationRuleUncheckedUpdateInput>
  }

  /**
   * AutomationRule delete
   */
  export type AutomationRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Filter which AutomationRule to delete.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule deleteMany
   */
  export type AutomationRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationRules to delete
     */
    where?: AutomationRuleWhereInput
    /**
     * Limit how many AutomationRules to delete.
     */
    limit?: number
  }

  /**
   * AutomationRule without action
   */
  export type AutomationRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
  }


  /**
   * Model CustomField
   */

  export type AggregateCustomField = {
    _count: CustomFieldCountAggregateOutputType | null
    _min: CustomFieldMinAggregateOutputType | null
    _max: CustomFieldMaxAggregateOutputType | null
  }

  export type CustomFieldMinAggregateOutputType = {
    id: string | null
    entity: string | null
    name: string | null
    label: string | null
    type: string | null
    required: boolean | null
    createdAt: Date | null
  }

  export type CustomFieldMaxAggregateOutputType = {
    id: string | null
    entity: string | null
    name: string | null
    label: string | null
    type: string | null
    required: boolean | null
    createdAt: Date | null
  }

  export type CustomFieldCountAggregateOutputType = {
    id: number
    entity: number
    name: number
    label: number
    type: number
    options: number
    required: number
    createdAt: number
    _all: number
  }


  export type CustomFieldMinAggregateInputType = {
    id?: true
    entity?: true
    name?: true
    label?: true
    type?: true
    required?: true
    createdAt?: true
  }

  export type CustomFieldMaxAggregateInputType = {
    id?: true
    entity?: true
    name?: true
    label?: true
    type?: true
    required?: true
    createdAt?: true
  }

  export type CustomFieldCountAggregateInputType = {
    id?: true
    entity?: true
    name?: true
    label?: true
    type?: true
    options?: true
    required?: true
    createdAt?: true
    _all?: true
  }

  export type CustomFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomField to aggregate.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomFields
    **/
    _count?: true | CustomFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomFieldMaxAggregateInputType
  }

  export type GetCustomFieldAggregateType<T extends CustomFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomField[P]>
      : GetScalarType<T[P], AggregateCustomField[P]>
  }




  export type CustomFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldWhereInput
    orderBy?: CustomFieldOrderByWithAggregationInput | CustomFieldOrderByWithAggregationInput[]
    by: CustomFieldScalarFieldEnum[] | CustomFieldScalarFieldEnum
    having?: CustomFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomFieldCountAggregateInputType | true
    _min?: CustomFieldMinAggregateInputType
    _max?: CustomFieldMaxAggregateInputType
  }

  export type CustomFieldGroupByOutputType = {
    id: string
    entity: string
    name: string
    label: string
    type: string
    options: JsonValue | null
    required: boolean
    createdAt: Date
    _count: CustomFieldCountAggregateOutputType | null
    _min: CustomFieldMinAggregateOutputType | null
    _max: CustomFieldMaxAggregateOutputType | null
  }

  type GetCustomFieldGroupByPayload<T extends CustomFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomFieldGroupByOutputType[P]>
            : GetScalarType<T[P], CustomFieldGroupByOutputType[P]>
        }
      >
    >


  export type CustomFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    name?: boolean
    label?: boolean
    type?: boolean
    options?: boolean
    required?: boolean
    createdAt?: boolean
    values?: boolean | CustomField$valuesArgs<ExtArgs>
    _count?: boolean | CustomFieldCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customField"]>

  export type CustomFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    name?: boolean
    label?: boolean
    type?: boolean
    options?: boolean
    required?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["customField"]>

  export type CustomFieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    name?: boolean
    label?: boolean
    type?: boolean
    options?: boolean
    required?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["customField"]>

  export type CustomFieldSelectScalar = {
    id?: boolean
    entity?: boolean
    name?: boolean
    label?: boolean
    type?: boolean
    options?: boolean
    required?: boolean
    createdAt?: boolean
  }

  export type CustomFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entity" | "name" | "label" | "type" | "options" | "required" | "createdAt", ExtArgs["result"]["customField"]>
  export type CustomFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | CustomField$valuesArgs<ExtArgs>
    _count?: boolean | CustomFieldCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomFieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomField"
    objects: {
      values: Prisma.$CustomFieldValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entity: string
      name: string
      label: string
      type: string
      options: Prisma.JsonValue | null
      required: boolean
      createdAt: Date
    }, ExtArgs["result"]["customField"]>
    composites: {}
  }

  type CustomFieldGetPayload<S extends boolean | null | undefined | CustomFieldDefaultArgs> = $Result.GetResult<Prisma.$CustomFieldPayload, S>

  type CustomFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomFieldCountAggregateInputType | true
    }

  export interface CustomFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomField'], meta: { name: 'CustomField' } }
    /**
     * Find zero or one CustomField that matches the filter.
     * @param {CustomFieldFindUniqueArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomFieldFindUniqueArgs>(args: SelectSubset<T, CustomFieldFindUniqueArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomFieldFindUniqueOrThrowArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindFirstArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomFieldFindFirstArgs>(args?: SelectSubset<T, CustomFieldFindFirstArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindFirstOrThrowArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomFields
     * const customFields = await prisma.customField.findMany()
     * 
     * // Get first 10 CustomFields
     * const customFields = await prisma.customField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customFieldWithIdOnly = await prisma.customField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomFieldFindManyArgs>(args?: SelectSubset<T, CustomFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomField.
     * @param {CustomFieldCreateArgs} args - Arguments to create a CustomField.
     * @example
     * // Create one CustomField
     * const CustomField = await prisma.customField.create({
     *   data: {
     *     // ... data to create a CustomField
     *   }
     * })
     * 
     */
    create<T extends CustomFieldCreateArgs>(args: SelectSubset<T, CustomFieldCreateArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomFields.
     * @param {CustomFieldCreateManyArgs} args - Arguments to create many CustomFields.
     * @example
     * // Create many CustomFields
     * const customField = await prisma.customField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomFieldCreateManyArgs>(args?: SelectSubset<T, CustomFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomFields and returns the data saved in the database.
     * @param {CustomFieldCreateManyAndReturnArgs} args - Arguments to create many CustomFields.
     * @example
     * // Create many CustomFields
     * const customField = await prisma.customField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomFields and only return the `id`
     * const customFieldWithIdOnly = await prisma.customField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomField.
     * @param {CustomFieldDeleteArgs} args - Arguments to delete one CustomField.
     * @example
     * // Delete one CustomField
     * const CustomField = await prisma.customField.delete({
     *   where: {
     *     // ... filter to delete one CustomField
     *   }
     * })
     * 
     */
    delete<T extends CustomFieldDeleteArgs>(args: SelectSubset<T, CustomFieldDeleteArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomField.
     * @param {CustomFieldUpdateArgs} args - Arguments to update one CustomField.
     * @example
     * // Update one CustomField
     * const customField = await prisma.customField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomFieldUpdateArgs>(args: SelectSubset<T, CustomFieldUpdateArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomFields.
     * @param {CustomFieldDeleteManyArgs} args - Arguments to filter CustomFields to delete.
     * @example
     * // Delete a few CustomFields
     * const { count } = await prisma.customField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomFieldDeleteManyArgs>(args?: SelectSubset<T, CustomFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomFields
     * const customField = await prisma.customField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomFieldUpdateManyArgs>(args: SelectSubset<T, CustomFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomFields and returns the data updated in the database.
     * @param {CustomFieldUpdateManyAndReturnArgs} args - Arguments to update many CustomFields.
     * @example
     * // Update many CustomFields
     * const customField = await prisma.customField.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomFields and only return the `id`
     * const customFieldWithIdOnly = await prisma.customField.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomFieldUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomFieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomField.
     * @param {CustomFieldUpsertArgs} args - Arguments to update or create a CustomField.
     * @example
     * // Update or create a CustomField
     * const customField = await prisma.customField.upsert({
     *   create: {
     *     // ... data to create a CustomField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomField we want to update
     *   }
     * })
     */
    upsert<T extends CustomFieldUpsertArgs>(args: SelectSubset<T, CustomFieldUpsertArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldCountArgs} args - Arguments to filter CustomFields to count.
     * @example
     * // Count the number of CustomFields
     * const count = await prisma.customField.count({
     *   where: {
     *     // ... the filter for the CustomFields we want to count
     *   }
     * })
    **/
    count<T extends CustomFieldCountArgs>(
      args?: Subset<T, CustomFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomFieldAggregateArgs>(args: Subset<T, CustomFieldAggregateArgs>): Prisma.PrismaPromise<GetCustomFieldAggregateType<T>>

    /**
     * Group by CustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomFieldGroupByArgs['orderBy'] }
        : { orderBy?: CustomFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomField model
   */
  readonly fields: CustomFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    values<T extends CustomField$valuesArgs<ExtArgs> = {}>(args?: Subset<T, CustomField$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomField model
   */
  interface CustomFieldFieldRefs {
    readonly id: FieldRef<"CustomField", 'String'>
    readonly entity: FieldRef<"CustomField", 'String'>
    readonly name: FieldRef<"CustomField", 'String'>
    readonly label: FieldRef<"CustomField", 'String'>
    readonly type: FieldRef<"CustomField", 'String'>
    readonly options: FieldRef<"CustomField", 'Json'>
    readonly required: FieldRef<"CustomField", 'Boolean'>
    readonly createdAt: FieldRef<"CustomField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomField findUnique
   */
  export type CustomFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField findUniqueOrThrow
   */
  export type CustomFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField findFirst
   */
  export type CustomFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFields.
     */
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * CustomField findFirstOrThrow
   */
  export type CustomFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFields.
     */
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * CustomField findMany
   */
  export type CustomFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomFields to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * CustomField create
   */
  export type CustomFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomField.
     */
    data: XOR<CustomFieldCreateInput, CustomFieldUncheckedCreateInput>
  }

  /**
   * CustomField createMany
   */
  export type CustomFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomFields.
     */
    data: CustomFieldCreateManyInput | CustomFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomField createManyAndReturn
   */
  export type CustomFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * The data used to create many CustomFields.
     */
    data: CustomFieldCreateManyInput | CustomFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomField update
   */
  export type CustomFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomField.
     */
    data: XOR<CustomFieldUpdateInput, CustomFieldUncheckedUpdateInput>
    /**
     * Choose, which CustomField to update.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField updateMany
   */
  export type CustomFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomFields.
     */
    data: XOR<CustomFieldUpdateManyMutationInput, CustomFieldUncheckedUpdateManyInput>
    /**
     * Filter which CustomFields to update
     */
    where?: CustomFieldWhereInput
    /**
     * Limit how many CustomFields to update.
     */
    limit?: number
  }

  /**
   * CustomField updateManyAndReturn
   */
  export type CustomFieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * The data used to update CustomFields.
     */
    data: XOR<CustomFieldUpdateManyMutationInput, CustomFieldUncheckedUpdateManyInput>
    /**
     * Filter which CustomFields to update
     */
    where?: CustomFieldWhereInput
    /**
     * Limit how many CustomFields to update.
     */
    limit?: number
  }

  /**
   * CustomField upsert
   */
  export type CustomFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomField to update in case it exists.
     */
    where: CustomFieldWhereUniqueInput
    /**
     * In case the CustomField found by the `where` argument doesn't exist, create a new CustomField with this data.
     */
    create: XOR<CustomFieldCreateInput, CustomFieldUncheckedCreateInput>
    /**
     * In case the CustomField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomFieldUpdateInput, CustomFieldUncheckedUpdateInput>
  }

  /**
   * CustomField delete
   */
  export type CustomFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter which CustomField to delete.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField deleteMany
   */
  export type CustomFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomFields to delete
     */
    where?: CustomFieldWhereInput
    /**
     * Limit how many CustomFields to delete.
     */
    limit?: number
  }

  /**
   * CustomField.values
   */
  export type CustomField$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    where?: CustomFieldValueWhereInput
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    cursor?: CustomFieldValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomFieldValueScalarFieldEnum | CustomFieldValueScalarFieldEnum[]
  }

  /**
   * CustomField without action
   */
  export type CustomFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
  }


  /**
   * Model CustomFieldValue
   */

  export type AggregateCustomFieldValue = {
    _count: CustomFieldValueCountAggregateOutputType | null
    _min: CustomFieldValueMinAggregateOutputType | null
    _max: CustomFieldValueMaxAggregateOutputType | null
  }

  export type CustomFieldValueMinAggregateOutputType = {
    id: string | null
    fieldId: string | null
    entity: string | null
    entityId: string | null
    value: string | null
    createdAt: Date | null
  }

  export type CustomFieldValueMaxAggregateOutputType = {
    id: string | null
    fieldId: string | null
    entity: string | null
    entityId: string | null
    value: string | null
    createdAt: Date | null
  }

  export type CustomFieldValueCountAggregateOutputType = {
    id: number
    fieldId: number
    entity: number
    entityId: number
    value: number
    createdAt: number
    _all: number
  }


  export type CustomFieldValueMinAggregateInputType = {
    id?: true
    fieldId?: true
    entity?: true
    entityId?: true
    value?: true
    createdAt?: true
  }

  export type CustomFieldValueMaxAggregateInputType = {
    id?: true
    fieldId?: true
    entity?: true
    entityId?: true
    value?: true
    createdAt?: true
  }

  export type CustomFieldValueCountAggregateInputType = {
    id?: true
    fieldId?: true
    entity?: true
    entityId?: true
    value?: true
    createdAt?: true
    _all?: true
  }

  export type CustomFieldValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomFieldValue to aggregate.
     */
    where?: CustomFieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFieldValues to fetch.
     */
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomFieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFieldValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomFieldValues
    **/
    _count?: true | CustomFieldValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomFieldValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomFieldValueMaxAggregateInputType
  }

  export type GetCustomFieldValueAggregateType<T extends CustomFieldValueAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomFieldValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomFieldValue[P]>
      : GetScalarType<T[P], AggregateCustomFieldValue[P]>
  }




  export type CustomFieldValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldValueWhereInput
    orderBy?: CustomFieldValueOrderByWithAggregationInput | CustomFieldValueOrderByWithAggregationInput[]
    by: CustomFieldValueScalarFieldEnum[] | CustomFieldValueScalarFieldEnum
    having?: CustomFieldValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomFieldValueCountAggregateInputType | true
    _min?: CustomFieldValueMinAggregateInputType
    _max?: CustomFieldValueMaxAggregateInputType
  }

  export type CustomFieldValueGroupByOutputType = {
    id: string
    fieldId: string
    entity: string
    entityId: string
    value: string
    createdAt: Date
    _count: CustomFieldValueCountAggregateOutputType | null
    _min: CustomFieldValueMinAggregateOutputType | null
    _max: CustomFieldValueMaxAggregateOutputType | null
  }

  type GetCustomFieldValueGroupByPayload<T extends CustomFieldValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomFieldValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomFieldValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomFieldValueGroupByOutputType[P]>
            : GetScalarType<T[P], CustomFieldValueGroupByOutputType[P]>
        }
      >
    >


  export type CustomFieldValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fieldId?: boolean
    entity?: boolean
    entityId?: boolean
    value?: boolean
    createdAt?: boolean
    field?: boolean | CustomFieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customFieldValue"]>

  export type CustomFieldValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fieldId?: boolean
    entity?: boolean
    entityId?: boolean
    value?: boolean
    createdAt?: boolean
    field?: boolean | CustomFieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customFieldValue"]>

  export type CustomFieldValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fieldId?: boolean
    entity?: boolean
    entityId?: boolean
    value?: boolean
    createdAt?: boolean
    field?: boolean | CustomFieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customFieldValue"]>

  export type CustomFieldValueSelectScalar = {
    id?: boolean
    fieldId?: boolean
    entity?: boolean
    entityId?: boolean
    value?: boolean
    createdAt?: boolean
  }

  export type CustomFieldValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fieldId" | "entity" | "entityId" | "value" | "createdAt", ExtArgs["result"]["customFieldValue"]>
  export type CustomFieldValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    field?: boolean | CustomFieldDefaultArgs<ExtArgs>
  }
  export type CustomFieldValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    field?: boolean | CustomFieldDefaultArgs<ExtArgs>
  }
  export type CustomFieldValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    field?: boolean | CustomFieldDefaultArgs<ExtArgs>
  }

  export type $CustomFieldValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomFieldValue"
    objects: {
      field: Prisma.$CustomFieldPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fieldId: string
      entity: string
      entityId: string
      value: string
      createdAt: Date
    }, ExtArgs["result"]["customFieldValue"]>
    composites: {}
  }

  type CustomFieldValueGetPayload<S extends boolean | null | undefined | CustomFieldValueDefaultArgs> = $Result.GetResult<Prisma.$CustomFieldValuePayload, S>

  type CustomFieldValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomFieldValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomFieldValueCountAggregateInputType | true
    }

  export interface CustomFieldValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomFieldValue'], meta: { name: 'CustomFieldValue' } }
    /**
     * Find zero or one CustomFieldValue that matches the filter.
     * @param {CustomFieldValueFindUniqueArgs} args - Arguments to find a CustomFieldValue
     * @example
     * // Get one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomFieldValueFindUniqueArgs>(args: SelectSubset<T, CustomFieldValueFindUniqueArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomFieldValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomFieldValueFindUniqueOrThrowArgs} args - Arguments to find a CustomFieldValue
     * @example
     * // Get one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomFieldValueFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomFieldValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomFieldValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueFindFirstArgs} args - Arguments to find a CustomFieldValue
     * @example
     * // Get one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomFieldValueFindFirstArgs>(args?: SelectSubset<T, CustomFieldValueFindFirstArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomFieldValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueFindFirstOrThrowArgs} args - Arguments to find a CustomFieldValue
     * @example
     * // Get one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomFieldValueFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomFieldValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomFieldValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomFieldValues
     * const customFieldValues = await prisma.customFieldValue.findMany()
     * 
     * // Get first 10 CustomFieldValues
     * const customFieldValues = await prisma.customFieldValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customFieldValueWithIdOnly = await prisma.customFieldValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomFieldValueFindManyArgs>(args?: SelectSubset<T, CustomFieldValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomFieldValue.
     * @param {CustomFieldValueCreateArgs} args - Arguments to create a CustomFieldValue.
     * @example
     * // Create one CustomFieldValue
     * const CustomFieldValue = await prisma.customFieldValue.create({
     *   data: {
     *     // ... data to create a CustomFieldValue
     *   }
     * })
     * 
     */
    create<T extends CustomFieldValueCreateArgs>(args: SelectSubset<T, CustomFieldValueCreateArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomFieldValues.
     * @param {CustomFieldValueCreateManyArgs} args - Arguments to create many CustomFieldValues.
     * @example
     * // Create many CustomFieldValues
     * const customFieldValue = await prisma.customFieldValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomFieldValueCreateManyArgs>(args?: SelectSubset<T, CustomFieldValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomFieldValues and returns the data saved in the database.
     * @param {CustomFieldValueCreateManyAndReturnArgs} args - Arguments to create many CustomFieldValues.
     * @example
     * // Create many CustomFieldValues
     * const customFieldValue = await prisma.customFieldValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomFieldValues and only return the `id`
     * const customFieldValueWithIdOnly = await prisma.customFieldValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomFieldValueCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomFieldValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomFieldValue.
     * @param {CustomFieldValueDeleteArgs} args - Arguments to delete one CustomFieldValue.
     * @example
     * // Delete one CustomFieldValue
     * const CustomFieldValue = await prisma.customFieldValue.delete({
     *   where: {
     *     // ... filter to delete one CustomFieldValue
     *   }
     * })
     * 
     */
    delete<T extends CustomFieldValueDeleteArgs>(args: SelectSubset<T, CustomFieldValueDeleteArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomFieldValue.
     * @param {CustomFieldValueUpdateArgs} args - Arguments to update one CustomFieldValue.
     * @example
     * // Update one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomFieldValueUpdateArgs>(args: SelectSubset<T, CustomFieldValueUpdateArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomFieldValues.
     * @param {CustomFieldValueDeleteManyArgs} args - Arguments to filter CustomFieldValues to delete.
     * @example
     * // Delete a few CustomFieldValues
     * const { count } = await prisma.customFieldValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomFieldValueDeleteManyArgs>(args?: SelectSubset<T, CustomFieldValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomFieldValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomFieldValues
     * const customFieldValue = await prisma.customFieldValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomFieldValueUpdateManyArgs>(args: SelectSubset<T, CustomFieldValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomFieldValues and returns the data updated in the database.
     * @param {CustomFieldValueUpdateManyAndReturnArgs} args - Arguments to update many CustomFieldValues.
     * @example
     * // Update many CustomFieldValues
     * const customFieldValue = await prisma.customFieldValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomFieldValues and only return the `id`
     * const customFieldValueWithIdOnly = await prisma.customFieldValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomFieldValueUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomFieldValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomFieldValue.
     * @param {CustomFieldValueUpsertArgs} args - Arguments to update or create a CustomFieldValue.
     * @example
     * // Update or create a CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.upsert({
     *   create: {
     *     // ... data to create a CustomFieldValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomFieldValue we want to update
     *   }
     * })
     */
    upsert<T extends CustomFieldValueUpsertArgs>(args: SelectSubset<T, CustomFieldValueUpsertArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomFieldValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueCountArgs} args - Arguments to filter CustomFieldValues to count.
     * @example
     * // Count the number of CustomFieldValues
     * const count = await prisma.customFieldValue.count({
     *   where: {
     *     // ... the filter for the CustomFieldValues we want to count
     *   }
     * })
    **/
    count<T extends CustomFieldValueCountArgs>(
      args?: Subset<T, CustomFieldValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomFieldValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomFieldValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomFieldValueAggregateArgs>(args: Subset<T, CustomFieldValueAggregateArgs>): Prisma.PrismaPromise<GetCustomFieldValueAggregateType<T>>

    /**
     * Group by CustomFieldValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomFieldValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomFieldValueGroupByArgs['orderBy'] }
        : { orderBy?: CustomFieldValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomFieldValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomFieldValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomFieldValue model
   */
  readonly fields: CustomFieldValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomFieldValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomFieldValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    field<T extends CustomFieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomFieldDefaultArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomFieldValue model
   */
  interface CustomFieldValueFieldRefs {
    readonly id: FieldRef<"CustomFieldValue", 'String'>
    readonly fieldId: FieldRef<"CustomFieldValue", 'String'>
    readonly entity: FieldRef<"CustomFieldValue", 'String'>
    readonly entityId: FieldRef<"CustomFieldValue", 'String'>
    readonly value: FieldRef<"CustomFieldValue", 'String'>
    readonly createdAt: FieldRef<"CustomFieldValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomFieldValue findUnique
   */
  export type CustomFieldValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValue to fetch.
     */
    where: CustomFieldValueWhereUniqueInput
  }

  /**
   * CustomFieldValue findUniqueOrThrow
   */
  export type CustomFieldValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValue to fetch.
     */
    where: CustomFieldValueWhereUniqueInput
  }

  /**
   * CustomFieldValue findFirst
   */
  export type CustomFieldValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValue to fetch.
     */
    where?: CustomFieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFieldValues to fetch.
     */
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFieldValues.
     */
    cursor?: CustomFieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFieldValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFieldValues.
     */
    distinct?: CustomFieldValueScalarFieldEnum | CustomFieldValueScalarFieldEnum[]
  }

  /**
   * CustomFieldValue findFirstOrThrow
   */
  export type CustomFieldValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValue to fetch.
     */
    where?: CustomFieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFieldValues to fetch.
     */
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFieldValues.
     */
    cursor?: CustomFieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFieldValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFieldValues.
     */
    distinct?: CustomFieldValueScalarFieldEnum | CustomFieldValueScalarFieldEnum[]
  }

  /**
   * CustomFieldValue findMany
   */
  export type CustomFieldValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValues to fetch.
     */
    where?: CustomFieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFieldValues to fetch.
     */
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomFieldValues.
     */
    cursor?: CustomFieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFieldValues.
     */
    skip?: number
    distinct?: CustomFieldValueScalarFieldEnum | CustomFieldValueScalarFieldEnum[]
  }

  /**
   * CustomFieldValue create
   */
  export type CustomFieldValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomFieldValue.
     */
    data: XOR<CustomFieldValueCreateInput, CustomFieldValueUncheckedCreateInput>
  }

  /**
   * CustomFieldValue createMany
   */
  export type CustomFieldValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomFieldValues.
     */
    data: CustomFieldValueCreateManyInput | CustomFieldValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomFieldValue createManyAndReturn
   */
  export type CustomFieldValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * The data used to create many CustomFieldValues.
     */
    data: CustomFieldValueCreateManyInput | CustomFieldValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomFieldValue update
   */
  export type CustomFieldValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomFieldValue.
     */
    data: XOR<CustomFieldValueUpdateInput, CustomFieldValueUncheckedUpdateInput>
    /**
     * Choose, which CustomFieldValue to update.
     */
    where: CustomFieldValueWhereUniqueInput
  }

  /**
   * CustomFieldValue updateMany
   */
  export type CustomFieldValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomFieldValues.
     */
    data: XOR<CustomFieldValueUpdateManyMutationInput, CustomFieldValueUncheckedUpdateManyInput>
    /**
     * Filter which CustomFieldValues to update
     */
    where?: CustomFieldValueWhereInput
    /**
     * Limit how many CustomFieldValues to update.
     */
    limit?: number
  }

  /**
   * CustomFieldValue updateManyAndReturn
   */
  export type CustomFieldValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * The data used to update CustomFieldValues.
     */
    data: XOR<CustomFieldValueUpdateManyMutationInput, CustomFieldValueUncheckedUpdateManyInput>
    /**
     * Filter which CustomFieldValues to update
     */
    where?: CustomFieldValueWhereInput
    /**
     * Limit how many CustomFieldValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomFieldValue upsert
   */
  export type CustomFieldValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomFieldValue to update in case it exists.
     */
    where: CustomFieldValueWhereUniqueInput
    /**
     * In case the CustomFieldValue found by the `where` argument doesn't exist, create a new CustomFieldValue with this data.
     */
    create: XOR<CustomFieldValueCreateInput, CustomFieldValueUncheckedCreateInput>
    /**
     * In case the CustomFieldValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomFieldValueUpdateInput, CustomFieldValueUncheckedUpdateInput>
  }

  /**
   * CustomFieldValue delete
   */
  export type CustomFieldValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter which CustomFieldValue to delete.
     */
    where: CustomFieldValueWhereUniqueInput
  }

  /**
   * CustomFieldValue deleteMany
   */
  export type CustomFieldValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomFieldValues to delete
     */
    where?: CustomFieldValueWhereInput
    /**
     * Limit how many CustomFieldValues to delete.
     */
    limit?: number
  }

  /**
   * CustomFieldValue without action
   */
  export type CustomFieldValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    entity: string | null
    entityId: string | null
    userId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    entity: string | null
    entityId: string | null
    userId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    entity: number
    entityId: number
    userId: number
    action: number
    changes: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    userId?: true
    action?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    userId?: true
    action?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    userId?: true
    action?: true
    changes?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    entity: string
    entityId: string
    userId: string
    action: string
    changes: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    userId?: boolean
    action?: boolean
    changes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    userId?: boolean
    action?: boolean
    changes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    userId?: boolean
    action?: boolean
    changes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    entity?: boolean
    entityId?: boolean
    userId?: boolean
    action?: boolean
    changes?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entity" | "entityId" | "userId" | "action" | "changes" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entity: string
      entityId: string
      userId: string
      action: string
      changes: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    entity: string | null
    entityId: string | null
    text: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    entity: string | null
    entityId: string | null
    text: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    entity: number
    entityId: number
    text: number
    userId: number
    mentions: number
    createdAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    text?: true
    userId?: true
    createdAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    text?: true
    userId?: true
    createdAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    text?: true
    userId?: true
    mentions?: true
    createdAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    entity: string
    entityId: string
    text: string
    userId: string
    mentions: string[]
    createdAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    text?: boolean
    userId?: boolean
    mentions?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    files?: boolean | Comment$filesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    text?: boolean
    userId?: boolean
    mentions?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    text?: boolean
    userId?: boolean
    mentions?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    entity?: boolean
    entityId?: boolean
    text?: boolean
    userId?: boolean
    mentions?: boolean
    createdAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entity" | "entityId" | "text" | "userId" | "mentions" | "createdAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    files?: boolean | Comment$filesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      files: Prisma.$FilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entity: string
      entityId: string
      text: string
      userId: string
      mentions: string[]
      createdAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    files<T extends Comment$filesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly entity: FieldRef<"Comment", 'String'>
    readonly entityId: FieldRef<"Comment", 'String'>
    readonly text: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly mentions: FieldRef<"Comment", 'String[]'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.files
   */
  export type Comment$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    message: string | null
    link: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    message: string | null
    link: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    message: number
    link: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    link?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    link?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    link?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    message: string
    link: string | null
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    link?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    link?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    link?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    link?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "message" | "link" | "isRead" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      message: string
      link: string | null
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    telegramId: 'telegramId',
    notificationsEnabled: 'notificationsEnabled',
    roleId: 'roleId',
    createdAt: 'createdAt',
    teamId: 'teamId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    name: 'name',
    industry: 'industry',
    phone: 'phone',
    email: 'email',
    website: 'website',
    address: 'address',
    ownerId: 'ownerId',
    createdAt: 'createdAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    position: 'position',
    ownerId: 'ownerId',
    accountId: 'accountId',
    createdAt: 'createdAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const DealScalarFieldEnum: {
    id: 'id',
    title: 'title',
    amount: 'amount',
    stage: 'stage',
    probability: 'probability',
    closeDate: 'closeDate',
    accountId: 'accountId',
    contactId: 'contactId',
    ownerId: 'ownerId',
    createdAt: 'createdAt'
  };

  export type DealScalarFieldEnum = (typeof DealScalarFieldEnum)[keyof typeof DealScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    status: 'status',
    description: 'description',
    date: 'date',
    ownerId: 'ownerId',
    accountId: 'accountId',
    contactId: 'contactId',
    dealId: 'dealId',
    parentId: 'parentId',
    createdAt: 'createdAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const EmailAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    smtpHost: 'smtpHost',
    smtpPort: 'smtpPort',
    smtpSecure: 'smtpSecure',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt'
  };

  export type EmailAccountScalarFieldEnum = (typeof EmailAccountScalarFieldEnum)[keyof typeof EmailAccountScalarFieldEnum]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    body: 'body',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const EmailMessageScalarFieldEnum: {
    id: 'id',
    subject: 'subject',
    to: 'to',
    body: 'body',
    status: 'status',
    userId: 'userId',
    templateId: 'templateId',
    attachments: 'attachments',
    createdAt: 'createdAt'
  };

  export type EmailMessageScalarFieldEnum = (typeof EmailMessageScalarFieldEnum)[keyof typeof EmailMessageScalarFieldEnum]


  export const EmailInboxMessageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    from: 'from',
    to: 'to',
    subject: 'subject',
    text: 'text',
    html: 'html',
    date: 'date',
    folder: 'folder',
    messageId: 'messageId',
    seen: 'seen',
    flagged: 'flagged',
    attachments: 'attachments',
    createdAt: 'createdAt'
  };

  export type EmailInboxMessageScalarFieldEnum = (typeof EmailInboxMessageScalarFieldEnum)[keyof typeof EmailInboxMessageScalarFieldEnum]


  export const EmailContactScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    name: 'name',
    phone: 'phone',
    company: 'company',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type EmailContactScalarFieldEnum = (typeof EmailContactScalarFieldEnum)[keyof typeof EmailContactScalarFieldEnum]


  export const DocumentTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    content: 'content',
    format: 'format',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type DocumentTemplateScalarFieldEnum = (typeof DocumentTemplateScalarFieldEnum)[keyof typeof DocumentTemplateScalarFieldEnum]


  export const GeneratedDocumentScalarFieldEnum: {
    id: 'id',
    filePath: 'filePath',
    format: 'format',
    templateId: 'templateId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type GeneratedDocumentScalarFieldEnum = (typeof GeneratedDocumentScalarFieldEnum)[keyof typeof GeneratedDocumentScalarFieldEnum]


  export const FileFolderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId',
    userId: 'userId',
    access: 'access',
    createdAt: 'createdAt',
    accountId: 'accountId',
    dealId: 'dealId'
  };

  export type FileFolderScalarFieldEnum = (typeof FileFolderScalarFieldEnum)[keyof typeof FileFolderScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    path: 'path',
    size: 'size',
    mimeType: 'mimeType',
    userId: 'userId',
    folderId: 'folderId',
    dealId: 'dealId',
    contactId: 'contactId',
    taskId: 'taskId',
    publicLink: 'publicLink',
    expiresAt: 'expiresAt',
    access: 'access',
    createdAt: 'createdAt',
    commentId: 'commentId'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const SettingOptionScalarFieldEnum: {
    id: 'id',
    category: 'category',
    label: 'label',
    value: 'value',
    position: 'position',
    createdAt: 'createdAt'
  };

  export type SettingOptionScalarFieldEnum = (typeof SettingOptionScalarFieldEnum)[keyof typeof SettingOptionScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const DealTagScalarFieldEnum: {
    dealId: 'dealId',
    tagId: 'tagId'
  };

  export type DealTagScalarFieldEnum = (typeof DealTagScalarFieldEnum)[keyof typeof DealTagScalarFieldEnum]


  export const ContactTagScalarFieldEnum: {
    contactId: 'contactId',
    tagId: 'tagId'
  };

  export type ContactTagScalarFieldEnum = (typeof ContactTagScalarFieldEnum)[keyof typeof ContactTagScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    label: 'label',
    color: 'color',
    createdAt: 'createdAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const WebhookScalarFieldEnum: {
    id: 'id',
    url: 'url',
    event: 'event',
    enabled: 'enabled',
    createdAt: 'createdAt'
  };

  export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


  export const SharedAccessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    entityId: 'entityId',
    entity: 'entity',
    canEdit: 'canEdit',
    createdAt: 'createdAt'
  };

  export type SharedAccessScalarFieldEnum = (typeof SharedAccessScalarFieldEnum)[keyof typeof SharedAccessScalarFieldEnum]


  export const AutomationRuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    entity: 'entity',
    trigger: 'trigger',
    field: 'field',
    condition: 'condition',
    action: 'action',
    enabled: 'enabled',
    createdAt: 'createdAt'
  };

  export type AutomationRuleScalarFieldEnum = (typeof AutomationRuleScalarFieldEnum)[keyof typeof AutomationRuleScalarFieldEnum]


  export const CustomFieldScalarFieldEnum: {
    id: 'id',
    entity: 'entity',
    name: 'name',
    label: 'label',
    type: 'type',
    options: 'options',
    required: 'required',
    createdAt: 'createdAt'
  };

  export type CustomFieldScalarFieldEnum = (typeof CustomFieldScalarFieldEnum)[keyof typeof CustomFieldScalarFieldEnum]


  export const CustomFieldValueScalarFieldEnum: {
    id: 'id',
    fieldId: 'fieldId',
    entity: 'entity',
    entityId: 'entityId',
    value: 'value',
    createdAt: 'createdAt'
  };

  export type CustomFieldValueScalarFieldEnum = (typeof CustomFieldValueScalarFieldEnum)[keyof typeof CustomFieldValueScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    entity: 'entity',
    entityId: 'entityId',
    userId: 'userId',
    action: 'action',
    changes: 'changes',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    entity: 'entity',
    entityId: 'entityId',
    text: 'text',
    userId: 'userId',
    mentions: 'mentions',
    createdAt: 'createdAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    message: 'message',
    link: 'link',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    telegramId?: StringNullableFilter<"User"> | string | null
    notificationsEnabled?: BoolFilter<"User"> | boolean
    roleId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    teamId?: StringNullableFilter<"User"> | string | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    Account?: AccountListRelationFilter
    Contact?: ContactListRelationFilter
    Deal?: DealListRelationFilter
    Activity?: ActivityListRelationFilter
    EmailAccount?: EmailAccountListRelationFilter
    EmailTemplate?: EmailTemplateListRelationFilter
    EmailMessage?: EmailMessageListRelationFilter
    EmailInboxMessage?: EmailInboxMessageListRelationFilter
    EmailContact?: EmailContactListRelationFilter
    DocumentTemplate?: DocumentTemplateListRelationFilter
    GeneratedDocument?: GeneratedDocumentListRelationFilter
    FileFolder?: FileFolderListRelationFilter
    File?: FileListRelationFilter
    SharedAccess?: SharedAccessListRelationFilter
    AuditLog?: AuditLogListRelationFilter
    Comment?: CommentListRelationFilter
    Notification?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    telegramId?: SortOrderInput | SortOrder
    notificationsEnabled?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    teamId?: SortOrderInput | SortOrder
    role?: RoleOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    Account?: AccountOrderByRelationAggregateInput
    Contact?: ContactOrderByRelationAggregateInput
    Deal?: DealOrderByRelationAggregateInput
    Activity?: ActivityOrderByRelationAggregateInput
    EmailAccount?: EmailAccountOrderByRelationAggregateInput
    EmailTemplate?: EmailTemplateOrderByRelationAggregateInput
    EmailMessage?: EmailMessageOrderByRelationAggregateInput
    EmailInboxMessage?: EmailInboxMessageOrderByRelationAggregateInput
    EmailContact?: EmailContactOrderByRelationAggregateInput
    DocumentTemplate?: DocumentTemplateOrderByRelationAggregateInput
    GeneratedDocument?: GeneratedDocumentOrderByRelationAggregateInput
    FileFolder?: FileFolderOrderByRelationAggregateInput
    File?: FileOrderByRelationAggregateInput
    SharedAccess?: SharedAccessOrderByRelationAggregateInput
    AuditLog?: AuditLogOrderByRelationAggregateInput
    Comment?: CommentOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    telegramId?: StringNullableFilter<"User"> | string | null
    notificationsEnabled?: BoolFilter<"User"> | boolean
    roleId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    teamId?: StringNullableFilter<"User"> | string | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    Account?: AccountListRelationFilter
    Contact?: ContactListRelationFilter
    Deal?: DealListRelationFilter
    Activity?: ActivityListRelationFilter
    EmailAccount?: EmailAccountListRelationFilter
    EmailTemplate?: EmailTemplateListRelationFilter
    EmailMessage?: EmailMessageListRelationFilter
    EmailInboxMessage?: EmailInboxMessageListRelationFilter
    EmailContact?: EmailContactListRelationFilter
    DocumentTemplate?: DocumentTemplateListRelationFilter
    GeneratedDocument?: GeneratedDocumentListRelationFilter
    FileFolder?: FileFolderListRelationFilter
    File?: FileListRelationFilter
    SharedAccess?: SharedAccessListRelationFilter
    AuditLog?: AuditLogListRelationFilter
    Comment?: CommentListRelationFilter
    Notification?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    telegramId?: SortOrderInput | SortOrder
    notificationsEnabled?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    teamId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    telegramId?: StringNullableWithAggregatesFilter<"User"> | string | null
    notificationsEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    roleId?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    teamId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    users?: UserListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    users?: UserListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    users?: UserListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    industry?: StringNullableFilter<"Account"> | string | null
    phone?: StringNullableFilter<"Account"> | string | null
    email?: StringNullableFilter<"Account"> | string | null
    website?: StringNullableFilter<"Account"> | string | null
    address?: StringNullableFilter<"Account"> | string | null
    ownerId?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    Contact?: ContactListRelationFilter
    Deal?: DealListRelationFilter
    Activity?: ActivityListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    industry?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    Contact?: ContactOrderByRelationAggregateInput
    Deal?: DealOrderByRelationAggregateInput
    Activity?: ActivityOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    name?: StringFilter<"Account"> | string
    industry?: StringNullableFilter<"Account"> | string | null
    phone?: StringNullableFilter<"Account"> | string | null
    email?: StringNullableFilter<"Account"> | string | null
    website?: StringNullableFilter<"Account"> | string | null
    address?: StringNullableFilter<"Account"> | string | null
    ownerId?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    Contact?: ContactListRelationFilter
    Deal?: DealListRelationFilter
    Activity?: ActivityListRelationFilter
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    industry?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    name?: StringWithAggregatesFilter<"Account"> | string
    industry?: StringNullableWithAggregatesFilter<"Account"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Account"> | string | null
    email?: StringNullableWithAggregatesFilter<"Account"> | string | null
    website?: StringNullableWithAggregatesFilter<"Account"> | string | null
    address?: StringNullableWithAggregatesFilter<"Account"> | string | null
    ownerId?: StringWithAggregatesFilter<"Account"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    firstName?: StringFilter<"Contact"> | string
    lastName?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    position?: StringNullableFilter<"Contact"> | string | null
    ownerId?: StringFilter<"Contact"> | string
    accountId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    Deal?: DealListRelationFilter
    Activity?: ActivityListRelationFilter
    ContactTag?: ContactTagListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    accountId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    Deal?: DealOrderByRelationAggregateInput
    Activity?: ActivityOrderByRelationAggregateInput
    ContactTag?: ContactTagOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    firstName?: StringFilter<"Contact"> | string
    lastName?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    position?: StringNullableFilter<"Contact"> | string | null
    ownerId?: StringFilter<"Contact"> | string
    accountId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    Deal?: DealListRelationFilter
    Activity?: ActivityListRelationFilter
    ContactTag?: ContactTagListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    accountId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    firstName?: StringWithAggregatesFilter<"Contact"> | string
    lastName?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    position?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    ownerId?: StringWithAggregatesFilter<"Contact"> | string
    accountId?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type DealWhereInput = {
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    id?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    amount?: FloatFilter<"Deal"> | number
    stage?: StringFilter<"Deal"> | string
    probability?: IntFilter<"Deal"> | number
    closeDate?: DateTimeFilter<"Deal"> | Date | string
    accountId?: StringNullableFilter<"Deal"> | string | null
    contactId?: StringNullableFilter<"Deal"> | string | null
    ownerId?: StringFilter<"Deal"> | string
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    Activity?: ActivityListRelationFilter
    DealTag?: DealTagListRelationFilter
  }

  export type DealOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    stage?: SortOrder
    probability?: SortOrder
    closeDate?: SortOrder
    accountId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    Activity?: ActivityOrderByRelationAggregateInput
    DealTag?: DealTagOrderByRelationAggregateInput
  }

  export type DealWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    title?: StringFilter<"Deal"> | string
    amount?: FloatFilter<"Deal"> | number
    stage?: StringFilter<"Deal"> | string
    probability?: IntFilter<"Deal"> | number
    closeDate?: DateTimeFilter<"Deal"> | Date | string
    accountId?: StringNullableFilter<"Deal"> | string | null
    contactId?: StringNullableFilter<"Deal"> | string | null
    ownerId?: StringFilter<"Deal"> | string
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    Activity?: ActivityListRelationFilter
    DealTag?: DealTagListRelationFilter
  }, "id">

  export type DealOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    stage?: SortOrder
    probability?: SortOrder
    closeDate?: SortOrder
    accountId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    _count?: DealCountOrderByAggregateInput
    _avg?: DealAvgOrderByAggregateInput
    _max?: DealMaxOrderByAggregateInput
    _min?: DealMinOrderByAggregateInput
    _sum?: DealSumOrderByAggregateInput
  }

  export type DealScalarWhereWithAggregatesInput = {
    AND?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    OR?: DealScalarWhereWithAggregatesInput[]
    NOT?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deal"> | string
    title?: StringWithAggregatesFilter<"Deal"> | string
    amount?: FloatWithAggregatesFilter<"Deal"> | number
    stage?: StringWithAggregatesFilter<"Deal"> | string
    probability?: IntWithAggregatesFilter<"Deal"> | number
    closeDate?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
    accountId?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    ownerId?: StringWithAggregatesFilter<"Deal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    type?: StringFilter<"Activity"> | string
    status?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    date?: DateTimeFilter<"Activity"> | Date | string
    ownerId?: StringFilter<"Activity"> | string
    accountId?: StringNullableFilter<"Activity"> | string | null
    contactId?: StringNullableFilter<"Activity"> | string | null
    dealId?: StringNullableFilter<"Activity"> | string | null
    parentId?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    parent?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
    subtasks?: ActivityListRelationFilter
    tags?: TagListRelationFilter
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    ownerId?: SortOrder
    accountId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    parent?: ActivityOrderByWithRelationInput
    subtasks?: ActivityOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    title?: StringFilter<"Activity"> | string
    type?: StringFilter<"Activity"> | string
    status?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    date?: DateTimeFilter<"Activity"> | Date | string
    ownerId?: StringFilter<"Activity"> | string
    accountId?: StringNullableFilter<"Activity"> | string | null
    contactId?: StringNullableFilter<"Activity"> | string | null
    dealId?: StringNullableFilter<"Activity"> | string | null
    parentId?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    parent?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
    subtasks?: ActivityListRelationFilter
    tags?: TagListRelationFilter
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    ownerId?: SortOrder
    accountId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    title?: StringWithAggregatesFilter<"Activity"> | string
    type?: StringWithAggregatesFilter<"Activity"> | string
    status?: StringWithAggregatesFilter<"Activity"> | string
    description?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    date?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    ownerId?: StringWithAggregatesFilter<"Activity"> | string
    accountId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type EmailAccountWhereInput = {
    AND?: EmailAccountWhereInput | EmailAccountWhereInput[]
    OR?: EmailAccountWhereInput[]
    NOT?: EmailAccountWhereInput | EmailAccountWhereInput[]
    id?: StringFilter<"EmailAccount"> | string
    userId?: StringFilter<"EmailAccount"> | string
    smtpHost?: StringFilter<"EmailAccount"> | string
    smtpPort?: IntFilter<"EmailAccount"> | number
    smtpSecure?: BoolFilter<"EmailAccount"> | boolean
    email?: StringFilter<"EmailAccount"> | string
    password?: StringFilter<"EmailAccount"> | string
    createdAt?: DateTimeFilter<"EmailAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmailAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpSecure?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmailAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailAccountWhereInput | EmailAccountWhereInput[]
    OR?: EmailAccountWhereInput[]
    NOT?: EmailAccountWhereInput | EmailAccountWhereInput[]
    userId?: StringFilter<"EmailAccount"> | string
    smtpHost?: StringFilter<"EmailAccount"> | string
    smtpPort?: IntFilter<"EmailAccount"> | number
    smtpSecure?: BoolFilter<"EmailAccount"> | boolean
    email?: StringFilter<"EmailAccount"> | string
    password?: StringFilter<"EmailAccount"> | string
    createdAt?: DateTimeFilter<"EmailAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type EmailAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpSecure?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _count?: EmailAccountCountOrderByAggregateInput
    _avg?: EmailAccountAvgOrderByAggregateInput
    _max?: EmailAccountMaxOrderByAggregateInput
    _min?: EmailAccountMinOrderByAggregateInput
    _sum?: EmailAccountSumOrderByAggregateInput
  }

  export type EmailAccountScalarWhereWithAggregatesInput = {
    AND?: EmailAccountScalarWhereWithAggregatesInput | EmailAccountScalarWhereWithAggregatesInput[]
    OR?: EmailAccountScalarWhereWithAggregatesInput[]
    NOT?: EmailAccountScalarWhereWithAggregatesInput | EmailAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailAccount"> | string
    userId?: StringWithAggregatesFilter<"EmailAccount"> | string
    smtpHost?: StringWithAggregatesFilter<"EmailAccount"> | string
    smtpPort?: IntWithAggregatesFilter<"EmailAccount"> | number
    smtpSecure?: BoolWithAggregatesFilter<"EmailAccount"> | boolean
    email?: StringWithAggregatesFilter<"EmailAccount"> | string
    password?: StringWithAggregatesFilter<"EmailAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailAccount"> | Date | string
  }

  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    body?: StringFilter<"EmailTemplate"> | string
    userId?: StringFilter<"EmailTemplate"> | string
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    EmailMessage?: EmailMessageListRelationFilter
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    EmailMessage?: EmailMessageOrderByRelationAggregateInput
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    body?: StringFilter<"EmailTemplate"> | string
    userId?: StringFilter<"EmailTemplate"> | string
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    EmailMessage?: EmailMessageListRelationFilter
  }, "id">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTemplate"> | string
    name?: StringWithAggregatesFilter<"EmailTemplate"> | string
    subject?: StringWithAggregatesFilter<"EmailTemplate"> | string
    body?: StringWithAggregatesFilter<"EmailTemplate"> | string
    userId?: StringWithAggregatesFilter<"EmailTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
  }

  export type EmailMessageWhereInput = {
    AND?: EmailMessageWhereInput | EmailMessageWhereInput[]
    OR?: EmailMessageWhereInput[]
    NOT?: EmailMessageWhereInput | EmailMessageWhereInput[]
    id?: StringFilter<"EmailMessage"> | string
    subject?: StringFilter<"EmailMessage"> | string
    to?: StringFilter<"EmailMessage"> | string
    body?: StringFilter<"EmailMessage"> | string
    status?: StringFilter<"EmailMessage"> | string
    userId?: StringFilter<"EmailMessage"> | string
    templateId?: StringNullableFilter<"EmailMessage"> | string | null
    attachments?: JsonNullableFilter<"EmailMessage">
    createdAt?: DateTimeFilter<"EmailMessage"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
  }

  export type EmailMessageOrderByWithRelationInput = {
    id?: SortOrder
    subject?: SortOrder
    to?: SortOrder
    body?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    template?: EmailTemplateOrderByWithRelationInput
  }

  export type EmailMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailMessageWhereInput | EmailMessageWhereInput[]
    OR?: EmailMessageWhereInput[]
    NOT?: EmailMessageWhereInput | EmailMessageWhereInput[]
    subject?: StringFilter<"EmailMessage"> | string
    to?: StringFilter<"EmailMessage"> | string
    body?: StringFilter<"EmailMessage"> | string
    status?: StringFilter<"EmailMessage"> | string
    userId?: StringFilter<"EmailMessage"> | string
    templateId?: StringNullableFilter<"EmailMessage"> | string | null
    attachments?: JsonNullableFilter<"EmailMessage">
    createdAt?: DateTimeFilter<"EmailMessage"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
  }, "id">

  export type EmailMessageOrderByWithAggregationInput = {
    id?: SortOrder
    subject?: SortOrder
    to?: SortOrder
    body?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmailMessageCountOrderByAggregateInput
    _max?: EmailMessageMaxOrderByAggregateInput
    _min?: EmailMessageMinOrderByAggregateInput
  }

  export type EmailMessageScalarWhereWithAggregatesInput = {
    AND?: EmailMessageScalarWhereWithAggregatesInput | EmailMessageScalarWhereWithAggregatesInput[]
    OR?: EmailMessageScalarWhereWithAggregatesInput[]
    NOT?: EmailMessageScalarWhereWithAggregatesInput | EmailMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailMessage"> | string
    subject?: StringWithAggregatesFilter<"EmailMessage"> | string
    to?: StringWithAggregatesFilter<"EmailMessage"> | string
    body?: StringWithAggregatesFilter<"EmailMessage"> | string
    status?: StringWithAggregatesFilter<"EmailMessage"> | string
    userId?: StringWithAggregatesFilter<"EmailMessage"> | string
    templateId?: StringNullableWithAggregatesFilter<"EmailMessage"> | string | null
    attachments?: JsonNullableWithAggregatesFilter<"EmailMessage">
    createdAt?: DateTimeWithAggregatesFilter<"EmailMessage"> | Date | string
  }

  export type EmailInboxMessageWhereInput = {
    AND?: EmailInboxMessageWhereInput | EmailInboxMessageWhereInput[]
    OR?: EmailInboxMessageWhereInput[]
    NOT?: EmailInboxMessageWhereInput | EmailInboxMessageWhereInput[]
    id?: StringFilter<"EmailInboxMessage"> | string
    userId?: StringFilter<"EmailInboxMessage"> | string
    from?: StringFilter<"EmailInboxMessage"> | string
    to?: StringFilter<"EmailInboxMessage"> | string
    subject?: StringFilter<"EmailInboxMessage"> | string
    text?: StringNullableFilter<"EmailInboxMessage"> | string | null
    html?: StringNullableFilter<"EmailInboxMessage"> | string | null
    date?: DateTimeFilter<"EmailInboxMessage"> | Date | string
    folder?: StringFilter<"EmailInboxMessage"> | string
    messageId?: StringFilter<"EmailInboxMessage"> | string
    seen?: BoolFilter<"EmailInboxMessage"> | boolean
    flagged?: BoolFilter<"EmailInboxMessage"> | boolean
    attachments?: JsonNullableFilter<"EmailInboxMessage">
    createdAt?: DateTimeFilter<"EmailInboxMessage"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmailInboxMessageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    from?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    text?: SortOrderInput | SortOrder
    html?: SortOrderInput | SortOrder
    date?: SortOrder
    folder?: SortOrder
    messageId?: SortOrder
    seen?: SortOrder
    flagged?: SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmailInboxMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId?: string
    AND?: EmailInboxMessageWhereInput | EmailInboxMessageWhereInput[]
    OR?: EmailInboxMessageWhereInput[]
    NOT?: EmailInboxMessageWhereInput | EmailInboxMessageWhereInput[]
    userId?: StringFilter<"EmailInboxMessage"> | string
    from?: StringFilter<"EmailInboxMessage"> | string
    to?: StringFilter<"EmailInboxMessage"> | string
    subject?: StringFilter<"EmailInboxMessage"> | string
    text?: StringNullableFilter<"EmailInboxMessage"> | string | null
    html?: StringNullableFilter<"EmailInboxMessage"> | string | null
    date?: DateTimeFilter<"EmailInboxMessage"> | Date | string
    folder?: StringFilter<"EmailInboxMessage"> | string
    seen?: BoolFilter<"EmailInboxMessage"> | boolean
    flagged?: BoolFilter<"EmailInboxMessage"> | boolean
    attachments?: JsonNullableFilter<"EmailInboxMessage">
    createdAt?: DateTimeFilter<"EmailInboxMessage"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "messageId">

  export type EmailInboxMessageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    from?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    text?: SortOrderInput | SortOrder
    html?: SortOrderInput | SortOrder
    date?: SortOrder
    folder?: SortOrder
    messageId?: SortOrder
    seen?: SortOrder
    flagged?: SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmailInboxMessageCountOrderByAggregateInput
    _max?: EmailInboxMessageMaxOrderByAggregateInput
    _min?: EmailInboxMessageMinOrderByAggregateInput
  }

  export type EmailInboxMessageScalarWhereWithAggregatesInput = {
    AND?: EmailInboxMessageScalarWhereWithAggregatesInput | EmailInboxMessageScalarWhereWithAggregatesInput[]
    OR?: EmailInboxMessageScalarWhereWithAggregatesInput[]
    NOT?: EmailInboxMessageScalarWhereWithAggregatesInput | EmailInboxMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailInboxMessage"> | string
    userId?: StringWithAggregatesFilter<"EmailInboxMessage"> | string
    from?: StringWithAggregatesFilter<"EmailInboxMessage"> | string
    to?: StringWithAggregatesFilter<"EmailInboxMessage"> | string
    subject?: StringWithAggregatesFilter<"EmailInboxMessage"> | string
    text?: StringNullableWithAggregatesFilter<"EmailInboxMessage"> | string | null
    html?: StringNullableWithAggregatesFilter<"EmailInboxMessage"> | string | null
    date?: DateTimeWithAggregatesFilter<"EmailInboxMessage"> | Date | string
    folder?: StringWithAggregatesFilter<"EmailInboxMessage"> | string
    messageId?: StringWithAggregatesFilter<"EmailInboxMessage"> | string
    seen?: BoolWithAggregatesFilter<"EmailInboxMessage"> | boolean
    flagged?: BoolWithAggregatesFilter<"EmailInboxMessage"> | boolean
    attachments?: JsonNullableWithAggregatesFilter<"EmailInboxMessage">
    createdAt?: DateTimeWithAggregatesFilter<"EmailInboxMessage"> | Date | string
  }

  export type EmailContactWhereInput = {
    AND?: EmailContactWhereInput | EmailContactWhereInput[]
    OR?: EmailContactWhereInput[]
    NOT?: EmailContactWhereInput | EmailContactWhereInput[]
    id?: StringFilter<"EmailContact"> | string
    userId?: StringFilter<"EmailContact"> | string
    email?: StringFilter<"EmailContact"> | string
    name?: StringNullableFilter<"EmailContact"> | string | null
    phone?: StringNullableFilter<"EmailContact"> | string | null
    company?: StringNullableFilter<"EmailContact"> | string | null
    notes?: StringNullableFilter<"EmailContact"> | string | null
    createdAt?: DateTimeFilter<"EmailContact"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmailContactOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmailContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_email?: EmailContactUserIdEmailCompoundUniqueInput
    AND?: EmailContactWhereInput | EmailContactWhereInput[]
    OR?: EmailContactWhereInput[]
    NOT?: EmailContactWhereInput | EmailContactWhereInput[]
    userId?: StringFilter<"EmailContact"> | string
    email?: StringFilter<"EmailContact"> | string
    name?: StringNullableFilter<"EmailContact"> | string | null
    phone?: StringNullableFilter<"EmailContact"> | string | null
    company?: StringNullableFilter<"EmailContact"> | string | null
    notes?: StringNullableFilter<"EmailContact"> | string | null
    createdAt?: DateTimeFilter<"EmailContact"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_email">

  export type EmailContactOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmailContactCountOrderByAggregateInput
    _max?: EmailContactMaxOrderByAggregateInput
    _min?: EmailContactMinOrderByAggregateInput
  }

  export type EmailContactScalarWhereWithAggregatesInput = {
    AND?: EmailContactScalarWhereWithAggregatesInput | EmailContactScalarWhereWithAggregatesInput[]
    OR?: EmailContactScalarWhereWithAggregatesInput[]
    NOT?: EmailContactScalarWhereWithAggregatesInput | EmailContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailContact"> | string
    userId?: StringWithAggregatesFilter<"EmailContact"> | string
    email?: StringWithAggregatesFilter<"EmailContact"> | string
    name?: StringNullableWithAggregatesFilter<"EmailContact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"EmailContact"> | string | null
    company?: StringNullableWithAggregatesFilter<"EmailContact"> | string | null
    notes?: StringNullableWithAggregatesFilter<"EmailContact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailContact"> | Date | string
  }

  export type DocumentTemplateWhereInput = {
    AND?: DocumentTemplateWhereInput | DocumentTemplateWhereInput[]
    OR?: DocumentTemplateWhereInput[]
    NOT?: DocumentTemplateWhereInput | DocumentTemplateWhereInput[]
    id?: StringFilter<"DocumentTemplate"> | string
    name?: StringFilter<"DocumentTemplate"> | string
    content?: StringFilter<"DocumentTemplate"> | string
    format?: StringFilter<"DocumentTemplate"> | string
    userId?: StringFilter<"DocumentTemplate"> | string
    createdAt?: DateTimeFilter<"DocumentTemplate"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    GeneratedDocument?: GeneratedDocumentListRelationFilter
  }

  export type DocumentTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    format?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    GeneratedDocument?: GeneratedDocumentOrderByRelationAggregateInput
  }

  export type DocumentTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentTemplateWhereInput | DocumentTemplateWhereInput[]
    OR?: DocumentTemplateWhereInput[]
    NOT?: DocumentTemplateWhereInput | DocumentTemplateWhereInput[]
    name?: StringFilter<"DocumentTemplate"> | string
    content?: StringFilter<"DocumentTemplate"> | string
    format?: StringFilter<"DocumentTemplate"> | string
    userId?: StringFilter<"DocumentTemplate"> | string
    createdAt?: DateTimeFilter<"DocumentTemplate"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    GeneratedDocument?: GeneratedDocumentListRelationFilter
  }, "id">

  export type DocumentTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    format?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: DocumentTemplateCountOrderByAggregateInput
    _max?: DocumentTemplateMaxOrderByAggregateInput
    _min?: DocumentTemplateMinOrderByAggregateInput
  }

  export type DocumentTemplateScalarWhereWithAggregatesInput = {
    AND?: DocumentTemplateScalarWhereWithAggregatesInput | DocumentTemplateScalarWhereWithAggregatesInput[]
    OR?: DocumentTemplateScalarWhereWithAggregatesInput[]
    NOT?: DocumentTemplateScalarWhereWithAggregatesInput | DocumentTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentTemplate"> | string
    name?: StringWithAggregatesFilter<"DocumentTemplate"> | string
    content?: StringWithAggregatesFilter<"DocumentTemplate"> | string
    format?: StringWithAggregatesFilter<"DocumentTemplate"> | string
    userId?: StringWithAggregatesFilter<"DocumentTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DocumentTemplate"> | Date | string
  }

  export type GeneratedDocumentWhereInput = {
    AND?: GeneratedDocumentWhereInput | GeneratedDocumentWhereInput[]
    OR?: GeneratedDocumentWhereInput[]
    NOT?: GeneratedDocumentWhereInput | GeneratedDocumentWhereInput[]
    id?: StringFilter<"GeneratedDocument"> | string
    filePath?: StringFilter<"GeneratedDocument"> | string
    format?: StringFilter<"GeneratedDocument"> | string
    templateId?: StringFilter<"GeneratedDocument"> | string
    userId?: StringFilter<"GeneratedDocument"> | string
    createdAt?: DateTimeFilter<"GeneratedDocument"> | Date | string
    template?: XOR<DocumentTemplateScalarRelationFilter, DocumentTemplateWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GeneratedDocumentOrderByWithRelationInput = {
    id?: SortOrder
    filePath?: SortOrder
    format?: SortOrder
    templateId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    template?: DocumentTemplateOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type GeneratedDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GeneratedDocumentWhereInput | GeneratedDocumentWhereInput[]
    OR?: GeneratedDocumentWhereInput[]
    NOT?: GeneratedDocumentWhereInput | GeneratedDocumentWhereInput[]
    filePath?: StringFilter<"GeneratedDocument"> | string
    format?: StringFilter<"GeneratedDocument"> | string
    templateId?: StringFilter<"GeneratedDocument"> | string
    userId?: StringFilter<"GeneratedDocument"> | string
    createdAt?: DateTimeFilter<"GeneratedDocument"> | Date | string
    template?: XOR<DocumentTemplateScalarRelationFilter, DocumentTemplateWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GeneratedDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    filePath?: SortOrder
    format?: SortOrder
    templateId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: GeneratedDocumentCountOrderByAggregateInput
    _max?: GeneratedDocumentMaxOrderByAggregateInput
    _min?: GeneratedDocumentMinOrderByAggregateInput
  }

  export type GeneratedDocumentScalarWhereWithAggregatesInput = {
    AND?: GeneratedDocumentScalarWhereWithAggregatesInput | GeneratedDocumentScalarWhereWithAggregatesInput[]
    OR?: GeneratedDocumentScalarWhereWithAggregatesInput[]
    NOT?: GeneratedDocumentScalarWhereWithAggregatesInput | GeneratedDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GeneratedDocument"> | string
    filePath?: StringWithAggregatesFilter<"GeneratedDocument"> | string
    format?: StringWithAggregatesFilter<"GeneratedDocument"> | string
    templateId?: StringWithAggregatesFilter<"GeneratedDocument"> | string
    userId?: StringWithAggregatesFilter<"GeneratedDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GeneratedDocument"> | Date | string
  }

  export type FileFolderWhereInput = {
    AND?: FileFolderWhereInput | FileFolderWhereInput[]
    OR?: FileFolderWhereInput[]
    NOT?: FileFolderWhereInput | FileFolderWhereInput[]
    id?: StringFilter<"FileFolder"> | string
    name?: StringFilter<"FileFolder"> | string
    parentId?: StringNullableFilter<"FileFolder"> | string | null
    userId?: StringFilter<"FileFolder"> | string
    access?: StringFilter<"FileFolder"> | string
    createdAt?: DateTimeFilter<"FileFolder"> | Date | string
    accountId?: StringNullableFilter<"FileFolder"> | string | null
    dealId?: StringNullableFilter<"FileFolder"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    files?: FileListRelationFilter
  }

  export type FileFolderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    userId?: SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    files?: FileOrderByRelationAggregateInput
  }

  export type FileFolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileFolderWhereInput | FileFolderWhereInput[]
    OR?: FileFolderWhereInput[]
    NOT?: FileFolderWhereInput | FileFolderWhereInput[]
    name?: StringFilter<"FileFolder"> | string
    parentId?: StringNullableFilter<"FileFolder"> | string | null
    userId?: StringFilter<"FileFolder"> | string
    access?: StringFilter<"FileFolder"> | string
    createdAt?: DateTimeFilter<"FileFolder"> | Date | string
    accountId?: StringNullableFilter<"FileFolder"> | string | null
    dealId?: StringNullableFilter<"FileFolder"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    files?: FileListRelationFilter
  }, "id">

  export type FileFolderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    userId?: SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    _count?: FileFolderCountOrderByAggregateInput
    _max?: FileFolderMaxOrderByAggregateInput
    _min?: FileFolderMinOrderByAggregateInput
  }

  export type FileFolderScalarWhereWithAggregatesInput = {
    AND?: FileFolderScalarWhereWithAggregatesInput | FileFolderScalarWhereWithAggregatesInput[]
    OR?: FileFolderScalarWhereWithAggregatesInput[]
    NOT?: FileFolderScalarWhereWithAggregatesInput | FileFolderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FileFolder"> | string
    name?: StringWithAggregatesFilter<"FileFolder"> | string
    parentId?: StringNullableWithAggregatesFilter<"FileFolder"> | string | null
    userId?: StringWithAggregatesFilter<"FileFolder"> | string
    access?: StringWithAggregatesFilter<"FileFolder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FileFolder"> | Date | string
    accountId?: StringNullableWithAggregatesFilter<"FileFolder"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"FileFolder"> | string | null
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    name?: StringFilter<"File"> | string
    path?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    mimeType?: StringFilter<"File"> | string
    userId?: StringFilter<"File"> | string
    folderId?: StringNullableFilter<"File"> | string | null
    dealId?: StringNullableFilter<"File"> | string | null
    contactId?: StringNullableFilter<"File"> | string | null
    taskId?: StringNullableFilter<"File"> | string | null
    publicLink?: StringNullableFilter<"File"> | string | null
    expiresAt?: DateTimeNullableFilter<"File"> | Date | string | null
    access?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    commentId?: StringNullableFilter<"File"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    folder?: XOR<FileFolderNullableScalarRelationFilter, FileFolderWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    userId?: SortOrder
    folderId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    taskId?: SortOrderInput | SortOrder
    publicLink?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    folder?: FileFolderOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    publicLink?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    name?: StringFilter<"File"> | string
    path?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    mimeType?: StringFilter<"File"> | string
    userId?: StringFilter<"File"> | string
    folderId?: StringNullableFilter<"File"> | string | null
    dealId?: StringNullableFilter<"File"> | string | null
    contactId?: StringNullableFilter<"File"> | string | null
    taskId?: StringNullableFilter<"File"> | string | null
    expiresAt?: DateTimeNullableFilter<"File"> | Date | string | null
    access?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    commentId?: StringNullableFilter<"File"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    folder?: XOR<FileFolderNullableScalarRelationFilter, FileFolderWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
  }, "id" | "publicLink">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    userId?: SortOrder
    folderId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    taskId?: SortOrderInput | SortOrder
    publicLink?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrderInput | SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    name?: StringWithAggregatesFilter<"File"> | string
    path?: StringWithAggregatesFilter<"File"> | string
    size?: IntWithAggregatesFilter<"File"> | number
    mimeType?: StringWithAggregatesFilter<"File"> | string
    userId?: StringWithAggregatesFilter<"File"> | string
    folderId?: StringNullableWithAggregatesFilter<"File"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"File"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"File"> | string | null
    taskId?: StringNullableWithAggregatesFilter<"File"> | string | null
    publicLink?: StringNullableWithAggregatesFilter<"File"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"File"> | Date | string | null
    access?: StringWithAggregatesFilter<"File"> | string
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    commentId?: StringNullableWithAggregatesFilter<"File"> | string | null
  }

  export type SettingOptionWhereInput = {
    AND?: SettingOptionWhereInput | SettingOptionWhereInput[]
    OR?: SettingOptionWhereInput[]
    NOT?: SettingOptionWhereInput | SettingOptionWhereInput[]
    id?: StringFilter<"SettingOption"> | string
    category?: StringFilter<"SettingOption"> | string
    label?: StringFilter<"SettingOption"> | string
    value?: StringFilter<"SettingOption"> | string
    position?: IntFilter<"SettingOption"> | number
    createdAt?: DateTimeFilter<"SettingOption"> | Date | string
  }

  export type SettingOptionOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    label?: SortOrder
    value?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type SettingOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettingOptionWhereInput | SettingOptionWhereInput[]
    OR?: SettingOptionWhereInput[]
    NOT?: SettingOptionWhereInput | SettingOptionWhereInput[]
    category?: StringFilter<"SettingOption"> | string
    label?: StringFilter<"SettingOption"> | string
    value?: StringFilter<"SettingOption"> | string
    position?: IntFilter<"SettingOption"> | number
    createdAt?: DateTimeFilter<"SettingOption"> | Date | string
  }, "id">

  export type SettingOptionOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    label?: SortOrder
    value?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    _count?: SettingOptionCountOrderByAggregateInput
    _avg?: SettingOptionAvgOrderByAggregateInput
    _max?: SettingOptionMaxOrderByAggregateInput
    _min?: SettingOptionMinOrderByAggregateInput
    _sum?: SettingOptionSumOrderByAggregateInput
  }

  export type SettingOptionScalarWhereWithAggregatesInput = {
    AND?: SettingOptionScalarWhereWithAggregatesInput | SettingOptionScalarWhereWithAggregatesInput[]
    OR?: SettingOptionScalarWhereWithAggregatesInput[]
    NOT?: SettingOptionScalarWhereWithAggregatesInput | SettingOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SettingOption"> | string
    category?: StringWithAggregatesFilter<"SettingOption"> | string
    label?: StringWithAggregatesFilter<"SettingOption"> | string
    value?: StringWithAggregatesFilter<"SettingOption"> | string
    position?: IntWithAggregatesFilter<"SettingOption"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SettingOption"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: StringFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringFilter<"SystemSetting"> | string
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSetting"> | string
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type DealTagWhereInput = {
    AND?: DealTagWhereInput | DealTagWhereInput[]
    OR?: DealTagWhereInput[]
    NOT?: DealTagWhereInput | DealTagWhereInput[]
    dealId?: StringFilter<"DealTag"> | string
    tagId?: StringFilter<"DealTag"> | string
    deal?: XOR<DealScalarRelationFilter, DealWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type DealTagOrderByWithRelationInput = {
    dealId?: SortOrder
    tagId?: SortOrder
    deal?: DealOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type DealTagWhereUniqueInput = Prisma.AtLeast<{
    dealId_tagId?: DealTagDealIdTagIdCompoundUniqueInput
    AND?: DealTagWhereInput | DealTagWhereInput[]
    OR?: DealTagWhereInput[]
    NOT?: DealTagWhereInput | DealTagWhereInput[]
    dealId?: StringFilter<"DealTag"> | string
    tagId?: StringFilter<"DealTag"> | string
    deal?: XOR<DealScalarRelationFilter, DealWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "dealId_tagId">

  export type DealTagOrderByWithAggregationInput = {
    dealId?: SortOrder
    tagId?: SortOrder
    _count?: DealTagCountOrderByAggregateInput
    _max?: DealTagMaxOrderByAggregateInput
    _min?: DealTagMinOrderByAggregateInput
  }

  export type DealTagScalarWhereWithAggregatesInput = {
    AND?: DealTagScalarWhereWithAggregatesInput | DealTagScalarWhereWithAggregatesInput[]
    OR?: DealTagScalarWhereWithAggregatesInput[]
    NOT?: DealTagScalarWhereWithAggregatesInput | DealTagScalarWhereWithAggregatesInput[]
    dealId?: StringWithAggregatesFilter<"DealTag"> | string
    tagId?: StringWithAggregatesFilter<"DealTag"> | string
  }

  export type ContactTagWhereInput = {
    AND?: ContactTagWhereInput | ContactTagWhereInput[]
    OR?: ContactTagWhereInput[]
    NOT?: ContactTagWhereInput | ContactTagWhereInput[]
    contactId?: StringFilter<"ContactTag"> | string
    tagId?: StringFilter<"ContactTag"> | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type ContactTagOrderByWithRelationInput = {
    contactId?: SortOrder
    tagId?: SortOrder
    contact?: ContactOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type ContactTagWhereUniqueInput = Prisma.AtLeast<{
    contactId_tagId?: ContactTagContactIdTagIdCompoundUniqueInput
    AND?: ContactTagWhereInput | ContactTagWhereInput[]
    OR?: ContactTagWhereInput[]
    NOT?: ContactTagWhereInput | ContactTagWhereInput[]
    contactId?: StringFilter<"ContactTag"> | string
    tagId?: StringFilter<"ContactTag"> | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "contactId_tagId">

  export type ContactTagOrderByWithAggregationInput = {
    contactId?: SortOrder
    tagId?: SortOrder
    _count?: ContactTagCountOrderByAggregateInput
    _max?: ContactTagMaxOrderByAggregateInput
    _min?: ContactTagMinOrderByAggregateInput
  }

  export type ContactTagScalarWhereWithAggregatesInput = {
    AND?: ContactTagScalarWhereWithAggregatesInput | ContactTagScalarWhereWithAggregatesInput[]
    OR?: ContactTagScalarWhereWithAggregatesInput[]
    NOT?: ContactTagScalarWhereWithAggregatesInput | ContactTagScalarWhereWithAggregatesInput[]
    contactId?: StringWithAggregatesFilter<"ContactTag"> | string
    tagId?: StringWithAggregatesFilter<"ContactTag"> | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    label?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    DealTags?: DealTagListRelationFilter
    ContactTags?: ContactTagListRelationFilter
    activities?: ActivityListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    DealTags?: DealTagOrderByRelationAggregateInput
    ContactTags?: ContactTagOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    label?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    DealTags?: DealTagListRelationFilter
    ContactTags?: ContactTagListRelationFilter
    activities?: ActivityListRelationFilter
  }, "id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    label?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringWithAggregatesFilter<"Tag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    id?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    event?: StringFilter<"Webhook"> | string
    enabled?: BoolFilter<"Webhook"> | boolean
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
  }

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    event?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    url?: StringFilter<"Webhook"> | string
    event?: StringFilter<"Webhook"> | string
    enabled?: BoolFilter<"Webhook"> | boolean
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
  }, "id">

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    event?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    _count?: WebhookCountOrderByAggregateInput
    _max?: WebhookMaxOrderByAggregateInput
    _min?: WebhookMinOrderByAggregateInput
  }

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    OR?: WebhookScalarWhereWithAggregatesInput[]
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Webhook"> | string
    url?: StringWithAggregatesFilter<"Webhook"> | string
    event?: StringWithAggregatesFilter<"Webhook"> | string
    enabled?: BoolWithAggregatesFilter<"Webhook"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
  }

  export type SharedAccessWhereInput = {
    AND?: SharedAccessWhereInput | SharedAccessWhereInput[]
    OR?: SharedAccessWhereInput[]
    NOT?: SharedAccessWhereInput | SharedAccessWhereInput[]
    id?: StringFilter<"SharedAccess"> | string
    userId?: StringFilter<"SharedAccess"> | string
    entityId?: StringFilter<"SharedAccess"> | string
    entity?: StringFilter<"SharedAccess"> | string
    canEdit?: BoolFilter<"SharedAccess"> | boolean
    createdAt?: DateTimeFilter<"SharedAccess"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SharedAccessOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    entity?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SharedAccessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_entityId_entity?: SharedAccessUserIdEntityIdEntityCompoundUniqueInput
    AND?: SharedAccessWhereInput | SharedAccessWhereInput[]
    OR?: SharedAccessWhereInput[]
    NOT?: SharedAccessWhereInput | SharedAccessWhereInput[]
    userId?: StringFilter<"SharedAccess"> | string
    entityId?: StringFilter<"SharedAccess"> | string
    entity?: StringFilter<"SharedAccess"> | string
    canEdit?: BoolFilter<"SharedAccess"> | boolean
    createdAt?: DateTimeFilter<"SharedAccess"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_entityId_entity">

  export type SharedAccessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    entity?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
    _count?: SharedAccessCountOrderByAggregateInput
    _max?: SharedAccessMaxOrderByAggregateInput
    _min?: SharedAccessMinOrderByAggregateInput
  }

  export type SharedAccessScalarWhereWithAggregatesInput = {
    AND?: SharedAccessScalarWhereWithAggregatesInput | SharedAccessScalarWhereWithAggregatesInput[]
    OR?: SharedAccessScalarWhereWithAggregatesInput[]
    NOT?: SharedAccessScalarWhereWithAggregatesInput | SharedAccessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SharedAccess"> | string
    userId?: StringWithAggregatesFilter<"SharedAccess"> | string
    entityId?: StringWithAggregatesFilter<"SharedAccess"> | string
    entity?: StringWithAggregatesFilter<"SharedAccess"> | string
    canEdit?: BoolWithAggregatesFilter<"SharedAccess"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SharedAccess"> | Date | string
  }

  export type AutomationRuleWhereInput = {
    AND?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    OR?: AutomationRuleWhereInput[]
    NOT?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    id?: StringFilter<"AutomationRule"> | string
    name?: StringFilter<"AutomationRule"> | string
    entity?: StringFilter<"AutomationRule"> | string
    trigger?: StringFilter<"AutomationRule"> | string
    field?: StringNullableFilter<"AutomationRule"> | string | null
    condition?: JsonFilter<"AutomationRule">
    action?: JsonFilter<"AutomationRule">
    enabled?: BoolFilter<"AutomationRule"> | boolean
    createdAt?: DateTimeFilter<"AutomationRule"> | Date | string
  }

  export type AutomationRuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    entity?: SortOrder
    trigger?: SortOrder
    field?: SortOrderInput | SortOrder
    condition?: SortOrder
    action?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
  }

  export type AutomationRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    OR?: AutomationRuleWhereInput[]
    NOT?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    name?: StringFilter<"AutomationRule"> | string
    entity?: StringFilter<"AutomationRule"> | string
    trigger?: StringFilter<"AutomationRule"> | string
    field?: StringNullableFilter<"AutomationRule"> | string | null
    condition?: JsonFilter<"AutomationRule">
    action?: JsonFilter<"AutomationRule">
    enabled?: BoolFilter<"AutomationRule"> | boolean
    createdAt?: DateTimeFilter<"AutomationRule"> | Date | string
  }, "id">

  export type AutomationRuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    entity?: SortOrder
    trigger?: SortOrder
    field?: SortOrderInput | SortOrder
    condition?: SortOrder
    action?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    _count?: AutomationRuleCountOrderByAggregateInput
    _max?: AutomationRuleMaxOrderByAggregateInput
    _min?: AutomationRuleMinOrderByAggregateInput
  }

  export type AutomationRuleScalarWhereWithAggregatesInput = {
    AND?: AutomationRuleScalarWhereWithAggregatesInput | AutomationRuleScalarWhereWithAggregatesInput[]
    OR?: AutomationRuleScalarWhereWithAggregatesInput[]
    NOT?: AutomationRuleScalarWhereWithAggregatesInput | AutomationRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationRule"> | string
    name?: StringWithAggregatesFilter<"AutomationRule"> | string
    entity?: StringWithAggregatesFilter<"AutomationRule"> | string
    trigger?: StringWithAggregatesFilter<"AutomationRule"> | string
    field?: StringNullableWithAggregatesFilter<"AutomationRule"> | string | null
    condition?: JsonWithAggregatesFilter<"AutomationRule">
    action?: JsonWithAggregatesFilter<"AutomationRule">
    enabled?: BoolWithAggregatesFilter<"AutomationRule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AutomationRule"> | Date | string
  }

  export type CustomFieldWhereInput = {
    AND?: CustomFieldWhereInput | CustomFieldWhereInput[]
    OR?: CustomFieldWhereInput[]
    NOT?: CustomFieldWhereInput | CustomFieldWhereInput[]
    id?: StringFilter<"CustomField"> | string
    entity?: StringFilter<"CustomField"> | string
    name?: StringFilter<"CustomField"> | string
    label?: StringFilter<"CustomField"> | string
    type?: StringFilter<"CustomField"> | string
    options?: JsonNullableFilter<"CustomField">
    required?: BoolFilter<"CustomField"> | boolean
    createdAt?: DateTimeFilter<"CustomField"> | Date | string
    values?: CustomFieldValueListRelationFilter
  }

  export type CustomFieldOrderByWithRelationInput = {
    id?: SortOrder
    entity?: SortOrder
    name?: SortOrder
    label?: SortOrder
    type?: SortOrder
    options?: SortOrderInput | SortOrder
    required?: SortOrder
    createdAt?: SortOrder
    values?: CustomFieldValueOrderByRelationAggregateInput
  }

  export type CustomFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomFieldWhereInput | CustomFieldWhereInput[]
    OR?: CustomFieldWhereInput[]
    NOT?: CustomFieldWhereInput | CustomFieldWhereInput[]
    entity?: StringFilter<"CustomField"> | string
    name?: StringFilter<"CustomField"> | string
    label?: StringFilter<"CustomField"> | string
    type?: StringFilter<"CustomField"> | string
    options?: JsonNullableFilter<"CustomField">
    required?: BoolFilter<"CustomField"> | boolean
    createdAt?: DateTimeFilter<"CustomField"> | Date | string
    values?: CustomFieldValueListRelationFilter
  }, "id">

  export type CustomFieldOrderByWithAggregationInput = {
    id?: SortOrder
    entity?: SortOrder
    name?: SortOrder
    label?: SortOrder
    type?: SortOrder
    options?: SortOrderInput | SortOrder
    required?: SortOrder
    createdAt?: SortOrder
    _count?: CustomFieldCountOrderByAggregateInput
    _max?: CustomFieldMaxOrderByAggregateInput
    _min?: CustomFieldMinOrderByAggregateInput
  }

  export type CustomFieldScalarWhereWithAggregatesInput = {
    AND?: CustomFieldScalarWhereWithAggregatesInput | CustomFieldScalarWhereWithAggregatesInput[]
    OR?: CustomFieldScalarWhereWithAggregatesInput[]
    NOT?: CustomFieldScalarWhereWithAggregatesInput | CustomFieldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomField"> | string
    entity?: StringWithAggregatesFilter<"CustomField"> | string
    name?: StringWithAggregatesFilter<"CustomField"> | string
    label?: StringWithAggregatesFilter<"CustomField"> | string
    type?: StringWithAggregatesFilter<"CustomField"> | string
    options?: JsonNullableWithAggregatesFilter<"CustomField">
    required?: BoolWithAggregatesFilter<"CustomField"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomField"> | Date | string
  }

  export type CustomFieldValueWhereInput = {
    AND?: CustomFieldValueWhereInput | CustomFieldValueWhereInput[]
    OR?: CustomFieldValueWhereInput[]
    NOT?: CustomFieldValueWhereInput | CustomFieldValueWhereInput[]
    id?: StringFilter<"CustomFieldValue"> | string
    fieldId?: StringFilter<"CustomFieldValue"> | string
    entity?: StringFilter<"CustomFieldValue"> | string
    entityId?: StringFilter<"CustomFieldValue"> | string
    value?: StringFilter<"CustomFieldValue"> | string
    createdAt?: DateTimeFilter<"CustomFieldValue"> | Date | string
    field?: XOR<CustomFieldScalarRelationFilter, CustomFieldWhereInput>
  }

  export type CustomFieldValueOrderByWithRelationInput = {
    id?: SortOrder
    fieldId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    field?: CustomFieldOrderByWithRelationInput
  }

  export type CustomFieldValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomFieldValueWhereInput | CustomFieldValueWhereInput[]
    OR?: CustomFieldValueWhereInput[]
    NOT?: CustomFieldValueWhereInput | CustomFieldValueWhereInput[]
    fieldId?: StringFilter<"CustomFieldValue"> | string
    entity?: StringFilter<"CustomFieldValue"> | string
    entityId?: StringFilter<"CustomFieldValue"> | string
    value?: StringFilter<"CustomFieldValue"> | string
    createdAt?: DateTimeFilter<"CustomFieldValue"> | Date | string
    field?: XOR<CustomFieldScalarRelationFilter, CustomFieldWhereInput>
  }, "id">

  export type CustomFieldValueOrderByWithAggregationInput = {
    id?: SortOrder
    fieldId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    _count?: CustomFieldValueCountOrderByAggregateInput
    _max?: CustomFieldValueMaxOrderByAggregateInput
    _min?: CustomFieldValueMinOrderByAggregateInput
  }

  export type CustomFieldValueScalarWhereWithAggregatesInput = {
    AND?: CustomFieldValueScalarWhereWithAggregatesInput | CustomFieldValueScalarWhereWithAggregatesInput[]
    OR?: CustomFieldValueScalarWhereWithAggregatesInput[]
    NOT?: CustomFieldValueScalarWhereWithAggregatesInput | CustomFieldValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomFieldValue"> | string
    fieldId?: StringWithAggregatesFilter<"CustomFieldValue"> | string
    entity?: StringWithAggregatesFilter<"CustomFieldValue"> | string
    entityId?: StringWithAggregatesFilter<"CustomFieldValue"> | string
    value?: StringWithAggregatesFilter<"CustomFieldValue"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomFieldValue"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    changes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    changes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    entity?: StringFilter<"Comment"> | string
    entityId?: StringFilter<"Comment"> | string
    text?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    mentions?: StringNullableListFilter<"Comment">
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    files?: FileListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    mentions?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    files?: FileOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    entity?: StringFilter<"Comment"> | string
    entityId?: StringFilter<"Comment"> | string
    text?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    mentions?: StringNullableListFilter<"Comment">
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    files?: FileListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    mentions?: SortOrder
    createdAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    entity?: StringWithAggregatesFilter<"Comment"> | string
    entityId?: StringWithAggregatesFilter<"Comment"> | string
    text?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    mentions?: StringNullableListFilter<"Comment">
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    users?: UserCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id?: string
    name: string
    industry?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutAccountInput
    Contact?: ContactCreateNestedManyWithoutAccountInput
    Deal?: DealCreateNestedManyWithoutAccountInput
    Activity?: ActivityCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    name: string
    industry?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    ownerId: string
    createdAt?: Date | string
    Contact?: ContactUncheckedCreateNestedManyWithoutAccountInput
    Deal?: DealUncheckedCreateNestedManyWithoutAccountInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutAccountNestedInput
    Contact?: ContactUpdateManyWithoutAccountNestedInput
    Deal?: DealUpdateManyWithoutAccountNestedInput
    Activity?: ActivityUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    Deal?: DealUncheckedUpdateManyWithoutAccountNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    name: string
    industry?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    ownerId: string
    createdAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutContactInput
    account?: AccountCreateNestedOneWithoutContactInput
    Deal?: DealCreateNestedManyWithoutContactInput
    Activity?: ActivityCreateNestedManyWithoutContactInput
    ContactTag?: ContactTagCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    ownerId: string
    accountId?: string | null
    createdAt?: Date | string
    Deal?: DealUncheckedCreateNestedManyWithoutContactInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutContactInput
    ContactTag?: ContactTagUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutContactNestedInput
    account?: AccountUpdateOneWithoutContactNestedInput
    Deal?: DealUpdateManyWithoutContactNestedInput
    Activity?: ActivityUpdateManyWithoutContactNestedInput
    ContactTag?: ContactTagUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Deal?: DealUncheckedUpdateManyWithoutContactNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutContactNestedInput
    ContactTag?: ContactTagUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    ownerId: string
    accountId?: string | null
    createdAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealCreateInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    createdAt?: Date | string
    account?: AccountCreateNestedOneWithoutDealInput
    contact?: ContactCreateNestedOneWithoutDealInput
    owner: UserCreateNestedOneWithoutDealInput
    Activity?: ActivityCreateNestedManyWithoutDealInput
    DealTag?: DealTagCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    accountId?: string | null
    contactId?: string | null
    ownerId: string
    createdAt?: Date | string
    Activity?: ActivityUncheckedCreateNestedManyWithoutDealInput
    DealTag?: DealTagUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutDealNestedInput
    contact?: ContactUpdateOneWithoutDealNestedInput
    owner?: UserUpdateOneRequiredWithoutDealNestedInput
    Activity?: ActivityUpdateManyWithoutDealNestedInput
    DealTag?: DealTagUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Activity?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    DealTag?: DealTagUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealCreateManyInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    accountId?: string | null
    contactId?: string | null
    ownerId: string
    createdAt?: Date | string
  }

  export type DealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutActivityInput
    account?: AccountCreateNestedOneWithoutActivityInput
    contact?: ContactCreateNestedOneWithoutActivityInput
    deal?: DealCreateNestedOneWithoutActivityInput
    parent?: ActivityCreateNestedOneWithoutSubtasksInput
    subtasks?: ActivityCreateNestedManyWithoutParentInput
    tags?: TagCreateNestedManyWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    ownerId: string
    accountId?: string | null
    contactId?: string | null
    dealId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    subtasks?: ActivityUncheckedCreateNestedManyWithoutParentInput
    tags?: TagUncheckedCreateNestedManyWithoutActivitiesInput
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutActivityNestedInput
    account?: AccountUpdateOneWithoutActivityNestedInput
    contact?: ContactUpdateOneWithoutActivityNestedInput
    deal?: DealUpdateOneWithoutActivityNestedInput
    parent?: ActivityUpdateOneWithoutSubtasksNestedInput
    subtasks?: ActivityUpdateManyWithoutParentNestedInput
    tags?: TagUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtasks?: ActivityUncheckedUpdateManyWithoutParentNestedInput
    tags?: TagUncheckedUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivityCreateManyInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    ownerId: string
    accountId?: string | null
    contactId?: string | null
    dealId?: string | null
    parentId?: string | null
    createdAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAccountCreateInput = {
    id?: string
    smtpHost: string
    smtpPort: number
    smtpSecure: boolean
    email: string
    password: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailAccountInput
  }

  export type EmailAccountUncheckedCreateInput = {
    id?: string
    userId: string
    smtpHost: string
    smtpPort: number
    smtpSecure: boolean
    email: string
    password: string
    createdAt?: Date | string
  }

  export type EmailAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    smtpHost?: StringFieldUpdateOperationsInput | string
    smtpPort?: IntFieldUpdateOperationsInput | number
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailAccountNestedInput
  }

  export type EmailAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    smtpHost?: StringFieldUpdateOperationsInput | string
    smtpPort?: IntFieldUpdateOperationsInput | number
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAccountCreateManyInput = {
    id?: string
    userId: string
    smtpHost: string
    smtpPort: number
    smtpSecure: boolean
    email: string
    password: string
    createdAt?: Date | string
  }

  export type EmailAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    smtpHost?: StringFieldUpdateOperationsInput | string
    smtpPort?: IntFieldUpdateOperationsInput | number
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    smtpHost?: StringFieldUpdateOperationsInput | string
    smtpPort?: IntFieldUpdateOperationsInput | number
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateInput = {
    id?: string
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailTemplateInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    body: string
    userId: string
    createdAt?: Date | string
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailTemplateNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateCreateManyInput = {
    id?: string
    name: string
    subject: string
    body: string
    userId: string
    createdAt?: Date | string
  }

  export type EmailTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageCreateInput = {
    id?: string
    subject: string
    to: string
    body: string
    status: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailMessageInput
    template?: EmailTemplateCreateNestedOneWithoutEmailMessageInput
  }

  export type EmailMessageUncheckedCreateInput = {
    id?: string
    subject: string
    to: string
    body: string
    status: string
    userId: string
    templateId?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailMessageNestedInput
    template?: EmailTemplateUpdateOneWithoutEmailMessageNestedInput
  }

  export type EmailMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageCreateManyInput = {
    id?: string
    subject: string
    to: string
    body: string
    status: string
    userId: string
    templateId?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailInboxMessageCreateInput = {
    id?: string
    from: string
    to: string
    subject: string
    text?: string | null
    html?: string | null
    date: Date | string
    folder: string
    messageId: string
    seen?: boolean
    flagged?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailInboxMessageInput
  }

  export type EmailInboxMessageUncheckedCreateInput = {
    id?: string
    userId: string
    from: string
    to: string
    subject: string
    text?: string | null
    html?: string | null
    date: Date | string
    folder: string
    messageId: string
    seen?: boolean
    flagged?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailInboxMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailInboxMessageNestedInput
  }

  export type EmailInboxMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailInboxMessageCreateManyInput = {
    id?: string
    userId: string
    from: string
    to: string
    subject: string
    text?: string | null
    html?: string | null
    date: Date | string
    folder: string
    messageId: string
    seen?: boolean
    flagged?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailInboxMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailInboxMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactCreateInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    company?: string | null
    notes?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailContactInput
  }

  export type EmailContactUncheckedCreateInput = {
    id?: string
    userId: string
    email: string
    name?: string | null
    phone?: string | null
    company?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type EmailContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailContactNestedInput
  }

  export type EmailContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactCreateManyInput = {
    id?: string
    userId: string
    email: string
    name?: string | null
    phone?: string | null
    company?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type EmailContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentTemplateCreateInput = {
    id?: string
    name: string
    content: string
    format: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentTemplateInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutTemplateInput
  }

  export type DocumentTemplateUncheckedCreateInput = {
    id?: string
    name: string
    content: string
    format: string
    userId: string
    createdAt?: Date | string
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type DocumentTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentTemplateNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutTemplateNestedInput
  }

  export type DocumentTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type DocumentTemplateCreateManyInput = {
    id?: string
    name: string
    content: string
    format: string
    userId: string
    createdAt?: Date | string
  }

  export type DocumentTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedDocumentCreateInput = {
    id?: string
    filePath: string
    format: string
    createdAt?: Date | string
    template: DocumentTemplateCreateNestedOneWithoutGeneratedDocumentInput
    user: UserCreateNestedOneWithoutGeneratedDocumentInput
  }

  export type GeneratedDocumentUncheckedCreateInput = {
    id?: string
    filePath: string
    format: string
    templateId: string
    userId: string
    createdAt?: Date | string
  }

  export type GeneratedDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: DocumentTemplateUpdateOneRequiredWithoutGeneratedDocumentNestedInput
    user?: UserUpdateOneRequiredWithoutGeneratedDocumentNestedInput
  }

  export type GeneratedDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedDocumentCreateManyInput = {
    id?: string
    filePath: string
    format: string
    templateId: string
    userId: string
    createdAt?: Date | string
  }

  export type GeneratedDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileFolderCreateInput = {
    id?: string
    name: string
    parentId?: string | null
    access: string
    createdAt?: Date | string
    accountId?: string | null
    dealId?: string | null
    user: UserCreateNestedOneWithoutFileFolderInput
    files?: FileCreateNestedManyWithoutFolderInput
  }

  export type FileFolderUncheckedCreateInput = {
    id?: string
    name: string
    parentId?: string | null
    userId: string
    access: string
    createdAt?: Date | string
    accountId?: string | null
    dealId?: string | null
    files?: FileUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FileFolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutFileFolderNestedInput
    files?: FileUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderCreateManyInput = {
    id?: string
    name: string
    parentId?: string | null
    userId: string
    access: string
    createdAt?: Date | string
    accountId?: string | null
    dealId?: string | null
  }

  export type FileFolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileFolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileCreateInput = {
    id?: string
    name: string
    path: string
    size: number
    mimeType: string
    dealId?: string | null
    contactId?: string | null
    taskId?: string | null
    publicLink?: string | null
    expiresAt?: Date | string | null
    access: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFileInput
    folder?: FileFolderCreateNestedOneWithoutFilesInput
    comment?: CommentCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    name: string
    path: string
    size: number
    mimeType: string
    userId: string
    folderId?: string | null
    dealId?: string | null
    contactId?: string | null
    taskId?: string | null
    publicLink?: string | null
    expiresAt?: Date | string | null
    access: string
    createdAt?: Date | string
    commentId?: string | null
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    publicLink?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFileNestedInput
    folder?: FileFolderUpdateOneWithoutFilesNestedInput
    comment?: CommentUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    publicLink?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileCreateManyInput = {
    id?: string
    name: string
    path: string
    size: number
    mimeType: string
    userId: string
    folderId?: string | null
    dealId?: string | null
    contactId?: string | null
    taskId?: string | null
    publicLink?: string | null
    expiresAt?: Date | string | null
    access: string
    createdAt?: Date | string
    commentId?: string | null
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    publicLink?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    publicLink?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingOptionCreateInput = {
    id?: string
    category: string
    label: string
    value: string
    position?: number
    createdAt?: Date | string
  }

  export type SettingOptionUncheckedCreateInput = {
    id?: string
    category: string
    label: string
    value: string
    position?: number
    createdAt?: Date | string
  }

  export type SettingOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingOptionCreateManyInput = {
    id?: string
    category: string
    label: string
    value: string
    position?: number
    createdAt?: Date | string
  }

  export type SettingOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    id?: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    id?: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealTagCreateInput = {
    deal: DealCreateNestedOneWithoutDealTagInput
    tag: TagCreateNestedOneWithoutDealTagsInput
  }

  export type DealTagUncheckedCreateInput = {
    dealId: string
    tagId: string
  }

  export type DealTagUpdateInput = {
    deal?: DealUpdateOneRequiredWithoutDealTagNestedInput
    tag?: TagUpdateOneRequiredWithoutDealTagsNestedInput
  }

  export type DealTagUncheckedUpdateInput = {
    dealId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type DealTagCreateManyInput = {
    dealId: string
    tagId: string
  }

  export type DealTagUpdateManyMutationInput = {

  }

  export type DealTagUncheckedUpdateManyInput = {
    dealId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagCreateInput = {
    contact: ContactCreateNestedOneWithoutContactTagInput
    tag: TagCreateNestedOneWithoutContactTagsInput
  }

  export type ContactTagUncheckedCreateInput = {
    contactId: string
    tagId: string
  }

  export type ContactTagUpdateInput = {
    contact?: ContactUpdateOneRequiredWithoutContactTagNestedInput
    tag?: TagUpdateOneRequiredWithoutContactTagsNestedInput
  }

  export type ContactTagUncheckedUpdateInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagCreateManyInput = {
    contactId: string
    tagId: string
  }

  export type ContactTagUpdateManyMutationInput = {

  }

  export type ContactTagUncheckedUpdateManyInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type TagCreateInput = {
    id?: string
    label: string
    color: string
    createdAt?: Date | string
    DealTags?: DealTagCreateNestedManyWithoutTagInput
    ContactTags?: ContactTagCreateNestedManyWithoutTagInput
    activities?: ActivityCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    label: string
    color: string
    createdAt?: Date | string
    DealTags?: DealTagUncheckedCreateNestedManyWithoutTagInput
    ContactTags?: ContactTagUncheckedCreateNestedManyWithoutTagInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DealTags?: DealTagUpdateManyWithoutTagNestedInput
    ContactTags?: ContactTagUpdateManyWithoutTagNestedInput
    activities?: ActivityUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DealTags?: DealTagUncheckedUpdateManyWithoutTagNestedInput
    ContactTags?: ContactTagUncheckedUpdateManyWithoutTagNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    label: string
    color: string
    createdAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookCreateInput = {
    id?: string
    url: string
    event: string
    enabled?: boolean
    createdAt?: Date | string
  }

  export type WebhookUncheckedCreateInput = {
    id?: string
    url: string
    event: string
    enabled?: boolean
    createdAt?: Date | string
  }

  export type WebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookCreateManyInput = {
    id?: string
    url: string
    event: string
    enabled?: boolean
    createdAt?: Date | string
  }

  export type WebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedAccessCreateInput = {
    id?: string
    entityId: string
    entity: string
    canEdit?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSharedAccessInput
  }

  export type SharedAccessUncheckedCreateInput = {
    id?: string
    userId: string
    entityId: string
    entity: string
    canEdit?: boolean
    createdAt?: Date | string
  }

  export type SharedAccessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSharedAccessNestedInput
  }

  export type SharedAccessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedAccessCreateManyInput = {
    id?: string
    userId: string
    entityId: string
    entity: string
    canEdit?: boolean
    createdAt?: Date | string
  }

  export type SharedAccessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedAccessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationRuleCreateInput = {
    id?: string
    name: string
    entity: string
    trigger: string
    field?: string | null
    condition: JsonNullValueInput | InputJsonValue
    action: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
  }

  export type AutomationRuleUncheckedCreateInput = {
    id?: string
    name: string
    entity: string
    trigger: string
    field?: string | null
    condition: JsonNullValueInput | InputJsonValue
    action: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
  }

  export type AutomationRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    field?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: JsonNullValueInput | InputJsonValue
    action?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    field?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: JsonNullValueInput | InputJsonValue
    action?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationRuleCreateManyInput = {
    id?: string
    name: string
    entity: string
    trigger: string
    field?: string | null
    condition: JsonNullValueInput | InputJsonValue
    action: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
  }

  export type AutomationRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    field?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: JsonNullValueInput | InputJsonValue
    action?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    field?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: JsonNullValueInput | InputJsonValue
    action?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldCreateInput = {
    id?: string
    entity: string
    name: string
    label: string
    type: string
    options?: NullableJsonNullValueInput | InputJsonValue
    required?: boolean
    createdAt?: Date | string
    values?: CustomFieldValueCreateNestedManyWithoutFieldInput
  }

  export type CustomFieldUncheckedCreateInput = {
    id?: string
    entity: string
    name: string
    label: string
    type: string
    options?: NullableJsonNullValueInput | InputJsonValue
    required?: boolean
    createdAt?: Date | string
    values?: CustomFieldValueUncheckedCreateNestedManyWithoutFieldInput
  }

  export type CustomFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    required?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: CustomFieldValueUpdateManyWithoutFieldNestedInput
  }

  export type CustomFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    required?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: CustomFieldValueUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type CustomFieldCreateManyInput = {
    id?: string
    entity: string
    name: string
    label: string
    type: string
    options?: NullableJsonNullValueInput | InputJsonValue
    required?: boolean
    createdAt?: Date | string
  }

  export type CustomFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    required?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    required?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldValueCreateInput = {
    id?: string
    entity: string
    entityId: string
    value: string
    createdAt?: Date | string
    field: CustomFieldCreateNestedOneWithoutValuesInput
  }

  export type CustomFieldValueUncheckedCreateInput = {
    id?: string
    fieldId: string
    entity: string
    entityId: string
    value: string
    createdAt?: Date | string
  }

  export type CustomFieldValueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: CustomFieldUpdateOneRequiredWithoutValuesNestedInput
  }

  export type CustomFieldValueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldValueCreateManyInput = {
    id?: string
    fieldId: string
    entity: string
    entityId: string
    value: string
    createdAt?: Date | string
  }

  export type CustomFieldValueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldValueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    entity: string
    entityId: string
    userId: string
    action: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    entity: string
    entityId: string
    userId: string
    action: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    entity: string
    entityId: string
    text: string
    mentions?: CommentCreatementionsInput | string[]
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCommentInput
    files?: FileCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    entity: string
    entityId: string
    text: string
    userId: string
    mentions?: CommentCreatementionsInput | string[]
    createdAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    mentions?: CommentUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentNestedInput
    files?: FileUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mentions?: CommentUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    entity: string
    entityId: string
    text: string
    userId: string
    mentions?: CommentCreatementionsInput | string[]
    createdAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    mentions?: CommentUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mentions?: CommentUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type TeamNullableScalarRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type DealListRelationFilter = {
    every?: DealWhereInput
    some?: DealWhereInput
    none?: DealWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type EmailAccountListRelationFilter = {
    every?: EmailAccountWhereInput
    some?: EmailAccountWhereInput
    none?: EmailAccountWhereInput
  }

  export type EmailTemplateListRelationFilter = {
    every?: EmailTemplateWhereInput
    some?: EmailTemplateWhereInput
    none?: EmailTemplateWhereInput
  }

  export type EmailMessageListRelationFilter = {
    every?: EmailMessageWhereInput
    some?: EmailMessageWhereInput
    none?: EmailMessageWhereInput
  }

  export type EmailInboxMessageListRelationFilter = {
    every?: EmailInboxMessageWhereInput
    some?: EmailInboxMessageWhereInput
    none?: EmailInboxMessageWhereInput
  }

  export type EmailContactListRelationFilter = {
    every?: EmailContactWhereInput
    some?: EmailContactWhereInput
    none?: EmailContactWhereInput
  }

  export type DocumentTemplateListRelationFilter = {
    every?: DocumentTemplateWhereInput
    some?: DocumentTemplateWhereInput
    none?: DocumentTemplateWhereInput
  }

  export type GeneratedDocumentListRelationFilter = {
    every?: GeneratedDocumentWhereInput
    some?: GeneratedDocumentWhereInput
    none?: GeneratedDocumentWhereInput
  }

  export type FileFolderListRelationFilter = {
    every?: FileFolderWhereInput
    some?: FileFolderWhereInput
    none?: FileFolderWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type SharedAccessListRelationFilter = {
    every?: SharedAccessWhereInput
    some?: SharedAccessWhereInput
    none?: SharedAccessWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailInboxMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GeneratedDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileFolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SharedAccessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    telegramId?: SortOrder
    notificationsEnabled?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    teamId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    telegramId?: SortOrder
    notificationsEnabled?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    teamId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    telegramId?: SortOrder
    notificationsEnabled?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    teamId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    industry?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    address?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    industry?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    address?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    industry?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    address?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountNullableScalarRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type ContactTagListRelationFilter = {
    every?: ContactTagWhereInput
    some?: ContactTagWhereInput
    none?: ContactTagWhereInput
  }

  export type ContactTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    position?: SortOrder
    ownerId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    position?: SortOrder
    ownerId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    position?: SortOrder
    ownerId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ContactNullableScalarRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type DealTagListRelationFilter = {
    every?: DealTagWhereInput
    some?: DealTagWhereInput
    none?: DealTagWhereInput
  }

  export type DealTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DealCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    stage?: SortOrder
    probability?: SortOrder
    closeDate?: SortOrder
    accountId?: SortOrder
    contactId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
  }

  export type DealAvgOrderByAggregateInput = {
    amount?: SortOrder
    probability?: SortOrder
  }

  export type DealMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    stage?: SortOrder
    probability?: SortOrder
    closeDate?: SortOrder
    accountId?: SortOrder
    contactId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
  }

  export type DealMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    stage?: SortOrder
    probability?: SortOrder
    closeDate?: SortOrder
    accountId?: SortOrder
    contactId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
  }

  export type DealSumOrderByAggregateInput = {
    amount?: SortOrder
    probability?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DealNullableScalarRelationFilter = {
    is?: DealWhereInput | null
    isNot?: DealWhereInput | null
  }

  export type ActivityNullableScalarRelationFilter = {
    is?: ActivityWhereInput | null
    isNot?: ActivityWhereInput | null
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    date?: SortOrder
    ownerId?: SortOrder
    accountId?: SortOrder
    contactId?: SortOrder
    dealId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    date?: SortOrder
    ownerId?: SortOrder
    accountId?: SortOrder
    contactId?: SortOrder
    dealId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    date?: SortOrder
    ownerId?: SortOrder
    accountId?: SortOrder
    contactId?: SortOrder
    dealId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpSecure?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAccountAvgOrderByAggregateInput = {
    smtpPort?: SortOrder
  }

  export type EmailAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpSecure?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpSecure?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAccountSumOrderByAggregateInput = {
    smtpPort?: SortOrder
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EmailTemplateNullableScalarRelationFilter = {
    is?: EmailTemplateWhereInput | null
    isNot?: EmailTemplateWhereInput | null
  }

  export type EmailMessageCountOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    to?: SortOrder
    body?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    templateId?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    to?: SortOrder
    body?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailMessageMinOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    to?: SortOrder
    body?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EmailInboxMessageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    from?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    html?: SortOrder
    date?: SortOrder
    folder?: SortOrder
    messageId?: SortOrder
    seen?: SortOrder
    flagged?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailInboxMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    from?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    html?: SortOrder
    date?: SortOrder
    folder?: SortOrder
    messageId?: SortOrder
    seen?: SortOrder
    flagged?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailInboxMessageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    from?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    html?: SortOrder
    date?: SortOrder
    folder?: SortOrder
    messageId?: SortOrder
    seen?: SortOrder
    flagged?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailContactUserIdEmailCompoundUniqueInput = {
    userId: string
    email: string
  }

  export type EmailContactCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailContactMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailContactMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    format?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    format?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    format?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentTemplateScalarRelationFilter = {
    is?: DocumentTemplateWhereInput
    isNot?: DocumentTemplateWhereInput
  }

  export type GeneratedDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    filePath?: SortOrder
    format?: SortOrder
    templateId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    filePath?: SortOrder
    format?: SortOrder
    templateId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    filePath?: SortOrder
    format?: SortOrder
    templateId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type FileFolderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    dealId?: SortOrder
  }

  export type FileFolderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    dealId?: SortOrder
  }

  export type FileFolderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    dealId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FileFolderNullableScalarRelationFilter = {
    is?: FileFolderWhereInput | null
    isNot?: FileFolderWhereInput | null
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    userId?: SortOrder
    folderId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    taskId?: SortOrder
    publicLink?: SortOrder
    expiresAt?: SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    userId?: SortOrder
    folderId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    taskId?: SortOrder
    publicLink?: SortOrder
    expiresAt?: SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    userId?: SortOrder
    folderId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    taskId?: SortOrder
    publicLink?: SortOrder
    expiresAt?: SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type SettingOptionCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    label?: SortOrder
    value?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type SettingOptionAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type SettingOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    label?: SortOrder
    value?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type SettingOptionMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    label?: SortOrder
    value?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type SettingOptionSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealScalarRelationFilter = {
    is?: DealWhereInput
    isNot?: DealWhereInput
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type DealTagDealIdTagIdCompoundUniqueInput = {
    dealId: string
    tagId: string
  }

  export type DealTagCountOrderByAggregateInput = {
    dealId?: SortOrder
    tagId?: SortOrder
  }

  export type DealTagMaxOrderByAggregateInput = {
    dealId?: SortOrder
    tagId?: SortOrder
  }

  export type DealTagMinOrderByAggregateInput = {
    dealId?: SortOrder
    tagId?: SortOrder
  }

  export type ContactScalarRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type ContactTagContactIdTagIdCompoundUniqueInput = {
    contactId: string
    tagId: string
  }

  export type ContactTagCountOrderByAggregateInput = {
    contactId?: SortOrder
    tagId?: SortOrder
  }

  export type ContactTagMaxOrderByAggregateInput = {
    contactId?: SortOrder
    tagId?: SortOrder
  }

  export type ContactTagMinOrderByAggregateInput = {
    contactId?: SortOrder
    tagId?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    event?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    event?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    event?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
  }

  export type SharedAccessUserIdEntityIdEntityCompoundUniqueInput = {
    userId: string
    entityId: string
    entity: string
  }

  export type SharedAccessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    entity?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
  }

  export type SharedAccessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    entity?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
  }

  export type SharedAccessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    entity?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AutomationRuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    entity?: SortOrder
    trigger?: SortOrder
    field?: SortOrder
    condition?: SortOrder
    action?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
  }

  export type AutomationRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    entity?: SortOrder
    trigger?: SortOrder
    field?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
  }

  export type AutomationRuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    entity?: SortOrder
    trigger?: SortOrder
    field?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type CustomFieldValueListRelationFilter = {
    every?: CustomFieldValueWhereInput
    some?: CustomFieldValueWhereInput
    none?: CustomFieldValueWhereInput
  }

  export type CustomFieldValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomFieldCountOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    name?: SortOrder
    label?: SortOrder
    type?: SortOrder
    options?: SortOrder
    required?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    name?: SortOrder
    label?: SortOrder
    type?: SortOrder
    required?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomFieldMinOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    name?: SortOrder
    label?: SortOrder
    type?: SortOrder
    required?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomFieldScalarRelationFilter = {
    is?: CustomFieldWhereInput
    isNot?: CustomFieldWhereInput
  }

  export type CustomFieldValueCountOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomFieldValueMaxOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomFieldValueMinOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    changes?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    mentions?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutUsersInput = {
    create?: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutUsersInput
    connect?: TeamWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutOwnerInput = {
    create?: XOR<AccountCreateWithoutOwnerInput, AccountUncheckedCreateWithoutOwnerInput> | AccountCreateWithoutOwnerInput[] | AccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutOwnerInput | AccountCreateOrConnectWithoutOwnerInput[]
    createMany?: AccountCreateManyOwnerInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ContactCreateWithoutOwnerInput, ContactUncheckedCreateWithoutOwnerInput> | ContactCreateWithoutOwnerInput[] | ContactUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutOwnerInput | ContactCreateOrConnectWithoutOwnerInput[]
    createMany?: ContactCreateManyOwnerInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutOwnerInput = {
    create?: XOR<DealCreateWithoutOwnerInput, DealUncheckedCreateWithoutOwnerInput> | DealCreateWithoutOwnerInput[] | DealUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DealCreateOrConnectWithoutOwnerInput | DealCreateOrConnectWithoutOwnerInput[]
    createMany?: DealCreateManyOwnerInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ActivityCreateWithoutOwnerInput, ActivityUncheckedCreateWithoutOwnerInput> | ActivityCreateWithoutOwnerInput[] | ActivityUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOwnerInput | ActivityCreateOrConnectWithoutOwnerInput[]
    createMany?: ActivityCreateManyOwnerInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type EmailAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailAccountCreateWithoutUserInput, EmailAccountUncheckedCreateWithoutUserInput> | EmailAccountCreateWithoutUserInput[] | EmailAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutUserInput | EmailAccountCreateOrConnectWithoutUserInput[]
    createMany?: EmailAccountCreateManyUserInputEnvelope
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
  }

  export type EmailTemplateCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput> | EmailTemplateCreateWithoutUserInput[] | EmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutUserInput | EmailTemplateCreateOrConnectWithoutUserInput[]
    createMany?: EmailTemplateCreateManyUserInputEnvelope
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
  }

  export type EmailMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailMessageCreateWithoutUserInput, EmailMessageUncheckedCreateWithoutUserInput> | EmailMessageCreateWithoutUserInput[] | EmailMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutUserInput | EmailMessageCreateOrConnectWithoutUserInput[]
    createMany?: EmailMessageCreateManyUserInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type EmailInboxMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailInboxMessageCreateWithoutUserInput, EmailInboxMessageUncheckedCreateWithoutUserInput> | EmailInboxMessageCreateWithoutUserInput[] | EmailInboxMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailInboxMessageCreateOrConnectWithoutUserInput | EmailInboxMessageCreateOrConnectWithoutUserInput[]
    createMany?: EmailInboxMessageCreateManyUserInputEnvelope
    connect?: EmailInboxMessageWhereUniqueInput | EmailInboxMessageWhereUniqueInput[]
  }

  export type EmailContactCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailContactCreateWithoutUserInput, EmailContactUncheckedCreateWithoutUserInput> | EmailContactCreateWithoutUserInput[] | EmailContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailContactCreateOrConnectWithoutUserInput | EmailContactCreateOrConnectWithoutUserInput[]
    createMany?: EmailContactCreateManyUserInputEnvelope
    connect?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
  }

  export type DocumentTemplateCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentTemplateCreateWithoutUserInput, DocumentTemplateUncheckedCreateWithoutUserInput> | DocumentTemplateCreateWithoutUserInput[] | DocumentTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentTemplateCreateOrConnectWithoutUserInput | DocumentTemplateCreateOrConnectWithoutUserInput[]
    createMany?: DocumentTemplateCreateManyUserInputEnvelope
    connect?: DocumentTemplateWhereUniqueInput | DocumentTemplateWhereUniqueInput[]
  }

  export type GeneratedDocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<GeneratedDocumentCreateWithoutUserInput, GeneratedDocumentUncheckedCreateWithoutUserInput> | GeneratedDocumentCreateWithoutUserInput[] | GeneratedDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedDocumentCreateOrConnectWithoutUserInput | GeneratedDocumentCreateOrConnectWithoutUserInput[]
    createMany?: GeneratedDocumentCreateManyUserInputEnvelope
    connect?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
  }

  export type FileFolderCreateNestedManyWithoutUserInput = {
    create?: XOR<FileFolderCreateWithoutUserInput, FileFolderUncheckedCreateWithoutUserInput> | FileFolderCreateWithoutUserInput[] | FileFolderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutUserInput | FileFolderCreateOrConnectWithoutUserInput[]
    createMany?: FileFolderCreateManyUserInputEnvelope
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutUserInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type SharedAccessCreateNestedManyWithoutUserInput = {
    create?: XOR<SharedAccessCreateWithoutUserInput, SharedAccessUncheckedCreateWithoutUserInput> | SharedAccessCreateWithoutUserInput[] | SharedAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedAccessCreateOrConnectWithoutUserInput | SharedAccessCreateOrConnectWithoutUserInput[]
    createMany?: SharedAccessCreateManyUserInputEnvelope
    connect?: SharedAccessWhereUniqueInput | SharedAccessWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<AccountCreateWithoutOwnerInput, AccountUncheckedCreateWithoutOwnerInput> | AccountCreateWithoutOwnerInput[] | AccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutOwnerInput | AccountCreateOrConnectWithoutOwnerInput[]
    createMany?: AccountCreateManyOwnerInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ContactCreateWithoutOwnerInput, ContactUncheckedCreateWithoutOwnerInput> | ContactCreateWithoutOwnerInput[] | ContactUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutOwnerInput | ContactCreateOrConnectWithoutOwnerInput[]
    createMany?: ContactCreateManyOwnerInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<DealCreateWithoutOwnerInput, DealUncheckedCreateWithoutOwnerInput> | DealCreateWithoutOwnerInput[] | DealUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DealCreateOrConnectWithoutOwnerInput | DealCreateOrConnectWithoutOwnerInput[]
    createMany?: DealCreateManyOwnerInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ActivityCreateWithoutOwnerInput, ActivityUncheckedCreateWithoutOwnerInput> | ActivityCreateWithoutOwnerInput[] | ActivityUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOwnerInput | ActivityCreateOrConnectWithoutOwnerInput[]
    createMany?: ActivityCreateManyOwnerInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type EmailAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailAccountCreateWithoutUserInput, EmailAccountUncheckedCreateWithoutUserInput> | EmailAccountCreateWithoutUserInput[] | EmailAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutUserInput | EmailAccountCreateOrConnectWithoutUserInput[]
    createMany?: EmailAccountCreateManyUserInputEnvelope
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
  }

  export type EmailTemplateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput> | EmailTemplateCreateWithoutUserInput[] | EmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutUserInput | EmailTemplateCreateOrConnectWithoutUserInput[]
    createMany?: EmailTemplateCreateManyUserInputEnvelope
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
  }

  export type EmailMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailMessageCreateWithoutUserInput, EmailMessageUncheckedCreateWithoutUserInput> | EmailMessageCreateWithoutUserInput[] | EmailMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutUserInput | EmailMessageCreateOrConnectWithoutUserInput[]
    createMany?: EmailMessageCreateManyUserInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailInboxMessageCreateWithoutUserInput, EmailInboxMessageUncheckedCreateWithoutUserInput> | EmailInboxMessageCreateWithoutUserInput[] | EmailInboxMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailInboxMessageCreateOrConnectWithoutUserInput | EmailInboxMessageCreateOrConnectWithoutUserInput[]
    createMany?: EmailInboxMessageCreateManyUserInputEnvelope
    connect?: EmailInboxMessageWhereUniqueInput | EmailInboxMessageWhereUniqueInput[]
  }

  export type EmailContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailContactCreateWithoutUserInput, EmailContactUncheckedCreateWithoutUserInput> | EmailContactCreateWithoutUserInput[] | EmailContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailContactCreateOrConnectWithoutUserInput | EmailContactCreateOrConnectWithoutUserInput[]
    createMany?: EmailContactCreateManyUserInputEnvelope
    connect?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
  }

  export type DocumentTemplateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentTemplateCreateWithoutUserInput, DocumentTemplateUncheckedCreateWithoutUserInput> | DocumentTemplateCreateWithoutUserInput[] | DocumentTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentTemplateCreateOrConnectWithoutUserInput | DocumentTemplateCreateOrConnectWithoutUserInput[]
    createMany?: DocumentTemplateCreateManyUserInputEnvelope
    connect?: DocumentTemplateWhereUniqueInput | DocumentTemplateWhereUniqueInput[]
  }

  export type GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GeneratedDocumentCreateWithoutUserInput, GeneratedDocumentUncheckedCreateWithoutUserInput> | GeneratedDocumentCreateWithoutUserInput[] | GeneratedDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedDocumentCreateOrConnectWithoutUserInput | GeneratedDocumentCreateOrConnectWithoutUserInput[]
    createMany?: GeneratedDocumentCreateManyUserInputEnvelope
    connect?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
  }

  export type FileFolderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FileFolderCreateWithoutUserInput, FileFolderUncheckedCreateWithoutUserInput> | FileFolderCreateWithoutUserInput[] | FileFolderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutUserInput | FileFolderCreateOrConnectWithoutUserInput[]
    createMany?: FileFolderCreateManyUserInputEnvelope
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type SharedAccessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SharedAccessCreateWithoutUserInput, SharedAccessUncheckedCreateWithoutUserInput> | SharedAccessCreateWithoutUserInput[] | SharedAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedAccessCreateOrConnectWithoutUserInput | SharedAccessCreateOrConnectWithoutUserInput[]
    createMany?: SharedAccessCreateManyUserInputEnvelope
    connect?: SharedAccessWhereUniqueInput | SharedAccessWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type TeamUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutUsersInput
    upsert?: TeamUpsertWithoutUsersInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutUsersInput, TeamUpdateWithoutUsersInput>, TeamUncheckedUpdateWithoutUsersInput>
  }

  export type AccountUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<AccountCreateWithoutOwnerInput, AccountUncheckedCreateWithoutOwnerInput> | AccountCreateWithoutOwnerInput[] | AccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutOwnerInput | AccountCreateOrConnectWithoutOwnerInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutOwnerInput | AccountUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: AccountCreateManyOwnerInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutOwnerInput | AccountUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutOwnerInput | AccountUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ContactCreateWithoutOwnerInput, ContactUncheckedCreateWithoutOwnerInput> | ContactCreateWithoutOwnerInput[] | ContactUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutOwnerInput | ContactCreateOrConnectWithoutOwnerInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutOwnerInput | ContactUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ContactCreateManyOwnerInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutOwnerInput | ContactUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutOwnerInput | ContactUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type DealUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<DealCreateWithoutOwnerInput, DealUncheckedCreateWithoutOwnerInput> | DealCreateWithoutOwnerInput[] | DealUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DealCreateOrConnectWithoutOwnerInput | DealCreateOrConnectWithoutOwnerInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutOwnerInput | DealUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: DealCreateManyOwnerInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutOwnerInput | DealUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: DealUpdateManyWithWhereWithoutOwnerInput | DealUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ActivityCreateWithoutOwnerInput, ActivityUncheckedCreateWithoutOwnerInput> | ActivityCreateWithoutOwnerInput[] | ActivityUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOwnerInput | ActivityCreateOrConnectWithoutOwnerInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutOwnerInput | ActivityUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ActivityCreateManyOwnerInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutOwnerInput | ActivityUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutOwnerInput | ActivityUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type EmailAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailAccountCreateWithoutUserInput, EmailAccountUncheckedCreateWithoutUserInput> | EmailAccountCreateWithoutUserInput[] | EmailAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutUserInput | EmailAccountCreateOrConnectWithoutUserInput[]
    upsert?: EmailAccountUpsertWithWhereUniqueWithoutUserInput | EmailAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailAccountCreateManyUserInputEnvelope
    set?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    disconnect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    delete?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    update?: EmailAccountUpdateWithWhereUniqueWithoutUserInput | EmailAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailAccountUpdateManyWithWhereWithoutUserInput | EmailAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
  }

  export type EmailTemplateUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput> | EmailTemplateCreateWithoutUserInput[] | EmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutUserInput | EmailTemplateCreateOrConnectWithoutUserInput[]
    upsert?: EmailTemplateUpsertWithWhereUniqueWithoutUserInput | EmailTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailTemplateCreateManyUserInputEnvelope
    set?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    disconnect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    delete?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    update?: EmailTemplateUpdateWithWhereUniqueWithoutUserInput | EmailTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailTemplateUpdateManyWithWhereWithoutUserInput | EmailTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
  }

  export type EmailMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailMessageCreateWithoutUserInput, EmailMessageUncheckedCreateWithoutUserInput> | EmailMessageCreateWithoutUserInput[] | EmailMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutUserInput | EmailMessageCreateOrConnectWithoutUserInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutUserInput | EmailMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailMessageCreateManyUserInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutUserInput | EmailMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutUserInput | EmailMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type EmailInboxMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailInboxMessageCreateWithoutUserInput, EmailInboxMessageUncheckedCreateWithoutUserInput> | EmailInboxMessageCreateWithoutUserInput[] | EmailInboxMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailInboxMessageCreateOrConnectWithoutUserInput | EmailInboxMessageCreateOrConnectWithoutUserInput[]
    upsert?: EmailInboxMessageUpsertWithWhereUniqueWithoutUserInput | EmailInboxMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailInboxMessageCreateManyUserInputEnvelope
    set?: EmailInboxMessageWhereUniqueInput | EmailInboxMessageWhereUniqueInput[]
    disconnect?: EmailInboxMessageWhereUniqueInput | EmailInboxMessageWhereUniqueInput[]
    delete?: EmailInboxMessageWhereUniqueInput | EmailInboxMessageWhereUniqueInput[]
    connect?: EmailInboxMessageWhereUniqueInput | EmailInboxMessageWhereUniqueInput[]
    update?: EmailInboxMessageUpdateWithWhereUniqueWithoutUserInput | EmailInboxMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailInboxMessageUpdateManyWithWhereWithoutUserInput | EmailInboxMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailInboxMessageScalarWhereInput | EmailInboxMessageScalarWhereInput[]
  }

  export type EmailContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailContactCreateWithoutUserInput, EmailContactUncheckedCreateWithoutUserInput> | EmailContactCreateWithoutUserInput[] | EmailContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailContactCreateOrConnectWithoutUserInput | EmailContactCreateOrConnectWithoutUserInput[]
    upsert?: EmailContactUpsertWithWhereUniqueWithoutUserInput | EmailContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailContactCreateManyUserInputEnvelope
    set?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    disconnect?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    delete?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    connect?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    update?: EmailContactUpdateWithWhereUniqueWithoutUserInput | EmailContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailContactUpdateManyWithWhereWithoutUserInput | EmailContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailContactScalarWhereInput | EmailContactScalarWhereInput[]
  }

  export type DocumentTemplateUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentTemplateCreateWithoutUserInput, DocumentTemplateUncheckedCreateWithoutUserInput> | DocumentTemplateCreateWithoutUserInput[] | DocumentTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentTemplateCreateOrConnectWithoutUserInput | DocumentTemplateCreateOrConnectWithoutUserInput[]
    upsert?: DocumentTemplateUpsertWithWhereUniqueWithoutUserInput | DocumentTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentTemplateCreateManyUserInputEnvelope
    set?: DocumentTemplateWhereUniqueInput | DocumentTemplateWhereUniqueInput[]
    disconnect?: DocumentTemplateWhereUniqueInput | DocumentTemplateWhereUniqueInput[]
    delete?: DocumentTemplateWhereUniqueInput | DocumentTemplateWhereUniqueInput[]
    connect?: DocumentTemplateWhereUniqueInput | DocumentTemplateWhereUniqueInput[]
    update?: DocumentTemplateUpdateWithWhereUniqueWithoutUserInput | DocumentTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentTemplateUpdateManyWithWhereWithoutUserInput | DocumentTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentTemplateScalarWhereInput | DocumentTemplateScalarWhereInput[]
  }

  export type GeneratedDocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<GeneratedDocumentCreateWithoutUserInput, GeneratedDocumentUncheckedCreateWithoutUserInput> | GeneratedDocumentCreateWithoutUserInput[] | GeneratedDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedDocumentCreateOrConnectWithoutUserInput | GeneratedDocumentCreateOrConnectWithoutUserInput[]
    upsert?: GeneratedDocumentUpsertWithWhereUniqueWithoutUserInput | GeneratedDocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GeneratedDocumentCreateManyUserInputEnvelope
    set?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    disconnect?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    delete?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    connect?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    update?: GeneratedDocumentUpdateWithWhereUniqueWithoutUserInput | GeneratedDocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GeneratedDocumentUpdateManyWithWhereWithoutUserInput | GeneratedDocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GeneratedDocumentScalarWhereInput | GeneratedDocumentScalarWhereInput[]
  }

  export type FileFolderUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileFolderCreateWithoutUserInput, FileFolderUncheckedCreateWithoutUserInput> | FileFolderCreateWithoutUserInput[] | FileFolderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutUserInput | FileFolderCreateOrConnectWithoutUserInput[]
    upsert?: FileFolderUpsertWithWhereUniqueWithoutUserInput | FileFolderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FileFolderCreateManyUserInputEnvelope
    set?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    disconnect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    delete?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    update?: FileFolderUpdateWithWhereUniqueWithoutUserInput | FileFolderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FileFolderUpdateManyWithWhereWithoutUserInput | FileFolderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
  }

  export type FileUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUserInput | FileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUserInput | FileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUserInput | FileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type SharedAccessUpdateManyWithoutUserNestedInput = {
    create?: XOR<SharedAccessCreateWithoutUserInput, SharedAccessUncheckedCreateWithoutUserInput> | SharedAccessCreateWithoutUserInput[] | SharedAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedAccessCreateOrConnectWithoutUserInput | SharedAccessCreateOrConnectWithoutUserInput[]
    upsert?: SharedAccessUpsertWithWhereUniqueWithoutUserInput | SharedAccessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SharedAccessCreateManyUserInputEnvelope
    set?: SharedAccessWhereUniqueInput | SharedAccessWhereUniqueInput[]
    disconnect?: SharedAccessWhereUniqueInput | SharedAccessWhereUniqueInput[]
    delete?: SharedAccessWhereUniqueInput | SharedAccessWhereUniqueInput[]
    connect?: SharedAccessWhereUniqueInput | SharedAccessWhereUniqueInput[]
    update?: SharedAccessUpdateWithWhereUniqueWithoutUserInput | SharedAccessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SharedAccessUpdateManyWithWhereWithoutUserInput | SharedAccessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SharedAccessScalarWhereInput | SharedAccessScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<AccountCreateWithoutOwnerInput, AccountUncheckedCreateWithoutOwnerInput> | AccountCreateWithoutOwnerInput[] | AccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutOwnerInput | AccountCreateOrConnectWithoutOwnerInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutOwnerInput | AccountUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: AccountCreateManyOwnerInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutOwnerInput | AccountUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutOwnerInput | AccountUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ContactCreateWithoutOwnerInput, ContactUncheckedCreateWithoutOwnerInput> | ContactCreateWithoutOwnerInput[] | ContactUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutOwnerInput | ContactCreateOrConnectWithoutOwnerInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutOwnerInput | ContactUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ContactCreateManyOwnerInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutOwnerInput | ContactUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutOwnerInput | ContactUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<DealCreateWithoutOwnerInput, DealUncheckedCreateWithoutOwnerInput> | DealCreateWithoutOwnerInput[] | DealUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DealCreateOrConnectWithoutOwnerInput | DealCreateOrConnectWithoutOwnerInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutOwnerInput | DealUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: DealCreateManyOwnerInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutOwnerInput | DealUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: DealUpdateManyWithWhereWithoutOwnerInput | DealUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ActivityCreateWithoutOwnerInput, ActivityUncheckedCreateWithoutOwnerInput> | ActivityCreateWithoutOwnerInput[] | ActivityUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOwnerInput | ActivityCreateOrConnectWithoutOwnerInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutOwnerInput | ActivityUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ActivityCreateManyOwnerInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutOwnerInput | ActivityUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutOwnerInput | ActivityUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type EmailAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailAccountCreateWithoutUserInput, EmailAccountUncheckedCreateWithoutUserInput> | EmailAccountCreateWithoutUserInput[] | EmailAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutUserInput | EmailAccountCreateOrConnectWithoutUserInput[]
    upsert?: EmailAccountUpsertWithWhereUniqueWithoutUserInput | EmailAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailAccountCreateManyUserInputEnvelope
    set?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    disconnect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    delete?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    update?: EmailAccountUpdateWithWhereUniqueWithoutUserInput | EmailAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailAccountUpdateManyWithWhereWithoutUserInput | EmailAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
  }

  export type EmailTemplateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput> | EmailTemplateCreateWithoutUserInput[] | EmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutUserInput | EmailTemplateCreateOrConnectWithoutUserInput[]
    upsert?: EmailTemplateUpsertWithWhereUniqueWithoutUserInput | EmailTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailTemplateCreateManyUserInputEnvelope
    set?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    disconnect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    delete?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    update?: EmailTemplateUpdateWithWhereUniqueWithoutUserInput | EmailTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailTemplateUpdateManyWithWhereWithoutUserInput | EmailTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
  }

  export type EmailMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailMessageCreateWithoutUserInput, EmailMessageUncheckedCreateWithoutUserInput> | EmailMessageCreateWithoutUserInput[] | EmailMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutUserInput | EmailMessageCreateOrConnectWithoutUserInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutUserInput | EmailMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailMessageCreateManyUserInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutUserInput | EmailMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutUserInput | EmailMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailInboxMessageCreateWithoutUserInput, EmailInboxMessageUncheckedCreateWithoutUserInput> | EmailInboxMessageCreateWithoutUserInput[] | EmailInboxMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailInboxMessageCreateOrConnectWithoutUserInput | EmailInboxMessageCreateOrConnectWithoutUserInput[]
    upsert?: EmailInboxMessageUpsertWithWhereUniqueWithoutUserInput | EmailInboxMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailInboxMessageCreateManyUserInputEnvelope
    set?: EmailInboxMessageWhereUniqueInput | EmailInboxMessageWhereUniqueInput[]
    disconnect?: EmailInboxMessageWhereUniqueInput | EmailInboxMessageWhereUniqueInput[]
    delete?: EmailInboxMessageWhereUniqueInput | EmailInboxMessageWhereUniqueInput[]
    connect?: EmailInboxMessageWhereUniqueInput | EmailInboxMessageWhereUniqueInput[]
    update?: EmailInboxMessageUpdateWithWhereUniqueWithoutUserInput | EmailInboxMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailInboxMessageUpdateManyWithWhereWithoutUserInput | EmailInboxMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailInboxMessageScalarWhereInput | EmailInboxMessageScalarWhereInput[]
  }

  export type EmailContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailContactCreateWithoutUserInput, EmailContactUncheckedCreateWithoutUserInput> | EmailContactCreateWithoutUserInput[] | EmailContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailContactCreateOrConnectWithoutUserInput | EmailContactCreateOrConnectWithoutUserInput[]
    upsert?: EmailContactUpsertWithWhereUniqueWithoutUserInput | EmailContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailContactCreateManyUserInputEnvelope
    set?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    disconnect?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    delete?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    connect?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    update?: EmailContactUpdateWithWhereUniqueWithoutUserInput | EmailContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailContactUpdateManyWithWhereWithoutUserInput | EmailContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailContactScalarWhereInput | EmailContactScalarWhereInput[]
  }

  export type DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentTemplateCreateWithoutUserInput, DocumentTemplateUncheckedCreateWithoutUserInput> | DocumentTemplateCreateWithoutUserInput[] | DocumentTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentTemplateCreateOrConnectWithoutUserInput | DocumentTemplateCreateOrConnectWithoutUserInput[]
    upsert?: DocumentTemplateUpsertWithWhereUniqueWithoutUserInput | DocumentTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentTemplateCreateManyUserInputEnvelope
    set?: DocumentTemplateWhereUniqueInput | DocumentTemplateWhereUniqueInput[]
    disconnect?: DocumentTemplateWhereUniqueInput | DocumentTemplateWhereUniqueInput[]
    delete?: DocumentTemplateWhereUniqueInput | DocumentTemplateWhereUniqueInput[]
    connect?: DocumentTemplateWhereUniqueInput | DocumentTemplateWhereUniqueInput[]
    update?: DocumentTemplateUpdateWithWhereUniqueWithoutUserInput | DocumentTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentTemplateUpdateManyWithWhereWithoutUserInput | DocumentTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentTemplateScalarWhereInput | DocumentTemplateScalarWhereInput[]
  }

  export type GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GeneratedDocumentCreateWithoutUserInput, GeneratedDocumentUncheckedCreateWithoutUserInput> | GeneratedDocumentCreateWithoutUserInput[] | GeneratedDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedDocumentCreateOrConnectWithoutUserInput | GeneratedDocumentCreateOrConnectWithoutUserInput[]
    upsert?: GeneratedDocumentUpsertWithWhereUniqueWithoutUserInput | GeneratedDocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GeneratedDocumentCreateManyUserInputEnvelope
    set?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    disconnect?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    delete?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    connect?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    update?: GeneratedDocumentUpdateWithWhereUniqueWithoutUserInput | GeneratedDocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GeneratedDocumentUpdateManyWithWhereWithoutUserInput | GeneratedDocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GeneratedDocumentScalarWhereInput | GeneratedDocumentScalarWhereInput[]
  }

  export type FileFolderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileFolderCreateWithoutUserInput, FileFolderUncheckedCreateWithoutUserInput> | FileFolderCreateWithoutUserInput[] | FileFolderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutUserInput | FileFolderCreateOrConnectWithoutUserInput[]
    upsert?: FileFolderUpsertWithWhereUniqueWithoutUserInput | FileFolderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FileFolderCreateManyUserInputEnvelope
    set?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    disconnect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    delete?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    update?: FileFolderUpdateWithWhereUniqueWithoutUserInput | FileFolderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FileFolderUpdateManyWithWhereWithoutUserInput | FileFolderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUserInput | FileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUserInput | FileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUserInput | FileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type SharedAccessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SharedAccessCreateWithoutUserInput, SharedAccessUncheckedCreateWithoutUserInput> | SharedAccessCreateWithoutUserInput[] | SharedAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedAccessCreateOrConnectWithoutUserInput | SharedAccessCreateOrConnectWithoutUserInput[]
    upsert?: SharedAccessUpsertWithWhereUniqueWithoutUserInput | SharedAccessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SharedAccessCreateManyUserInputEnvelope
    set?: SharedAccessWhereUniqueInput | SharedAccessWhereUniqueInput[]
    disconnect?: SharedAccessWhereUniqueInput | SharedAccessWhereUniqueInput[]
    delete?: SharedAccessWhereUniqueInput | SharedAccessWhereUniqueInput[]
    connect?: SharedAccessWhereUniqueInput | SharedAccessWhereUniqueInput[]
    update?: SharedAccessUpdateWithWhereUniqueWithoutUserInput | SharedAccessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SharedAccessUpdateManyWithWhereWithoutUserInput | SharedAccessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SharedAccessScalarWhereInput | SharedAccessScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutTeamInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutTeamNestedInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTeamInput | UserUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTeamInput | UserUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTeamInput | UserUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTeamInput | UserUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTeamInput | UserUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTeamInput | UserUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    connect?: UserWhereUniqueInput
  }

  export type ContactCreateNestedManyWithoutAccountInput = {
    create?: XOR<ContactCreateWithoutAccountInput, ContactUncheckedCreateWithoutAccountInput> | ContactCreateWithoutAccountInput[] | ContactUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAccountInput | ContactCreateOrConnectWithoutAccountInput[]
    createMany?: ContactCreateManyAccountInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutAccountInput = {
    create?: XOR<DealCreateWithoutAccountInput, DealUncheckedCreateWithoutAccountInput> | DealCreateWithoutAccountInput[] | DealUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: DealCreateOrConnectWithoutAccountInput | DealCreateOrConnectWithoutAccountInput[]
    createMany?: DealCreateManyAccountInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutAccountInput = {
    create?: XOR<ActivityCreateWithoutAccountInput, ActivityUncheckedCreateWithoutAccountInput> | ActivityCreateWithoutAccountInput[] | ActivityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutAccountInput | ActivityCreateOrConnectWithoutAccountInput[]
    createMany?: ActivityCreateManyAccountInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ContactCreateWithoutAccountInput, ContactUncheckedCreateWithoutAccountInput> | ContactCreateWithoutAccountInput[] | ContactUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAccountInput | ContactCreateOrConnectWithoutAccountInput[]
    createMany?: ContactCreateManyAccountInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<DealCreateWithoutAccountInput, DealUncheckedCreateWithoutAccountInput> | DealCreateWithoutAccountInput[] | DealUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: DealCreateOrConnectWithoutAccountInput | DealCreateOrConnectWithoutAccountInput[]
    createMany?: DealCreateManyAccountInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ActivityCreateWithoutAccountInput, ActivityUncheckedCreateWithoutAccountInput> | ActivityCreateWithoutAccountInput[] | ActivityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutAccountInput | ActivityCreateOrConnectWithoutAccountInput[]
    createMany?: ActivityCreateManyAccountInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAccountNestedInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    upsert?: UserUpsertWithoutAccountInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountInput, UserUpdateWithoutAccountInput>, UserUncheckedUpdateWithoutAccountInput>
  }

  export type ContactUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ContactCreateWithoutAccountInput, ContactUncheckedCreateWithoutAccountInput> | ContactCreateWithoutAccountInput[] | ContactUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAccountInput | ContactCreateOrConnectWithoutAccountInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutAccountInput | ContactUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ContactCreateManyAccountInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutAccountInput | ContactUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutAccountInput | ContactUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type DealUpdateManyWithoutAccountNestedInput = {
    create?: XOR<DealCreateWithoutAccountInput, DealUncheckedCreateWithoutAccountInput> | DealCreateWithoutAccountInput[] | DealUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: DealCreateOrConnectWithoutAccountInput | DealCreateOrConnectWithoutAccountInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutAccountInput | DealUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: DealCreateManyAccountInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutAccountInput | DealUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: DealUpdateManyWithWhereWithoutAccountInput | DealUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ActivityCreateWithoutAccountInput, ActivityUncheckedCreateWithoutAccountInput> | ActivityCreateWithoutAccountInput[] | ActivityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutAccountInput | ActivityCreateOrConnectWithoutAccountInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutAccountInput | ActivityUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ActivityCreateManyAccountInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutAccountInput | ActivityUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutAccountInput | ActivityUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ContactCreateWithoutAccountInput, ContactUncheckedCreateWithoutAccountInput> | ContactCreateWithoutAccountInput[] | ContactUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAccountInput | ContactCreateOrConnectWithoutAccountInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutAccountInput | ContactUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ContactCreateManyAccountInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutAccountInput | ContactUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutAccountInput | ContactUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<DealCreateWithoutAccountInput, DealUncheckedCreateWithoutAccountInput> | DealCreateWithoutAccountInput[] | DealUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: DealCreateOrConnectWithoutAccountInput | DealCreateOrConnectWithoutAccountInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutAccountInput | DealUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: DealCreateManyAccountInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutAccountInput | DealUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: DealUpdateManyWithWhereWithoutAccountInput | DealUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ActivityCreateWithoutAccountInput, ActivityUncheckedCreateWithoutAccountInput> | ActivityCreateWithoutAccountInput[] | ActivityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutAccountInput | ActivityCreateOrConnectWithoutAccountInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutAccountInput | ActivityUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ActivityCreateManyAccountInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutAccountInput | ActivityUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutAccountInput | ActivityUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutContactInput = {
    create?: XOR<UserCreateWithoutContactInput, UserUncheckedCreateWithoutContactInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactInput
    connect?: UserWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutContactInput = {
    create?: XOR<AccountCreateWithoutContactInput, AccountUncheckedCreateWithoutContactInput>
    connectOrCreate?: AccountCreateOrConnectWithoutContactInput
    connect?: AccountWhereUniqueInput
  }

  export type DealCreateNestedManyWithoutContactInput = {
    create?: XOR<DealCreateWithoutContactInput, DealUncheckedCreateWithoutContactInput> | DealCreateWithoutContactInput[] | DealUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DealCreateOrConnectWithoutContactInput | DealCreateOrConnectWithoutContactInput[]
    createMany?: DealCreateManyContactInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutContactInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ContactTagCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput> | ContactTagCreateWithoutContactInput[] | ContactTagUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutContactInput | ContactTagCreateOrConnectWithoutContactInput[]
    createMany?: ContactTagCreateManyContactInputEnvelope
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<DealCreateWithoutContactInput, DealUncheckedCreateWithoutContactInput> | DealCreateWithoutContactInput[] | DealUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DealCreateOrConnectWithoutContactInput | DealCreateOrConnectWithoutContactInput[]
    createMany?: DealCreateManyContactInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ContactTagUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput> | ContactTagCreateWithoutContactInput[] | ContactTagUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutContactInput | ContactTagCreateOrConnectWithoutContactInput[]
    createMany?: ContactTagCreateManyContactInputEnvelope
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutContactNestedInput = {
    create?: XOR<UserCreateWithoutContactInput, UserUncheckedCreateWithoutContactInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactInput
    upsert?: UserUpsertWithoutContactInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactInput, UserUpdateWithoutContactInput>, UserUncheckedUpdateWithoutContactInput>
  }

  export type AccountUpdateOneWithoutContactNestedInput = {
    create?: XOR<AccountCreateWithoutContactInput, AccountUncheckedCreateWithoutContactInput>
    connectOrCreate?: AccountCreateOrConnectWithoutContactInput
    upsert?: AccountUpsertWithoutContactInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutContactInput, AccountUpdateWithoutContactInput>, AccountUncheckedUpdateWithoutContactInput>
  }

  export type DealUpdateManyWithoutContactNestedInput = {
    create?: XOR<DealCreateWithoutContactInput, DealUncheckedCreateWithoutContactInput> | DealCreateWithoutContactInput[] | DealUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DealCreateOrConnectWithoutContactInput | DealCreateOrConnectWithoutContactInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutContactInput | DealUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: DealCreateManyContactInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutContactInput | DealUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: DealUpdateManyWithWhereWithoutContactInput | DealUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutContactNestedInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutContactInput | ActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutContactInput | ActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutContactInput | ActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ContactTagUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput> | ContactTagCreateWithoutContactInput[] | ContactTagUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutContactInput | ContactTagCreateOrConnectWithoutContactInput[]
    upsert?: ContactTagUpsertWithWhereUniqueWithoutContactInput | ContactTagUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactTagCreateManyContactInputEnvelope
    set?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    disconnect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    delete?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    update?: ContactTagUpdateWithWhereUniqueWithoutContactInput | ContactTagUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactTagUpdateManyWithWhereWithoutContactInput | ContactTagUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<DealCreateWithoutContactInput, DealUncheckedCreateWithoutContactInput> | DealCreateWithoutContactInput[] | DealUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DealCreateOrConnectWithoutContactInput | DealCreateOrConnectWithoutContactInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutContactInput | DealUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: DealCreateManyContactInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutContactInput | DealUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: DealUpdateManyWithWhereWithoutContactInput | DealUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutContactInput | ActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutContactInput | ActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutContactInput | ActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ContactTagUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput> | ContactTagCreateWithoutContactInput[] | ContactTagUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutContactInput | ContactTagCreateOrConnectWithoutContactInput[]
    upsert?: ContactTagUpsertWithWhereUniqueWithoutContactInput | ContactTagUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactTagCreateManyContactInputEnvelope
    set?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    disconnect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    delete?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    update?: ContactTagUpdateWithWhereUniqueWithoutContactInput | ContactTagUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactTagUpdateManyWithWhereWithoutContactInput | ContactTagUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutDealInput = {
    create?: XOR<AccountCreateWithoutDealInput, AccountUncheckedCreateWithoutDealInput>
    connectOrCreate?: AccountCreateOrConnectWithoutDealInput
    connect?: AccountWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutDealInput = {
    create?: XOR<ContactCreateWithoutDealInput, ContactUncheckedCreateWithoutDealInput>
    connectOrCreate?: ContactCreateOrConnectWithoutDealInput
    connect?: ContactWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDealInput = {
    create?: XOR<UserCreateWithoutDealInput, UserUncheckedCreateWithoutDealInput>
    connectOrCreate?: UserCreateOrConnectWithoutDealInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityCreateNestedManyWithoutDealInput = {
    create?: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput> | ActivityCreateWithoutDealInput[] | ActivityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDealInput | ActivityCreateOrConnectWithoutDealInput[]
    createMany?: ActivityCreateManyDealInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type DealTagCreateNestedManyWithoutDealInput = {
    create?: XOR<DealTagCreateWithoutDealInput, DealTagUncheckedCreateWithoutDealInput> | DealTagCreateWithoutDealInput[] | DealTagUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealTagCreateOrConnectWithoutDealInput | DealTagCreateOrConnectWithoutDealInput[]
    createMany?: DealTagCreateManyDealInputEnvelope
    connect?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput> | ActivityCreateWithoutDealInput[] | ActivityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDealInput | ActivityCreateOrConnectWithoutDealInput[]
    createMany?: ActivityCreateManyDealInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type DealTagUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<DealTagCreateWithoutDealInput, DealTagUncheckedCreateWithoutDealInput> | DealTagCreateWithoutDealInput[] | DealTagUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealTagCreateOrConnectWithoutDealInput | DealTagCreateOrConnectWithoutDealInput[]
    createMany?: DealTagCreateManyDealInputEnvelope
    connect?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountUpdateOneWithoutDealNestedInput = {
    create?: XOR<AccountCreateWithoutDealInput, AccountUncheckedCreateWithoutDealInput>
    connectOrCreate?: AccountCreateOrConnectWithoutDealInput
    upsert?: AccountUpsertWithoutDealInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutDealInput, AccountUpdateWithoutDealInput>, AccountUncheckedUpdateWithoutDealInput>
  }

  export type ContactUpdateOneWithoutDealNestedInput = {
    create?: XOR<ContactCreateWithoutDealInput, ContactUncheckedCreateWithoutDealInput>
    connectOrCreate?: ContactCreateOrConnectWithoutDealInput
    upsert?: ContactUpsertWithoutDealInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutDealInput, ContactUpdateWithoutDealInput>, ContactUncheckedUpdateWithoutDealInput>
  }

  export type UserUpdateOneRequiredWithoutDealNestedInput = {
    create?: XOR<UserCreateWithoutDealInput, UserUncheckedCreateWithoutDealInput>
    connectOrCreate?: UserCreateOrConnectWithoutDealInput
    upsert?: UserUpsertWithoutDealInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDealInput, UserUpdateWithoutDealInput>, UserUncheckedUpdateWithoutDealInput>
  }

  export type ActivityUpdateManyWithoutDealNestedInput = {
    create?: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput> | ActivityCreateWithoutDealInput[] | ActivityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDealInput | ActivityCreateOrConnectWithoutDealInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutDealInput | ActivityUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: ActivityCreateManyDealInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutDealInput | ActivityUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutDealInput | ActivityUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type DealTagUpdateManyWithoutDealNestedInput = {
    create?: XOR<DealTagCreateWithoutDealInput, DealTagUncheckedCreateWithoutDealInput> | DealTagCreateWithoutDealInput[] | DealTagUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealTagCreateOrConnectWithoutDealInput | DealTagCreateOrConnectWithoutDealInput[]
    upsert?: DealTagUpsertWithWhereUniqueWithoutDealInput | DealTagUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DealTagCreateManyDealInputEnvelope
    set?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    disconnect?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    delete?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    connect?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    update?: DealTagUpdateWithWhereUniqueWithoutDealInput | DealTagUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DealTagUpdateManyWithWhereWithoutDealInput | DealTagUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DealTagScalarWhereInput | DealTagScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput> | ActivityCreateWithoutDealInput[] | ActivityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDealInput | ActivityCreateOrConnectWithoutDealInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutDealInput | ActivityUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: ActivityCreateManyDealInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutDealInput | ActivityUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutDealInput | ActivityUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type DealTagUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<DealTagCreateWithoutDealInput, DealTagUncheckedCreateWithoutDealInput> | DealTagCreateWithoutDealInput[] | DealTagUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealTagCreateOrConnectWithoutDealInput | DealTagCreateOrConnectWithoutDealInput[]
    upsert?: DealTagUpsertWithWhereUniqueWithoutDealInput | DealTagUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DealTagCreateManyDealInputEnvelope
    set?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    disconnect?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    delete?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    connect?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    update?: DealTagUpdateWithWhereUniqueWithoutDealInput | DealTagUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DealTagUpdateManyWithWhereWithoutDealInput | DealTagUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DealTagScalarWhereInput | DealTagScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutActivityInput = {
    create?: XOR<UserCreateWithoutActivityInput, UserUncheckedCreateWithoutActivityInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityInput
    connect?: UserWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutActivityInput = {
    create?: XOR<AccountCreateWithoutActivityInput, AccountUncheckedCreateWithoutActivityInput>
    connectOrCreate?: AccountCreateOrConnectWithoutActivityInput
    connect?: AccountWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutActivityInput = {
    create?: XOR<ContactCreateWithoutActivityInput, ContactUncheckedCreateWithoutActivityInput>
    connectOrCreate?: ContactCreateOrConnectWithoutActivityInput
    connect?: ContactWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutActivityInput = {
    create?: XOR<DealCreateWithoutActivityInput, DealUncheckedCreateWithoutActivityInput>
    connectOrCreate?: DealCreateOrConnectWithoutActivityInput
    connect?: DealWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutSubtasksInput = {
    create?: XOR<ActivityCreateWithoutSubtasksInput, ActivityUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutSubtasksInput
    connect?: ActivityWhereUniqueInput
  }

  export type ActivityCreateNestedManyWithoutParentInput = {
    create?: XOR<ActivityCreateWithoutParentInput, ActivityUncheckedCreateWithoutParentInput> | ActivityCreateWithoutParentInput[] | ActivityUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutParentInput | ActivityCreateOrConnectWithoutParentInput[]
    createMany?: ActivityCreateManyParentInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutActivitiesInput = {
    create?: XOR<TagCreateWithoutActivitiesInput, TagUncheckedCreateWithoutActivitiesInput> | TagCreateWithoutActivitiesInput[] | TagUncheckedCreateWithoutActivitiesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutActivitiesInput | TagCreateOrConnectWithoutActivitiesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ActivityCreateWithoutParentInput, ActivityUncheckedCreateWithoutParentInput> | ActivityCreateWithoutParentInput[] | ActivityUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutParentInput | ActivityCreateOrConnectWithoutParentInput[]
    createMany?: ActivityCreateManyParentInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutActivitiesInput = {
    create?: XOR<TagCreateWithoutActivitiesInput, TagUncheckedCreateWithoutActivitiesInput> | TagCreateWithoutActivitiesInput[] | TagUncheckedCreateWithoutActivitiesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutActivitiesInput | TagCreateOrConnectWithoutActivitiesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutActivityNestedInput = {
    create?: XOR<UserCreateWithoutActivityInput, UserUncheckedCreateWithoutActivityInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityInput
    upsert?: UserUpsertWithoutActivityInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityInput, UserUpdateWithoutActivityInput>, UserUncheckedUpdateWithoutActivityInput>
  }

  export type AccountUpdateOneWithoutActivityNestedInput = {
    create?: XOR<AccountCreateWithoutActivityInput, AccountUncheckedCreateWithoutActivityInput>
    connectOrCreate?: AccountCreateOrConnectWithoutActivityInput
    upsert?: AccountUpsertWithoutActivityInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutActivityInput, AccountUpdateWithoutActivityInput>, AccountUncheckedUpdateWithoutActivityInput>
  }

  export type ContactUpdateOneWithoutActivityNestedInput = {
    create?: XOR<ContactCreateWithoutActivityInput, ContactUncheckedCreateWithoutActivityInput>
    connectOrCreate?: ContactCreateOrConnectWithoutActivityInput
    upsert?: ContactUpsertWithoutActivityInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutActivityInput, ContactUpdateWithoutActivityInput>, ContactUncheckedUpdateWithoutActivityInput>
  }

  export type DealUpdateOneWithoutActivityNestedInput = {
    create?: XOR<DealCreateWithoutActivityInput, DealUncheckedCreateWithoutActivityInput>
    connectOrCreate?: DealCreateOrConnectWithoutActivityInput
    upsert?: DealUpsertWithoutActivityInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutActivityInput, DealUpdateWithoutActivityInput>, DealUncheckedUpdateWithoutActivityInput>
  }

  export type ActivityUpdateOneWithoutSubtasksNestedInput = {
    create?: XOR<ActivityCreateWithoutSubtasksInput, ActivityUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutSubtasksInput
    upsert?: ActivityUpsertWithoutSubtasksInput
    disconnect?: ActivityWhereInput | boolean
    delete?: ActivityWhereInput | boolean
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutSubtasksInput, ActivityUpdateWithoutSubtasksInput>, ActivityUncheckedUpdateWithoutSubtasksInput>
  }

  export type ActivityUpdateManyWithoutParentNestedInput = {
    create?: XOR<ActivityCreateWithoutParentInput, ActivityUncheckedCreateWithoutParentInput> | ActivityCreateWithoutParentInput[] | ActivityUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutParentInput | ActivityCreateOrConnectWithoutParentInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutParentInput | ActivityUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ActivityCreateManyParentInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutParentInput | ActivityUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutParentInput | ActivityUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type TagUpdateManyWithoutActivitiesNestedInput = {
    create?: XOR<TagCreateWithoutActivitiesInput, TagUncheckedCreateWithoutActivitiesInput> | TagCreateWithoutActivitiesInput[] | TagUncheckedCreateWithoutActivitiesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutActivitiesInput | TagCreateOrConnectWithoutActivitiesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutActivitiesInput | TagUpsertWithWhereUniqueWithoutActivitiesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutActivitiesInput | TagUpdateWithWhereUniqueWithoutActivitiesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutActivitiesInput | TagUpdateManyWithWhereWithoutActivitiesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ActivityCreateWithoutParentInput, ActivityUncheckedCreateWithoutParentInput> | ActivityCreateWithoutParentInput[] | ActivityUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutParentInput | ActivityCreateOrConnectWithoutParentInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutParentInput | ActivityUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ActivityCreateManyParentInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutParentInput | ActivityUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutParentInput | ActivityUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutActivitiesNestedInput = {
    create?: XOR<TagCreateWithoutActivitiesInput, TagUncheckedCreateWithoutActivitiesInput> | TagCreateWithoutActivitiesInput[] | TagUncheckedCreateWithoutActivitiesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutActivitiesInput | TagCreateOrConnectWithoutActivitiesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutActivitiesInput | TagUpsertWithWhereUniqueWithoutActivitiesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutActivitiesInput | TagUpdateWithWhereUniqueWithoutActivitiesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutActivitiesInput | TagUpdateManyWithWhereWithoutActivitiesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmailAccountInput = {
    create?: XOR<UserCreateWithoutEmailAccountInput, UserUncheckedCreateWithoutEmailAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailAccountInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmailAccountNestedInput = {
    create?: XOR<UserCreateWithoutEmailAccountInput, UserUncheckedCreateWithoutEmailAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailAccountInput
    upsert?: UserUpsertWithoutEmailAccountInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailAccountInput, UserUpdateWithoutEmailAccountInput>, UserUncheckedUpdateWithoutEmailAccountInput>
  }

  export type UserCreateNestedOneWithoutEmailTemplateInput = {
    create?: XOR<UserCreateWithoutEmailTemplateInput, UserUncheckedCreateWithoutEmailTemplateInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailTemplateInput
    connect?: UserWhereUniqueInput
  }

  export type EmailMessageCreateNestedManyWithoutTemplateInput = {
    create?: XOR<EmailMessageCreateWithoutTemplateInput, EmailMessageUncheckedCreateWithoutTemplateInput> | EmailMessageCreateWithoutTemplateInput[] | EmailMessageUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutTemplateInput | EmailMessageCreateOrConnectWithoutTemplateInput[]
    createMany?: EmailMessageCreateManyTemplateInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type EmailMessageUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<EmailMessageCreateWithoutTemplateInput, EmailMessageUncheckedCreateWithoutTemplateInput> | EmailMessageCreateWithoutTemplateInput[] | EmailMessageUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutTemplateInput | EmailMessageCreateOrConnectWithoutTemplateInput[]
    createMany?: EmailMessageCreateManyTemplateInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutEmailTemplateNestedInput = {
    create?: XOR<UserCreateWithoutEmailTemplateInput, UserUncheckedCreateWithoutEmailTemplateInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailTemplateInput
    upsert?: UserUpsertWithoutEmailTemplateInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailTemplateInput, UserUpdateWithoutEmailTemplateInput>, UserUncheckedUpdateWithoutEmailTemplateInput>
  }

  export type EmailMessageUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<EmailMessageCreateWithoutTemplateInput, EmailMessageUncheckedCreateWithoutTemplateInput> | EmailMessageCreateWithoutTemplateInput[] | EmailMessageUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutTemplateInput | EmailMessageCreateOrConnectWithoutTemplateInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutTemplateInput | EmailMessageUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: EmailMessageCreateManyTemplateInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutTemplateInput | EmailMessageUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutTemplateInput | EmailMessageUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type EmailMessageUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<EmailMessageCreateWithoutTemplateInput, EmailMessageUncheckedCreateWithoutTemplateInput> | EmailMessageCreateWithoutTemplateInput[] | EmailMessageUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutTemplateInput | EmailMessageCreateOrConnectWithoutTemplateInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutTemplateInput | EmailMessageUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: EmailMessageCreateManyTemplateInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutTemplateInput | EmailMessageUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutTemplateInput | EmailMessageUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmailMessageInput = {
    create?: XOR<UserCreateWithoutEmailMessageInput, UserUncheckedCreateWithoutEmailMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailMessageInput
    connect?: UserWhereUniqueInput
  }

  export type EmailTemplateCreateNestedOneWithoutEmailMessageInput = {
    create?: XOR<EmailTemplateCreateWithoutEmailMessageInput, EmailTemplateUncheckedCreateWithoutEmailMessageInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutEmailMessageInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmailMessageNestedInput = {
    create?: XOR<UserCreateWithoutEmailMessageInput, UserUncheckedCreateWithoutEmailMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailMessageInput
    upsert?: UserUpsertWithoutEmailMessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailMessageInput, UserUpdateWithoutEmailMessageInput>, UserUncheckedUpdateWithoutEmailMessageInput>
  }

  export type EmailTemplateUpdateOneWithoutEmailMessageNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutEmailMessageInput, EmailTemplateUncheckedCreateWithoutEmailMessageInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutEmailMessageInput
    upsert?: EmailTemplateUpsertWithoutEmailMessageInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutEmailMessageInput, EmailTemplateUpdateWithoutEmailMessageInput>, EmailTemplateUncheckedUpdateWithoutEmailMessageInput>
  }

  export type UserCreateNestedOneWithoutEmailInboxMessageInput = {
    create?: XOR<UserCreateWithoutEmailInboxMessageInput, UserUncheckedCreateWithoutEmailInboxMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailInboxMessageInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmailInboxMessageNestedInput = {
    create?: XOR<UserCreateWithoutEmailInboxMessageInput, UserUncheckedCreateWithoutEmailInboxMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailInboxMessageInput
    upsert?: UserUpsertWithoutEmailInboxMessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailInboxMessageInput, UserUpdateWithoutEmailInboxMessageInput>, UserUncheckedUpdateWithoutEmailInboxMessageInput>
  }

  export type UserCreateNestedOneWithoutEmailContactInput = {
    create?: XOR<UserCreateWithoutEmailContactInput, UserUncheckedCreateWithoutEmailContactInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailContactInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmailContactNestedInput = {
    create?: XOR<UserCreateWithoutEmailContactInput, UserUncheckedCreateWithoutEmailContactInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailContactInput
    upsert?: UserUpsertWithoutEmailContactInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailContactInput, UserUpdateWithoutEmailContactInput>, UserUncheckedUpdateWithoutEmailContactInput>
  }

  export type UserCreateNestedOneWithoutDocumentTemplateInput = {
    create?: XOR<UserCreateWithoutDocumentTemplateInput, UserUncheckedCreateWithoutDocumentTemplateInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentTemplateInput
    connect?: UserWhereUniqueInput
  }

  export type GeneratedDocumentCreateNestedManyWithoutTemplateInput = {
    create?: XOR<GeneratedDocumentCreateWithoutTemplateInput, GeneratedDocumentUncheckedCreateWithoutTemplateInput> | GeneratedDocumentCreateWithoutTemplateInput[] | GeneratedDocumentUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: GeneratedDocumentCreateOrConnectWithoutTemplateInput | GeneratedDocumentCreateOrConnectWithoutTemplateInput[]
    createMany?: GeneratedDocumentCreateManyTemplateInputEnvelope
    connect?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
  }

  export type GeneratedDocumentUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<GeneratedDocumentCreateWithoutTemplateInput, GeneratedDocumentUncheckedCreateWithoutTemplateInput> | GeneratedDocumentCreateWithoutTemplateInput[] | GeneratedDocumentUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: GeneratedDocumentCreateOrConnectWithoutTemplateInput | GeneratedDocumentCreateOrConnectWithoutTemplateInput[]
    createMany?: GeneratedDocumentCreateManyTemplateInputEnvelope
    connect?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutDocumentTemplateNestedInput = {
    create?: XOR<UserCreateWithoutDocumentTemplateInput, UserUncheckedCreateWithoutDocumentTemplateInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentTemplateInput
    upsert?: UserUpsertWithoutDocumentTemplateInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentTemplateInput, UserUpdateWithoutDocumentTemplateInput>, UserUncheckedUpdateWithoutDocumentTemplateInput>
  }

  export type GeneratedDocumentUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<GeneratedDocumentCreateWithoutTemplateInput, GeneratedDocumentUncheckedCreateWithoutTemplateInput> | GeneratedDocumentCreateWithoutTemplateInput[] | GeneratedDocumentUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: GeneratedDocumentCreateOrConnectWithoutTemplateInput | GeneratedDocumentCreateOrConnectWithoutTemplateInput[]
    upsert?: GeneratedDocumentUpsertWithWhereUniqueWithoutTemplateInput | GeneratedDocumentUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: GeneratedDocumentCreateManyTemplateInputEnvelope
    set?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    disconnect?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    delete?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    connect?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    update?: GeneratedDocumentUpdateWithWhereUniqueWithoutTemplateInput | GeneratedDocumentUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: GeneratedDocumentUpdateManyWithWhereWithoutTemplateInput | GeneratedDocumentUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: GeneratedDocumentScalarWhereInput | GeneratedDocumentScalarWhereInput[]
  }

  export type GeneratedDocumentUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<GeneratedDocumentCreateWithoutTemplateInput, GeneratedDocumentUncheckedCreateWithoutTemplateInput> | GeneratedDocumentCreateWithoutTemplateInput[] | GeneratedDocumentUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: GeneratedDocumentCreateOrConnectWithoutTemplateInput | GeneratedDocumentCreateOrConnectWithoutTemplateInput[]
    upsert?: GeneratedDocumentUpsertWithWhereUniqueWithoutTemplateInput | GeneratedDocumentUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: GeneratedDocumentCreateManyTemplateInputEnvelope
    set?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    disconnect?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    delete?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    connect?: GeneratedDocumentWhereUniqueInput | GeneratedDocumentWhereUniqueInput[]
    update?: GeneratedDocumentUpdateWithWhereUniqueWithoutTemplateInput | GeneratedDocumentUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: GeneratedDocumentUpdateManyWithWhereWithoutTemplateInput | GeneratedDocumentUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: GeneratedDocumentScalarWhereInput | GeneratedDocumentScalarWhereInput[]
  }

  export type DocumentTemplateCreateNestedOneWithoutGeneratedDocumentInput = {
    create?: XOR<DocumentTemplateCreateWithoutGeneratedDocumentInput, DocumentTemplateUncheckedCreateWithoutGeneratedDocumentInput>
    connectOrCreate?: DocumentTemplateCreateOrConnectWithoutGeneratedDocumentInput
    connect?: DocumentTemplateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGeneratedDocumentInput = {
    create?: XOR<UserCreateWithoutGeneratedDocumentInput, UserUncheckedCreateWithoutGeneratedDocumentInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedDocumentInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentTemplateUpdateOneRequiredWithoutGeneratedDocumentNestedInput = {
    create?: XOR<DocumentTemplateCreateWithoutGeneratedDocumentInput, DocumentTemplateUncheckedCreateWithoutGeneratedDocumentInput>
    connectOrCreate?: DocumentTemplateCreateOrConnectWithoutGeneratedDocumentInput
    upsert?: DocumentTemplateUpsertWithoutGeneratedDocumentInput
    connect?: DocumentTemplateWhereUniqueInput
    update?: XOR<XOR<DocumentTemplateUpdateToOneWithWhereWithoutGeneratedDocumentInput, DocumentTemplateUpdateWithoutGeneratedDocumentInput>, DocumentTemplateUncheckedUpdateWithoutGeneratedDocumentInput>
  }

  export type UserUpdateOneRequiredWithoutGeneratedDocumentNestedInput = {
    create?: XOR<UserCreateWithoutGeneratedDocumentInput, UserUncheckedCreateWithoutGeneratedDocumentInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedDocumentInput
    upsert?: UserUpsertWithoutGeneratedDocumentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGeneratedDocumentInput, UserUpdateWithoutGeneratedDocumentInput>, UserUncheckedUpdateWithoutGeneratedDocumentInput>
  }

  export type UserCreateNestedOneWithoutFileFolderInput = {
    create?: XOR<UserCreateWithoutFileFolderInput, UserUncheckedCreateWithoutFileFolderInput>
    connectOrCreate?: UserCreateOrConnectWithoutFileFolderInput
    connect?: UserWhereUniqueInput
  }

  export type FileCreateNestedManyWithoutFolderInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[]
    createMany?: FileCreateManyFolderInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[]
    createMany?: FileCreateManyFolderInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutFileFolderNestedInput = {
    create?: XOR<UserCreateWithoutFileFolderInput, UserUncheckedCreateWithoutFileFolderInput>
    connectOrCreate?: UserCreateOrConnectWithoutFileFolderInput
    upsert?: UserUpsertWithoutFileFolderInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFileFolderInput, UserUpdateWithoutFileFolderInput>, UserUncheckedUpdateWithoutFileFolderInput>
  }

  export type FileUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutFolderInput | FileUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: FileCreateManyFolderInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutFolderInput | FileUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: FileUpdateManyWithWhereWithoutFolderInput | FileUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutFolderInput | FileUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: FileCreateManyFolderInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutFolderInput | FileUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: FileUpdateManyWithWhereWithoutFolderInput | FileUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFileInput = {
    create?: XOR<UserCreateWithoutFileInput, UserUncheckedCreateWithoutFileInput>
    connectOrCreate?: UserCreateOrConnectWithoutFileInput
    connect?: UserWhereUniqueInput
  }

  export type FileFolderCreateNestedOneWithoutFilesInput = {
    create?: XOR<FileFolderCreateWithoutFilesInput, FileFolderUncheckedCreateWithoutFilesInput>
    connectOrCreate?: FileFolderCreateOrConnectWithoutFilesInput
    connect?: FileFolderWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutFilesInput = {
    create?: XOR<CommentCreateWithoutFilesInput, CommentUncheckedCreateWithoutFilesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutFilesInput
    connect?: CommentWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutFileNestedInput = {
    create?: XOR<UserCreateWithoutFileInput, UserUncheckedCreateWithoutFileInput>
    connectOrCreate?: UserCreateOrConnectWithoutFileInput
    upsert?: UserUpsertWithoutFileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFileInput, UserUpdateWithoutFileInput>, UserUncheckedUpdateWithoutFileInput>
  }

  export type FileFolderUpdateOneWithoutFilesNestedInput = {
    create?: XOR<FileFolderCreateWithoutFilesInput, FileFolderUncheckedCreateWithoutFilesInput>
    connectOrCreate?: FileFolderCreateOrConnectWithoutFilesInput
    upsert?: FileFolderUpsertWithoutFilesInput
    disconnect?: FileFolderWhereInput | boolean
    delete?: FileFolderWhereInput | boolean
    connect?: FileFolderWhereUniqueInput
    update?: XOR<XOR<FileFolderUpdateToOneWithWhereWithoutFilesInput, FileFolderUpdateWithoutFilesInput>, FileFolderUncheckedUpdateWithoutFilesInput>
  }

  export type CommentUpdateOneWithoutFilesNestedInput = {
    create?: XOR<CommentCreateWithoutFilesInput, CommentUncheckedCreateWithoutFilesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutFilesInput
    upsert?: CommentUpsertWithoutFilesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutFilesInput, CommentUpdateWithoutFilesInput>, CommentUncheckedUpdateWithoutFilesInput>
  }

  export type DealCreateNestedOneWithoutDealTagInput = {
    create?: XOR<DealCreateWithoutDealTagInput, DealUncheckedCreateWithoutDealTagInput>
    connectOrCreate?: DealCreateOrConnectWithoutDealTagInput
    connect?: DealWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutDealTagsInput = {
    create?: XOR<TagCreateWithoutDealTagsInput, TagUncheckedCreateWithoutDealTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutDealTagsInput
    connect?: TagWhereUniqueInput
  }

  export type DealUpdateOneRequiredWithoutDealTagNestedInput = {
    create?: XOR<DealCreateWithoutDealTagInput, DealUncheckedCreateWithoutDealTagInput>
    connectOrCreate?: DealCreateOrConnectWithoutDealTagInput
    upsert?: DealUpsertWithoutDealTagInput
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutDealTagInput, DealUpdateWithoutDealTagInput>, DealUncheckedUpdateWithoutDealTagInput>
  }

  export type TagUpdateOneRequiredWithoutDealTagsNestedInput = {
    create?: XOR<TagCreateWithoutDealTagsInput, TagUncheckedCreateWithoutDealTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutDealTagsInput
    upsert?: TagUpsertWithoutDealTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutDealTagsInput, TagUpdateWithoutDealTagsInput>, TagUncheckedUpdateWithoutDealTagsInput>
  }

  export type ContactCreateNestedOneWithoutContactTagInput = {
    create?: XOR<ContactCreateWithoutContactTagInput, ContactUncheckedCreateWithoutContactTagInput>
    connectOrCreate?: ContactCreateOrConnectWithoutContactTagInput
    connect?: ContactWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutContactTagsInput = {
    create?: XOR<TagCreateWithoutContactTagsInput, TagUncheckedCreateWithoutContactTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutContactTagsInput
    connect?: TagWhereUniqueInput
  }

  export type ContactUpdateOneRequiredWithoutContactTagNestedInput = {
    create?: XOR<ContactCreateWithoutContactTagInput, ContactUncheckedCreateWithoutContactTagInput>
    connectOrCreate?: ContactCreateOrConnectWithoutContactTagInput
    upsert?: ContactUpsertWithoutContactTagInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutContactTagInput, ContactUpdateWithoutContactTagInput>, ContactUncheckedUpdateWithoutContactTagInput>
  }

  export type TagUpdateOneRequiredWithoutContactTagsNestedInput = {
    create?: XOR<TagCreateWithoutContactTagsInput, TagUncheckedCreateWithoutContactTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutContactTagsInput
    upsert?: TagUpsertWithoutContactTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutContactTagsInput, TagUpdateWithoutContactTagsInput>, TagUncheckedUpdateWithoutContactTagsInput>
  }

  export type DealTagCreateNestedManyWithoutTagInput = {
    create?: XOR<DealTagCreateWithoutTagInput, DealTagUncheckedCreateWithoutTagInput> | DealTagCreateWithoutTagInput[] | DealTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DealTagCreateOrConnectWithoutTagInput | DealTagCreateOrConnectWithoutTagInput[]
    createMany?: DealTagCreateManyTagInputEnvelope
    connect?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
  }

  export type ContactTagCreateNestedManyWithoutTagInput = {
    create?: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput> | ContactTagCreateWithoutTagInput[] | ContactTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutTagInput | ContactTagCreateOrConnectWithoutTagInput[]
    createMany?: ContactTagCreateManyTagInputEnvelope
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutTagsInput = {
    create?: XOR<ActivityCreateWithoutTagsInput, ActivityUncheckedCreateWithoutTagsInput> | ActivityCreateWithoutTagsInput[] | ActivityUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTagsInput | ActivityCreateOrConnectWithoutTagsInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type DealTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<DealTagCreateWithoutTagInput, DealTagUncheckedCreateWithoutTagInput> | DealTagCreateWithoutTagInput[] | DealTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DealTagCreateOrConnectWithoutTagInput | DealTagCreateOrConnectWithoutTagInput[]
    createMany?: DealTagCreateManyTagInputEnvelope
    connect?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
  }

  export type ContactTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput> | ContactTagCreateWithoutTagInput[] | ContactTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutTagInput | ContactTagCreateOrConnectWithoutTagInput[]
    createMany?: ContactTagCreateManyTagInputEnvelope
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<ActivityCreateWithoutTagsInput, ActivityUncheckedCreateWithoutTagsInput> | ActivityCreateWithoutTagsInput[] | ActivityUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTagsInput | ActivityCreateOrConnectWithoutTagsInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type DealTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<DealTagCreateWithoutTagInput, DealTagUncheckedCreateWithoutTagInput> | DealTagCreateWithoutTagInput[] | DealTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DealTagCreateOrConnectWithoutTagInput | DealTagCreateOrConnectWithoutTagInput[]
    upsert?: DealTagUpsertWithWhereUniqueWithoutTagInput | DealTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: DealTagCreateManyTagInputEnvelope
    set?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    disconnect?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    delete?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    connect?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    update?: DealTagUpdateWithWhereUniqueWithoutTagInput | DealTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: DealTagUpdateManyWithWhereWithoutTagInput | DealTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: DealTagScalarWhereInput | DealTagScalarWhereInput[]
  }

  export type ContactTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput> | ContactTagCreateWithoutTagInput[] | ContactTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutTagInput | ContactTagCreateOrConnectWithoutTagInput[]
    upsert?: ContactTagUpsertWithWhereUniqueWithoutTagInput | ContactTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ContactTagCreateManyTagInputEnvelope
    set?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    disconnect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    delete?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    update?: ContactTagUpdateWithWhereUniqueWithoutTagInput | ContactTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ContactTagUpdateManyWithWhereWithoutTagInput | ContactTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ActivityCreateWithoutTagsInput, ActivityUncheckedCreateWithoutTagsInput> | ActivityCreateWithoutTagsInput[] | ActivityUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTagsInput | ActivityCreateOrConnectWithoutTagsInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutTagsInput | ActivityUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutTagsInput | ActivityUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutTagsInput | ActivityUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type DealTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<DealTagCreateWithoutTagInput, DealTagUncheckedCreateWithoutTagInput> | DealTagCreateWithoutTagInput[] | DealTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DealTagCreateOrConnectWithoutTagInput | DealTagCreateOrConnectWithoutTagInput[]
    upsert?: DealTagUpsertWithWhereUniqueWithoutTagInput | DealTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: DealTagCreateManyTagInputEnvelope
    set?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    disconnect?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    delete?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    connect?: DealTagWhereUniqueInput | DealTagWhereUniqueInput[]
    update?: DealTagUpdateWithWhereUniqueWithoutTagInput | DealTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: DealTagUpdateManyWithWhereWithoutTagInput | DealTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: DealTagScalarWhereInput | DealTagScalarWhereInput[]
  }

  export type ContactTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput> | ContactTagCreateWithoutTagInput[] | ContactTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutTagInput | ContactTagCreateOrConnectWithoutTagInput[]
    upsert?: ContactTagUpsertWithWhereUniqueWithoutTagInput | ContactTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ContactTagCreateManyTagInputEnvelope
    set?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    disconnect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    delete?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    update?: ContactTagUpdateWithWhereUniqueWithoutTagInput | ContactTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ContactTagUpdateManyWithWhereWithoutTagInput | ContactTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ActivityCreateWithoutTagsInput, ActivityUncheckedCreateWithoutTagsInput> | ActivityCreateWithoutTagsInput[] | ActivityUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTagsInput | ActivityCreateOrConnectWithoutTagsInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutTagsInput | ActivityUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutTagsInput | ActivityUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutTagsInput | ActivityUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSharedAccessInput = {
    create?: XOR<UserCreateWithoutSharedAccessInput, UserUncheckedCreateWithoutSharedAccessInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedAccessInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSharedAccessNestedInput = {
    create?: XOR<UserCreateWithoutSharedAccessInput, UserUncheckedCreateWithoutSharedAccessInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedAccessInput
    upsert?: UserUpsertWithoutSharedAccessInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedAccessInput, UserUpdateWithoutSharedAccessInput>, UserUncheckedUpdateWithoutSharedAccessInput>
  }

  export type CustomFieldValueCreateNestedManyWithoutFieldInput = {
    create?: XOR<CustomFieldValueCreateWithoutFieldInput, CustomFieldValueUncheckedCreateWithoutFieldInput> | CustomFieldValueCreateWithoutFieldInput[] | CustomFieldValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutFieldInput | CustomFieldValueCreateOrConnectWithoutFieldInput[]
    createMany?: CustomFieldValueCreateManyFieldInputEnvelope
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
  }

  export type CustomFieldValueUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<CustomFieldValueCreateWithoutFieldInput, CustomFieldValueUncheckedCreateWithoutFieldInput> | CustomFieldValueCreateWithoutFieldInput[] | CustomFieldValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutFieldInput | CustomFieldValueCreateOrConnectWithoutFieldInput[]
    createMany?: CustomFieldValueCreateManyFieldInputEnvelope
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
  }

  export type CustomFieldValueUpdateManyWithoutFieldNestedInput = {
    create?: XOR<CustomFieldValueCreateWithoutFieldInput, CustomFieldValueUncheckedCreateWithoutFieldInput> | CustomFieldValueCreateWithoutFieldInput[] | CustomFieldValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutFieldInput | CustomFieldValueCreateOrConnectWithoutFieldInput[]
    upsert?: CustomFieldValueUpsertWithWhereUniqueWithoutFieldInput | CustomFieldValueUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: CustomFieldValueCreateManyFieldInputEnvelope
    set?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    disconnect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    delete?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    update?: CustomFieldValueUpdateWithWhereUniqueWithoutFieldInput | CustomFieldValueUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: CustomFieldValueUpdateManyWithWhereWithoutFieldInput | CustomFieldValueUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: CustomFieldValueScalarWhereInput | CustomFieldValueScalarWhereInput[]
  }

  export type CustomFieldValueUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<CustomFieldValueCreateWithoutFieldInput, CustomFieldValueUncheckedCreateWithoutFieldInput> | CustomFieldValueCreateWithoutFieldInput[] | CustomFieldValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutFieldInput | CustomFieldValueCreateOrConnectWithoutFieldInput[]
    upsert?: CustomFieldValueUpsertWithWhereUniqueWithoutFieldInput | CustomFieldValueUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: CustomFieldValueCreateManyFieldInputEnvelope
    set?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    disconnect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    delete?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    update?: CustomFieldValueUpdateWithWhereUniqueWithoutFieldInput | CustomFieldValueUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: CustomFieldValueUpdateManyWithWhereWithoutFieldInput | CustomFieldValueUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: CustomFieldValueScalarWhereInput | CustomFieldValueScalarWhereInput[]
  }

  export type CustomFieldCreateNestedOneWithoutValuesInput = {
    create?: XOR<CustomFieldCreateWithoutValuesInput, CustomFieldUncheckedCreateWithoutValuesInput>
    connectOrCreate?: CustomFieldCreateOrConnectWithoutValuesInput
    connect?: CustomFieldWhereUniqueInput
  }

  export type CustomFieldUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<CustomFieldCreateWithoutValuesInput, CustomFieldUncheckedCreateWithoutValuesInput>
    connectOrCreate?: CustomFieldCreateOrConnectWithoutValuesInput
    upsert?: CustomFieldUpsertWithoutValuesInput
    connect?: CustomFieldWhereUniqueInput
    update?: XOR<XOR<CustomFieldUpdateToOneWithWhereWithoutValuesInput, CustomFieldUpdateWithoutValuesInput>, CustomFieldUncheckedUpdateWithoutValuesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput
    upsert?: UserUpsertWithoutAuditLogInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogInput, UserUpdateWithoutAuditLogInput>, UserUncheckedUpdateWithoutAuditLogInput>
  }

  export type CommentCreatementionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCommentInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    connect?: UserWhereUniqueInput
  }

  export type FileCreateNestedManyWithoutCommentInput = {
    create?: XOR<FileCreateWithoutCommentInput, FileUncheckedCreateWithoutCommentInput> | FileCreateWithoutCommentInput[] | FileUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: FileCreateOrConnectWithoutCommentInput | FileCreateOrConnectWithoutCommentInput[]
    createMany?: FileCreateManyCommentInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<FileCreateWithoutCommentInput, FileUncheckedCreateWithoutCommentInput> | FileCreateWithoutCommentInput[] | FileUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: FileCreateOrConnectWithoutCommentInput | FileCreateOrConnectWithoutCommentInput[]
    createMany?: FileCreateManyCommentInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type CommentUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    upsert?: UserUpsertWithoutCommentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentInput, UserUpdateWithoutCommentInput>, UserUncheckedUpdateWithoutCommentInput>
  }

  export type FileUpdateManyWithoutCommentNestedInput = {
    create?: XOR<FileCreateWithoutCommentInput, FileUncheckedCreateWithoutCommentInput> | FileCreateWithoutCommentInput[] | FileUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: FileCreateOrConnectWithoutCommentInput | FileCreateOrConnectWithoutCommentInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutCommentInput | FileUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: FileCreateManyCommentInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutCommentInput | FileUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: FileUpdateManyWithWhereWithoutCommentInput | FileUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<FileCreateWithoutCommentInput, FileUncheckedCreateWithoutCommentInput> | FileCreateWithoutCommentInput[] | FileUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: FileCreateOrConnectWithoutCommentInput | FileCreateOrConnectWithoutCommentInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutCommentInput | FileUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: FileCreateManyCommentInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutCommentInput | FileUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: FileUpdateManyWithWhereWithoutCommentInput | FileUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type TeamCreateWithoutUsersInput = {
    id?: string
    name: string
  }

  export type TeamUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
  }

  export type TeamCreateOrConnectWithoutUsersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
  }

  export type AccountCreateWithoutOwnerInput = {
    id?: string
    name: string
    industry?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    createdAt?: Date | string
    Contact?: ContactCreateNestedManyWithoutAccountInput
    Deal?: DealCreateNestedManyWithoutAccountInput
    Activity?: ActivityCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    industry?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    createdAt?: Date | string
    Contact?: ContactUncheckedCreateNestedManyWithoutAccountInput
    Deal?: DealUncheckedCreateNestedManyWithoutAccountInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutOwnerInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutOwnerInput, AccountUncheckedCreateWithoutOwnerInput>
  }

  export type AccountCreateManyOwnerInputEnvelope = {
    data: AccountCreateManyOwnerInput | AccountCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutOwnerInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    createdAt?: Date | string
    account?: AccountCreateNestedOneWithoutContactInput
    Deal?: DealCreateNestedManyWithoutContactInput
    Activity?: ActivityCreateNestedManyWithoutContactInput
    ContactTag?: ContactTagCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutOwnerInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    accountId?: string | null
    createdAt?: Date | string
    Deal?: DealUncheckedCreateNestedManyWithoutContactInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutContactInput
    ContactTag?: ContactTagUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutOwnerInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutOwnerInput, ContactUncheckedCreateWithoutOwnerInput>
  }

  export type ContactCreateManyOwnerInputEnvelope = {
    data: ContactCreateManyOwnerInput | ContactCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutOwnerInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    createdAt?: Date | string
    account?: AccountCreateNestedOneWithoutDealInput
    contact?: ContactCreateNestedOneWithoutDealInput
    Activity?: ActivityCreateNestedManyWithoutDealInput
    DealTag?: DealTagCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutOwnerInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    accountId?: string | null
    contactId?: string | null
    createdAt?: Date | string
    Activity?: ActivityUncheckedCreateNestedManyWithoutDealInput
    DealTag?: DealTagUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutOwnerInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutOwnerInput, DealUncheckedCreateWithoutOwnerInput>
  }

  export type DealCreateManyOwnerInputEnvelope = {
    data: DealCreateManyOwnerInput | DealCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutOwnerInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    createdAt?: Date | string
    account?: AccountCreateNestedOneWithoutActivityInput
    contact?: ContactCreateNestedOneWithoutActivityInput
    deal?: DealCreateNestedOneWithoutActivityInput
    parent?: ActivityCreateNestedOneWithoutSubtasksInput
    subtasks?: ActivityCreateNestedManyWithoutParentInput
    tags?: TagCreateNestedManyWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutOwnerInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    accountId?: string | null
    contactId?: string | null
    dealId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    subtasks?: ActivityUncheckedCreateNestedManyWithoutParentInput
    tags?: TagUncheckedCreateNestedManyWithoutActivitiesInput
  }

  export type ActivityCreateOrConnectWithoutOwnerInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutOwnerInput, ActivityUncheckedCreateWithoutOwnerInput>
  }

  export type ActivityCreateManyOwnerInputEnvelope = {
    data: ActivityCreateManyOwnerInput | ActivityCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type EmailAccountCreateWithoutUserInput = {
    id?: string
    smtpHost: string
    smtpPort: number
    smtpSecure: boolean
    email: string
    password: string
    createdAt?: Date | string
  }

  export type EmailAccountUncheckedCreateWithoutUserInput = {
    id?: string
    smtpHost: string
    smtpPort: number
    smtpSecure: boolean
    email: string
    password: string
    createdAt?: Date | string
  }

  export type EmailAccountCreateOrConnectWithoutUserInput = {
    where: EmailAccountWhereUniqueInput
    create: XOR<EmailAccountCreateWithoutUserInput, EmailAccountUncheckedCreateWithoutUserInput>
  }

  export type EmailAccountCreateManyUserInputEnvelope = {
    data: EmailAccountCreateManyUserInput | EmailAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailTemplateCreateWithoutUserInput = {
    id?: string
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    EmailMessage?: EmailMessageCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutUserInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput>
  }

  export type EmailTemplateCreateManyUserInputEnvelope = {
    data: EmailTemplateCreateManyUserInput | EmailTemplateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailMessageCreateWithoutUserInput = {
    id?: string
    subject: string
    to: string
    body: string
    status: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    template?: EmailTemplateCreateNestedOneWithoutEmailMessageInput
  }

  export type EmailMessageUncheckedCreateWithoutUserInput = {
    id?: string
    subject: string
    to: string
    body: string
    status: string
    templateId?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailMessageCreateOrConnectWithoutUserInput = {
    where: EmailMessageWhereUniqueInput
    create: XOR<EmailMessageCreateWithoutUserInput, EmailMessageUncheckedCreateWithoutUserInput>
  }

  export type EmailMessageCreateManyUserInputEnvelope = {
    data: EmailMessageCreateManyUserInput | EmailMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailInboxMessageCreateWithoutUserInput = {
    id?: string
    from: string
    to: string
    subject: string
    text?: string | null
    html?: string | null
    date: Date | string
    folder: string
    messageId: string
    seen?: boolean
    flagged?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailInboxMessageUncheckedCreateWithoutUserInput = {
    id?: string
    from: string
    to: string
    subject: string
    text?: string | null
    html?: string | null
    date: Date | string
    folder: string
    messageId: string
    seen?: boolean
    flagged?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailInboxMessageCreateOrConnectWithoutUserInput = {
    where: EmailInboxMessageWhereUniqueInput
    create: XOR<EmailInboxMessageCreateWithoutUserInput, EmailInboxMessageUncheckedCreateWithoutUserInput>
  }

  export type EmailInboxMessageCreateManyUserInputEnvelope = {
    data: EmailInboxMessageCreateManyUserInput | EmailInboxMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailContactCreateWithoutUserInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    company?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type EmailContactUncheckedCreateWithoutUserInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    company?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type EmailContactCreateOrConnectWithoutUserInput = {
    where: EmailContactWhereUniqueInput
    create: XOR<EmailContactCreateWithoutUserInput, EmailContactUncheckedCreateWithoutUserInput>
  }

  export type EmailContactCreateManyUserInputEnvelope = {
    data: EmailContactCreateManyUserInput | EmailContactCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentTemplateCreateWithoutUserInput = {
    id?: string
    name: string
    content: string
    format: string
    createdAt?: Date | string
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutTemplateInput
  }

  export type DocumentTemplateUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    content: string
    format: string
    createdAt?: Date | string
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type DocumentTemplateCreateOrConnectWithoutUserInput = {
    where: DocumentTemplateWhereUniqueInput
    create: XOR<DocumentTemplateCreateWithoutUserInput, DocumentTemplateUncheckedCreateWithoutUserInput>
  }

  export type DocumentTemplateCreateManyUserInputEnvelope = {
    data: DocumentTemplateCreateManyUserInput | DocumentTemplateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedDocumentCreateWithoutUserInput = {
    id?: string
    filePath: string
    format: string
    createdAt?: Date | string
    template: DocumentTemplateCreateNestedOneWithoutGeneratedDocumentInput
  }

  export type GeneratedDocumentUncheckedCreateWithoutUserInput = {
    id?: string
    filePath: string
    format: string
    templateId: string
    createdAt?: Date | string
  }

  export type GeneratedDocumentCreateOrConnectWithoutUserInput = {
    where: GeneratedDocumentWhereUniqueInput
    create: XOR<GeneratedDocumentCreateWithoutUserInput, GeneratedDocumentUncheckedCreateWithoutUserInput>
  }

  export type GeneratedDocumentCreateManyUserInputEnvelope = {
    data: GeneratedDocumentCreateManyUserInput | GeneratedDocumentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FileFolderCreateWithoutUserInput = {
    id?: string
    name: string
    parentId?: string | null
    access: string
    createdAt?: Date | string
    accountId?: string | null
    dealId?: string | null
    files?: FileCreateNestedManyWithoutFolderInput
  }

  export type FileFolderUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    parentId?: string | null
    access: string
    createdAt?: Date | string
    accountId?: string | null
    dealId?: string | null
    files?: FileUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FileFolderCreateOrConnectWithoutUserInput = {
    where: FileFolderWhereUniqueInput
    create: XOR<FileFolderCreateWithoutUserInput, FileFolderUncheckedCreateWithoutUserInput>
  }

  export type FileFolderCreateManyUserInputEnvelope = {
    data: FileFolderCreateManyUserInput | FileFolderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutUserInput = {
    id?: string
    name: string
    path: string
    size: number
    mimeType: string
    dealId?: string | null
    contactId?: string | null
    taskId?: string | null
    publicLink?: string | null
    expiresAt?: Date | string | null
    access: string
    createdAt?: Date | string
    folder?: FileFolderCreateNestedOneWithoutFilesInput
    comment?: CommentCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    path: string
    size: number
    mimeType: string
    folderId?: string | null
    dealId?: string | null
    contactId?: string | null
    taskId?: string | null
    publicLink?: string | null
    expiresAt?: Date | string | null
    access: string
    createdAt?: Date | string
    commentId?: string | null
  }

  export type FileCreateOrConnectWithoutUserInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput>
  }

  export type FileCreateManyUserInputEnvelope = {
    data: FileCreateManyUserInput | FileCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SharedAccessCreateWithoutUserInput = {
    id?: string
    entityId: string
    entity: string
    canEdit?: boolean
    createdAt?: Date | string
  }

  export type SharedAccessUncheckedCreateWithoutUserInput = {
    id?: string
    entityId: string
    entity: string
    canEdit?: boolean
    createdAt?: Date | string
  }

  export type SharedAccessCreateOrConnectWithoutUserInput = {
    where: SharedAccessWhereUniqueInput
    create: XOR<SharedAccessCreateWithoutUserInput, SharedAccessUncheckedCreateWithoutUserInput>
  }

  export type SharedAccessCreateManyUserInputEnvelope = {
    data: SharedAccessCreateManyUserInput | SharedAccessCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    entity: string
    entityId: string
    text: string
    mentions?: CommentCreatementionsInput | string[]
    createdAt?: Date | string
    files?: FileCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    entity: string
    entityId: string
    text: string
    mentions?: CommentCreatementionsInput | string[]
    createdAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TeamUpsertWithoutUsersInput = {
    update: XOR<TeamUpdateWithoutUsersInput, TeamUncheckedUpdateWithoutUsersInput>
    create: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutUsersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutUsersInput, TeamUncheckedUpdateWithoutUsersInput>
  }

  export type TeamUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TeamUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUpsertWithWhereUniqueWithoutOwnerInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutOwnerInput, AccountUncheckedUpdateWithoutOwnerInput>
    create: XOR<AccountCreateWithoutOwnerInput, AccountUncheckedCreateWithoutOwnerInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutOwnerInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutOwnerInput, AccountUncheckedUpdateWithoutOwnerInput>
  }

  export type AccountUpdateManyWithWhereWithoutOwnerInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutOwnerInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    industry?: StringNullableFilter<"Account"> | string | null
    phone?: StringNullableFilter<"Account"> | string | null
    email?: StringNullableFilter<"Account"> | string | null
    website?: StringNullableFilter<"Account"> | string | null
    address?: StringNullableFilter<"Account"> | string | null
    ownerId?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutOwnerInput, ContactUncheckedUpdateWithoutOwnerInput>
    create: XOR<ContactCreateWithoutOwnerInput, ContactUncheckedCreateWithoutOwnerInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutOwnerInput, ContactUncheckedUpdateWithoutOwnerInput>
  }

  export type ContactUpdateManyWithWhereWithoutOwnerInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    firstName?: StringFilter<"Contact"> | string
    lastName?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    position?: StringNullableFilter<"Contact"> | string | null
    ownerId?: StringFilter<"Contact"> | string
    accountId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type DealUpsertWithWhereUniqueWithoutOwnerInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutOwnerInput, DealUncheckedUpdateWithoutOwnerInput>
    create: XOR<DealCreateWithoutOwnerInput, DealUncheckedCreateWithoutOwnerInput>
  }

  export type DealUpdateWithWhereUniqueWithoutOwnerInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutOwnerInput, DealUncheckedUpdateWithoutOwnerInput>
  }

  export type DealUpdateManyWithWhereWithoutOwnerInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutOwnerInput>
  }

  export type DealScalarWhereInput = {
    AND?: DealScalarWhereInput | DealScalarWhereInput[]
    OR?: DealScalarWhereInput[]
    NOT?: DealScalarWhereInput | DealScalarWhereInput[]
    id?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    amount?: FloatFilter<"Deal"> | number
    stage?: StringFilter<"Deal"> | string
    probability?: IntFilter<"Deal"> | number
    closeDate?: DateTimeFilter<"Deal"> | Date | string
    accountId?: StringNullableFilter<"Deal"> | string | null
    contactId?: StringNullableFilter<"Deal"> | string | null
    ownerId?: StringFilter<"Deal"> | string
    createdAt?: DateTimeFilter<"Deal"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutOwnerInput, ActivityUncheckedUpdateWithoutOwnerInput>
    create: XOR<ActivityCreateWithoutOwnerInput, ActivityUncheckedCreateWithoutOwnerInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutOwnerInput, ActivityUncheckedUpdateWithoutOwnerInput>
  }

  export type ActivityUpdateManyWithWhereWithoutOwnerInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    type?: StringFilter<"Activity"> | string
    status?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    date?: DateTimeFilter<"Activity"> | Date | string
    ownerId?: StringFilter<"Activity"> | string
    accountId?: StringNullableFilter<"Activity"> | string | null
    contactId?: StringNullableFilter<"Activity"> | string | null
    dealId?: StringNullableFilter<"Activity"> | string | null
    parentId?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type EmailAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailAccountWhereUniqueInput
    update: XOR<EmailAccountUpdateWithoutUserInput, EmailAccountUncheckedUpdateWithoutUserInput>
    create: XOR<EmailAccountCreateWithoutUserInput, EmailAccountUncheckedCreateWithoutUserInput>
  }

  export type EmailAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailAccountWhereUniqueInput
    data: XOR<EmailAccountUpdateWithoutUserInput, EmailAccountUncheckedUpdateWithoutUserInput>
  }

  export type EmailAccountUpdateManyWithWhereWithoutUserInput = {
    where: EmailAccountScalarWhereInput
    data: XOR<EmailAccountUpdateManyMutationInput, EmailAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailAccountScalarWhereInput = {
    AND?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
    OR?: EmailAccountScalarWhereInput[]
    NOT?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
    id?: StringFilter<"EmailAccount"> | string
    userId?: StringFilter<"EmailAccount"> | string
    smtpHost?: StringFilter<"EmailAccount"> | string
    smtpPort?: IntFilter<"EmailAccount"> | number
    smtpSecure?: BoolFilter<"EmailAccount"> | boolean
    email?: StringFilter<"EmailAccount"> | string
    password?: StringFilter<"EmailAccount"> | string
    createdAt?: DateTimeFilter<"EmailAccount"> | Date | string
  }

  export type EmailTemplateUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailTemplateWhereUniqueInput
    update: XOR<EmailTemplateUpdateWithoutUserInput, EmailTemplateUncheckedUpdateWithoutUserInput>
    create: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput>
  }

  export type EmailTemplateUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailTemplateWhereUniqueInput
    data: XOR<EmailTemplateUpdateWithoutUserInput, EmailTemplateUncheckedUpdateWithoutUserInput>
  }

  export type EmailTemplateUpdateManyWithWhereWithoutUserInput = {
    where: EmailTemplateScalarWhereInput
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailTemplateScalarWhereInput = {
    AND?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
    OR?: EmailTemplateScalarWhereInput[]
    NOT?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    body?: StringFilter<"EmailTemplate"> | string
    userId?: StringFilter<"EmailTemplate"> | string
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
  }

  export type EmailMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailMessageWhereUniqueInput
    update: XOR<EmailMessageUpdateWithoutUserInput, EmailMessageUncheckedUpdateWithoutUserInput>
    create: XOR<EmailMessageCreateWithoutUserInput, EmailMessageUncheckedCreateWithoutUserInput>
  }

  export type EmailMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailMessageWhereUniqueInput
    data: XOR<EmailMessageUpdateWithoutUserInput, EmailMessageUncheckedUpdateWithoutUserInput>
  }

  export type EmailMessageUpdateManyWithWhereWithoutUserInput = {
    where: EmailMessageScalarWhereInput
    data: XOR<EmailMessageUpdateManyMutationInput, EmailMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailMessageScalarWhereInput = {
    AND?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
    OR?: EmailMessageScalarWhereInput[]
    NOT?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
    id?: StringFilter<"EmailMessage"> | string
    subject?: StringFilter<"EmailMessage"> | string
    to?: StringFilter<"EmailMessage"> | string
    body?: StringFilter<"EmailMessage"> | string
    status?: StringFilter<"EmailMessage"> | string
    userId?: StringFilter<"EmailMessage"> | string
    templateId?: StringNullableFilter<"EmailMessage"> | string | null
    attachments?: JsonNullableFilter<"EmailMessage">
    createdAt?: DateTimeFilter<"EmailMessage"> | Date | string
  }

  export type EmailInboxMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailInboxMessageWhereUniqueInput
    update: XOR<EmailInboxMessageUpdateWithoutUserInput, EmailInboxMessageUncheckedUpdateWithoutUserInput>
    create: XOR<EmailInboxMessageCreateWithoutUserInput, EmailInboxMessageUncheckedCreateWithoutUserInput>
  }

  export type EmailInboxMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailInboxMessageWhereUniqueInput
    data: XOR<EmailInboxMessageUpdateWithoutUserInput, EmailInboxMessageUncheckedUpdateWithoutUserInput>
  }

  export type EmailInboxMessageUpdateManyWithWhereWithoutUserInput = {
    where: EmailInboxMessageScalarWhereInput
    data: XOR<EmailInboxMessageUpdateManyMutationInput, EmailInboxMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailInboxMessageScalarWhereInput = {
    AND?: EmailInboxMessageScalarWhereInput | EmailInboxMessageScalarWhereInput[]
    OR?: EmailInboxMessageScalarWhereInput[]
    NOT?: EmailInboxMessageScalarWhereInput | EmailInboxMessageScalarWhereInput[]
    id?: StringFilter<"EmailInboxMessage"> | string
    userId?: StringFilter<"EmailInboxMessage"> | string
    from?: StringFilter<"EmailInboxMessage"> | string
    to?: StringFilter<"EmailInboxMessage"> | string
    subject?: StringFilter<"EmailInboxMessage"> | string
    text?: StringNullableFilter<"EmailInboxMessage"> | string | null
    html?: StringNullableFilter<"EmailInboxMessage"> | string | null
    date?: DateTimeFilter<"EmailInboxMessage"> | Date | string
    folder?: StringFilter<"EmailInboxMessage"> | string
    messageId?: StringFilter<"EmailInboxMessage"> | string
    seen?: BoolFilter<"EmailInboxMessage"> | boolean
    flagged?: BoolFilter<"EmailInboxMessage"> | boolean
    attachments?: JsonNullableFilter<"EmailInboxMessage">
    createdAt?: DateTimeFilter<"EmailInboxMessage"> | Date | string
  }

  export type EmailContactUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailContactWhereUniqueInput
    update: XOR<EmailContactUpdateWithoutUserInput, EmailContactUncheckedUpdateWithoutUserInput>
    create: XOR<EmailContactCreateWithoutUserInput, EmailContactUncheckedCreateWithoutUserInput>
  }

  export type EmailContactUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailContactWhereUniqueInput
    data: XOR<EmailContactUpdateWithoutUserInput, EmailContactUncheckedUpdateWithoutUserInput>
  }

  export type EmailContactUpdateManyWithWhereWithoutUserInput = {
    where: EmailContactScalarWhereInput
    data: XOR<EmailContactUpdateManyMutationInput, EmailContactUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailContactScalarWhereInput = {
    AND?: EmailContactScalarWhereInput | EmailContactScalarWhereInput[]
    OR?: EmailContactScalarWhereInput[]
    NOT?: EmailContactScalarWhereInput | EmailContactScalarWhereInput[]
    id?: StringFilter<"EmailContact"> | string
    userId?: StringFilter<"EmailContact"> | string
    email?: StringFilter<"EmailContact"> | string
    name?: StringNullableFilter<"EmailContact"> | string | null
    phone?: StringNullableFilter<"EmailContact"> | string | null
    company?: StringNullableFilter<"EmailContact"> | string | null
    notes?: StringNullableFilter<"EmailContact"> | string | null
    createdAt?: DateTimeFilter<"EmailContact"> | Date | string
  }

  export type DocumentTemplateUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentTemplateWhereUniqueInput
    update: XOR<DocumentTemplateUpdateWithoutUserInput, DocumentTemplateUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentTemplateCreateWithoutUserInput, DocumentTemplateUncheckedCreateWithoutUserInput>
  }

  export type DocumentTemplateUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentTemplateWhereUniqueInput
    data: XOR<DocumentTemplateUpdateWithoutUserInput, DocumentTemplateUncheckedUpdateWithoutUserInput>
  }

  export type DocumentTemplateUpdateManyWithWhereWithoutUserInput = {
    where: DocumentTemplateScalarWhereInput
    data: XOR<DocumentTemplateUpdateManyMutationInput, DocumentTemplateUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentTemplateScalarWhereInput = {
    AND?: DocumentTemplateScalarWhereInput | DocumentTemplateScalarWhereInput[]
    OR?: DocumentTemplateScalarWhereInput[]
    NOT?: DocumentTemplateScalarWhereInput | DocumentTemplateScalarWhereInput[]
    id?: StringFilter<"DocumentTemplate"> | string
    name?: StringFilter<"DocumentTemplate"> | string
    content?: StringFilter<"DocumentTemplate"> | string
    format?: StringFilter<"DocumentTemplate"> | string
    userId?: StringFilter<"DocumentTemplate"> | string
    createdAt?: DateTimeFilter<"DocumentTemplate"> | Date | string
  }

  export type GeneratedDocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: GeneratedDocumentWhereUniqueInput
    update: XOR<GeneratedDocumentUpdateWithoutUserInput, GeneratedDocumentUncheckedUpdateWithoutUserInput>
    create: XOR<GeneratedDocumentCreateWithoutUserInput, GeneratedDocumentUncheckedCreateWithoutUserInput>
  }

  export type GeneratedDocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: GeneratedDocumentWhereUniqueInput
    data: XOR<GeneratedDocumentUpdateWithoutUserInput, GeneratedDocumentUncheckedUpdateWithoutUserInput>
  }

  export type GeneratedDocumentUpdateManyWithWhereWithoutUserInput = {
    where: GeneratedDocumentScalarWhereInput
    data: XOR<GeneratedDocumentUpdateManyMutationInput, GeneratedDocumentUncheckedUpdateManyWithoutUserInput>
  }

  export type GeneratedDocumentScalarWhereInput = {
    AND?: GeneratedDocumentScalarWhereInput | GeneratedDocumentScalarWhereInput[]
    OR?: GeneratedDocumentScalarWhereInput[]
    NOT?: GeneratedDocumentScalarWhereInput | GeneratedDocumentScalarWhereInput[]
    id?: StringFilter<"GeneratedDocument"> | string
    filePath?: StringFilter<"GeneratedDocument"> | string
    format?: StringFilter<"GeneratedDocument"> | string
    templateId?: StringFilter<"GeneratedDocument"> | string
    userId?: StringFilter<"GeneratedDocument"> | string
    createdAt?: DateTimeFilter<"GeneratedDocument"> | Date | string
  }

  export type FileFolderUpsertWithWhereUniqueWithoutUserInput = {
    where: FileFolderWhereUniqueInput
    update: XOR<FileFolderUpdateWithoutUserInput, FileFolderUncheckedUpdateWithoutUserInput>
    create: XOR<FileFolderCreateWithoutUserInput, FileFolderUncheckedCreateWithoutUserInput>
  }

  export type FileFolderUpdateWithWhereUniqueWithoutUserInput = {
    where: FileFolderWhereUniqueInput
    data: XOR<FileFolderUpdateWithoutUserInput, FileFolderUncheckedUpdateWithoutUserInput>
  }

  export type FileFolderUpdateManyWithWhereWithoutUserInput = {
    where: FileFolderScalarWhereInput
    data: XOR<FileFolderUpdateManyMutationInput, FileFolderUncheckedUpdateManyWithoutUserInput>
  }

  export type FileFolderScalarWhereInput = {
    AND?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
    OR?: FileFolderScalarWhereInput[]
    NOT?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
    id?: StringFilter<"FileFolder"> | string
    name?: StringFilter<"FileFolder"> | string
    parentId?: StringNullableFilter<"FileFolder"> | string | null
    userId?: StringFilter<"FileFolder"> | string
    access?: StringFilter<"FileFolder"> | string
    createdAt?: DateTimeFilter<"FileFolder"> | Date | string
    accountId?: StringNullableFilter<"FileFolder"> | string | null
    dealId?: StringNullableFilter<"FileFolder"> | string | null
  }

  export type FileUpsertWithWhereUniqueWithoutUserInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutUserInput, FileUncheckedUpdateWithoutUserInput>
    create: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput>
  }

  export type FileUpdateWithWhereUniqueWithoutUserInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutUserInput, FileUncheckedUpdateWithoutUserInput>
  }

  export type FileUpdateManyWithWhereWithoutUserInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutUserInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    name?: StringFilter<"File"> | string
    path?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    mimeType?: StringFilter<"File"> | string
    userId?: StringFilter<"File"> | string
    folderId?: StringNullableFilter<"File"> | string | null
    dealId?: StringNullableFilter<"File"> | string | null
    contactId?: StringNullableFilter<"File"> | string | null
    taskId?: StringNullableFilter<"File"> | string | null
    publicLink?: StringNullableFilter<"File"> | string | null
    expiresAt?: DateTimeNullableFilter<"File"> | Date | string | null
    access?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    commentId?: StringNullableFilter<"File"> | string | null
  }

  export type SharedAccessUpsertWithWhereUniqueWithoutUserInput = {
    where: SharedAccessWhereUniqueInput
    update: XOR<SharedAccessUpdateWithoutUserInput, SharedAccessUncheckedUpdateWithoutUserInput>
    create: XOR<SharedAccessCreateWithoutUserInput, SharedAccessUncheckedCreateWithoutUserInput>
  }

  export type SharedAccessUpdateWithWhereUniqueWithoutUserInput = {
    where: SharedAccessWhereUniqueInput
    data: XOR<SharedAccessUpdateWithoutUserInput, SharedAccessUncheckedUpdateWithoutUserInput>
  }

  export type SharedAccessUpdateManyWithWhereWithoutUserInput = {
    where: SharedAccessScalarWhereInput
    data: XOR<SharedAccessUpdateManyMutationInput, SharedAccessUncheckedUpdateManyWithoutUserInput>
  }

  export type SharedAccessScalarWhereInput = {
    AND?: SharedAccessScalarWhereInput | SharedAccessScalarWhereInput[]
    OR?: SharedAccessScalarWhereInput[]
    NOT?: SharedAccessScalarWhereInput | SharedAccessScalarWhereInput[]
    id?: StringFilter<"SharedAccess"> | string
    userId?: StringFilter<"SharedAccess"> | string
    entityId?: StringFilter<"SharedAccess"> | string
    entity?: StringFilter<"SharedAccess"> | string
    canEdit?: BoolFilter<"SharedAccess"> | boolean
    createdAt?: DateTimeFilter<"SharedAccess"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    entity?: StringFilter<"Comment"> | string
    entityId?: StringFilter<"Comment"> | string
    text?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    mentions?: StringNullableListFilter<"Comment">
    createdAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    telegramId?: StringNullableFilter<"User"> | string | null
    notificationsEnabled?: BoolFilter<"User"> | boolean
    roleId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    teamId?: StringNullableFilter<"User"> | string | null
  }

  export type UserCreateWithoutTeamInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
  }

  export type UserCreateManyTeamInputEnvelope = {
    data: UserCreateManyTeamInput | UserCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTeamInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTeamInput, UserUncheckedUpdateWithoutTeamInput>
    create: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTeamInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTeamInput, UserUncheckedUpdateWithoutTeamInput>
  }

  export type UserUpdateManyWithWhereWithoutTeamInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTeamInput>
  }

  export type UserCreateWithoutAccountInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
  }

  export type ContactCreateWithoutAccountInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutContactInput
    Deal?: DealCreateNestedManyWithoutContactInput
    Activity?: ActivityCreateNestedManyWithoutContactInput
    ContactTag?: ContactTagCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutAccountInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    ownerId: string
    createdAt?: Date | string
    Deal?: DealUncheckedCreateNestedManyWithoutContactInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutContactInput
    ContactTag?: ContactTagUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutAccountInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutAccountInput, ContactUncheckedCreateWithoutAccountInput>
  }

  export type ContactCreateManyAccountInputEnvelope = {
    data: ContactCreateManyAccountInput | ContactCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutAccountInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    createdAt?: Date | string
    contact?: ContactCreateNestedOneWithoutDealInput
    owner: UserCreateNestedOneWithoutDealInput
    Activity?: ActivityCreateNestedManyWithoutDealInput
    DealTag?: DealTagCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutAccountInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    contactId?: string | null
    ownerId: string
    createdAt?: Date | string
    Activity?: ActivityUncheckedCreateNestedManyWithoutDealInput
    DealTag?: DealTagUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutAccountInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutAccountInput, DealUncheckedCreateWithoutAccountInput>
  }

  export type DealCreateManyAccountInputEnvelope = {
    data: DealCreateManyAccountInput | DealCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutAccountInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutActivityInput
    contact?: ContactCreateNestedOneWithoutActivityInput
    deal?: DealCreateNestedOneWithoutActivityInput
    parent?: ActivityCreateNestedOneWithoutSubtasksInput
    subtasks?: ActivityCreateNestedManyWithoutParentInput
    tags?: TagCreateNestedManyWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutAccountInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    ownerId: string
    contactId?: string | null
    dealId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    subtasks?: ActivityUncheckedCreateNestedManyWithoutParentInput
    tags?: TagUncheckedCreateNestedManyWithoutActivitiesInput
  }

  export type ActivityCreateOrConnectWithoutAccountInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutAccountInput, ActivityUncheckedCreateWithoutAccountInput>
  }

  export type ActivityCreateManyAccountInputEnvelope = {
    data: ActivityCreateManyAccountInput | ActivityCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAccountInput = {
    update: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
  }

  export type UserUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContactUpsertWithWhereUniqueWithoutAccountInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutAccountInput, ContactUncheckedUpdateWithoutAccountInput>
    create: XOR<ContactCreateWithoutAccountInput, ContactUncheckedCreateWithoutAccountInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutAccountInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutAccountInput, ContactUncheckedUpdateWithoutAccountInput>
  }

  export type ContactUpdateManyWithWhereWithoutAccountInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutAccountInput>
  }

  export type DealUpsertWithWhereUniqueWithoutAccountInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutAccountInput, DealUncheckedUpdateWithoutAccountInput>
    create: XOR<DealCreateWithoutAccountInput, DealUncheckedCreateWithoutAccountInput>
  }

  export type DealUpdateWithWhereUniqueWithoutAccountInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutAccountInput, DealUncheckedUpdateWithoutAccountInput>
  }

  export type DealUpdateManyWithWhereWithoutAccountInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutAccountInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutAccountInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutAccountInput, ActivityUncheckedUpdateWithoutAccountInput>
    create: XOR<ActivityCreateWithoutAccountInput, ActivityUncheckedCreateWithoutAccountInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutAccountInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutAccountInput, ActivityUncheckedUpdateWithoutAccountInput>
  }

  export type ActivityUpdateManyWithWhereWithoutAccountInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutAccountInput>
  }

  export type UserCreateWithoutContactInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContactInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContactInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactInput, UserUncheckedCreateWithoutContactInput>
  }

  export type AccountCreateWithoutContactInput = {
    id?: string
    name: string
    industry?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutAccountInput
    Deal?: DealCreateNestedManyWithoutAccountInput
    Activity?: ActivityCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutContactInput = {
    id?: string
    name: string
    industry?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    ownerId: string
    createdAt?: Date | string
    Deal?: DealUncheckedCreateNestedManyWithoutAccountInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutContactInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutContactInput, AccountUncheckedCreateWithoutContactInput>
  }

  export type DealCreateWithoutContactInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    createdAt?: Date | string
    account?: AccountCreateNestedOneWithoutDealInput
    owner: UserCreateNestedOneWithoutDealInput
    Activity?: ActivityCreateNestedManyWithoutDealInput
    DealTag?: DealTagCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutContactInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    accountId?: string | null
    ownerId: string
    createdAt?: Date | string
    Activity?: ActivityUncheckedCreateNestedManyWithoutDealInput
    DealTag?: DealTagUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutContactInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutContactInput, DealUncheckedCreateWithoutContactInput>
  }

  export type DealCreateManyContactInputEnvelope = {
    data: DealCreateManyContactInput | DealCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutContactInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutActivityInput
    account?: AccountCreateNestedOneWithoutActivityInput
    deal?: DealCreateNestedOneWithoutActivityInput
    parent?: ActivityCreateNestedOneWithoutSubtasksInput
    subtasks?: ActivityCreateNestedManyWithoutParentInput
    tags?: TagCreateNestedManyWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutContactInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    ownerId: string
    accountId?: string | null
    dealId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    subtasks?: ActivityUncheckedCreateNestedManyWithoutParentInput
    tags?: TagUncheckedCreateNestedManyWithoutActivitiesInput
  }

  export type ActivityCreateOrConnectWithoutContactInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput>
  }

  export type ActivityCreateManyContactInputEnvelope = {
    data: ActivityCreateManyContactInput | ActivityCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ContactTagCreateWithoutContactInput = {
    tag: TagCreateNestedOneWithoutContactTagsInput
  }

  export type ContactTagUncheckedCreateWithoutContactInput = {
    tagId: string
  }

  export type ContactTagCreateOrConnectWithoutContactInput = {
    where: ContactTagWhereUniqueInput
    create: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput>
  }

  export type ContactTagCreateManyContactInputEnvelope = {
    data: ContactTagCreateManyContactInput | ContactTagCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutContactInput = {
    update: XOR<UserUpdateWithoutContactInput, UserUncheckedUpdateWithoutContactInput>
    create: XOR<UserCreateWithoutContactInput, UserUncheckedCreateWithoutContactInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactInput, UserUncheckedUpdateWithoutContactInput>
  }

  export type UserUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountUpsertWithoutContactInput = {
    update: XOR<AccountUpdateWithoutContactInput, AccountUncheckedUpdateWithoutContactInput>
    create: XOR<AccountCreateWithoutContactInput, AccountUncheckedCreateWithoutContactInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutContactInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutContactInput, AccountUncheckedUpdateWithoutContactInput>
  }

  export type AccountUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutAccountNestedInput
    Deal?: DealUpdateManyWithoutAccountNestedInput
    Activity?: ActivityUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Deal?: DealUncheckedUpdateManyWithoutAccountNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type DealUpsertWithWhereUniqueWithoutContactInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutContactInput, DealUncheckedUpdateWithoutContactInput>
    create: XOR<DealCreateWithoutContactInput, DealUncheckedCreateWithoutContactInput>
  }

  export type DealUpdateWithWhereUniqueWithoutContactInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutContactInput, DealUncheckedUpdateWithoutContactInput>
  }

  export type DealUpdateManyWithWhereWithoutContactInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutContactInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutContactInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutContactInput, ActivityUncheckedUpdateWithoutContactInput>
    create: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutContactInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutContactInput, ActivityUncheckedUpdateWithoutContactInput>
  }

  export type ActivityUpdateManyWithWhereWithoutContactInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactTagUpsertWithWhereUniqueWithoutContactInput = {
    where: ContactTagWhereUniqueInput
    update: XOR<ContactTagUpdateWithoutContactInput, ContactTagUncheckedUpdateWithoutContactInput>
    create: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput>
  }

  export type ContactTagUpdateWithWhereUniqueWithoutContactInput = {
    where: ContactTagWhereUniqueInput
    data: XOR<ContactTagUpdateWithoutContactInput, ContactTagUncheckedUpdateWithoutContactInput>
  }

  export type ContactTagUpdateManyWithWhereWithoutContactInput = {
    where: ContactTagScalarWhereInput
    data: XOR<ContactTagUpdateManyMutationInput, ContactTagUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactTagScalarWhereInput = {
    AND?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
    OR?: ContactTagScalarWhereInput[]
    NOT?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
    contactId?: StringFilter<"ContactTag"> | string
    tagId?: StringFilter<"ContactTag"> | string
  }

  export type AccountCreateWithoutDealInput = {
    id?: string
    name: string
    industry?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutAccountInput
    Contact?: ContactCreateNestedManyWithoutAccountInput
    Activity?: ActivityCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutDealInput = {
    id?: string
    name: string
    industry?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    ownerId: string
    createdAt?: Date | string
    Contact?: ContactUncheckedCreateNestedManyWithoutAccountInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutDealInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutDealInput, AccountUncheckedCreateWithoutDealInput>
  }

  export type ContactCreateWithoutDealInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutContactInput
    account?: AccountCreateNestedOneWithoutContactInput
    Activity?: ActivityCreateNestedManyWithoutContactInput
    ContactTag?: ContactTagCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutDealInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    ownerId: string
    accountId?: string | null
    createdAt?: Date | string
    Activity?: ActivityUncheckedCreateNestedManyWithoutContactInput
    ContactTag?: ContactTagUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutDealInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutDealInput, ContactUncheckedCreateWithoutDealInput>
  }

  export type UserCreateWithoutDealInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDealInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDealInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDealInput, UserUncheckedCreateWithoutDealInput>
  }

  export type ActivityCreateWithoutDealInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutActivityInput
    account?: AccountCreateNestedOneWithoutActivityInput
    contact?: ContactCreateNestedOneWithoutActivityInput
    parent?: ActivityCreateNestedOneWithoutSubtasksInput
    subtasks?: ActivityCreateNestedManyWithoutParentInput
    tags?: TagCreateNestedManyWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutDealInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    ownerId: string
    accountId?: string | null
    contactId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    subtasks?: ActivityUncheckedCreateNestedManyWithoutParentInput
    tags?: TagUncheckedCreateNestedManyWithoutActivitiesInput
  }

  export type ActivityCreateOrConnectWithoutDealInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput>
  }

  export type ActivityCreateManyDealInputEnvelope = {
    data: ActivityCreateManyDealInput | ActivityCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type DealTagCreateWithoutDealInput = {
    tag: TagCreateNestedOneWithoutDealTagsInput
  }

  export type DealTagUncheckedCreateWithoutDealInput = {
    tagId: string
  }

  export type DealTagCreateOrConnectWithoutDealInput = {
    where: DealTagWhereUniqueInput
    create: XOR<DealTagCreateWithoutDealInput, DealTagUncheckedCreateWithoutDealInput>
  }

  export type DealTagCreateManyDealInputEnvelope = {
    data: DealTagCreateManyDealInput | DealTagCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutDealInput = {
    update: XOR<AccountUpdateWithoutDealInput, AccountUncheckedUpdateWithoutDealInput>
    create: XOR<AccountCreateWithoutDealInput, AccountUncheckedCreateWithoutDealInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutDealInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutDealInput, AccountUncheckedUpdateWithoutDealInput>
  }

  export type AccountUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutAccountNestedInput
    Contact?: ContactUpdateManyWithoutAccountNestedInput
    Activity?: ActivityUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ContactUpsertWithoutDealInput = {
    update: XOR<ContactUpdateWithoutDealInput, ContactUncheckedUpdateWithoutDealInput>
    create: XOR<ContactCreateWithoutDealInput, ContactUncheckedCreateWithoutDealInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutDealInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutDealInput, ContactUncheckedUpdateWithoutDealInput>
  }

  export type ContactUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutContactNestedInput
    account?: AccountUpdateOneWithoutContactNestedInput
    Activity?: ActivityUpdateManyWithoutContactNestedInput
    ContactTag?: ContactTagUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Activity?: ActivityUncheckedUpdateManyWithoutContactNestedInput
    ContactTag?: ContactTagUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserUpsertWithoutDealInput = {
    update: XOR<UserUpdateWithoutDealInput, UserUncheckedUpdateWithoutDealInput>
    create: XOR<UserCreateWithoutDealInput, UserUncheckedCreateWithoutDealInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDealInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDealInput, UserUncheckedUpdateWithoutDealInput>
  }

  export type UserUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ActivityUpsertWithWhereUniqueWithoutDealInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutDealInput, ActivityUncheckedUpdateWithoutDealInput>
    create: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutDealInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutDealInput, ActivityUncheckedUpdateWithoutDealInput>
  }

  export type ActivityUpdateManyWithWhereWithoutDealInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutDealInput>
  }

  export type DealTagUpsertWithWhereUniqueWithoutDealInput = {
    where: DealTagWhereUniqueInput
    update: XOR<DealTagUpdateWithoutDealInput, DealTagUncheckedUpdateWithoutDealInput>
    create: XOR<DealTagCreateWithoutDealInput, DealTagUncheckedCreateWithoutDealInput>
  }

  export type DealTagUpdateWithWhereUniqueWithoutDealInput = {
    where: DealTagWhereUniqueInput
    data: XOR<DealTagUpdateWithoutDealInput, DealTagUncheckedUpdateWithoutDealInput>
  }

  export type DealTagUpdateManyWithWhereWithoutDealInput = {
    where: DealTagScalarWhereInput
    data: XOR<DealTagUpdateManyMutationInput, DealTagUncheckedUpdateManyWithoutDealInput>
  }

  export type DealTagScalarWhereInput = {
    AND?: DealTagScalarWhereInput | DealTagScalarWhereInput[]
    OR?: DealTagScalarWhereInput[]
    NOT?: DealTagScalarWhereInput | DealTagScalarWhereInput[]
    dealId?: StringFilter<"DealTag"> | string
    tagId?: StringFilter<"DealTag"> | string
  }

  export type UserCreateWithoutActivityInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityInput, UserUncheckedCreateWithoutActivityInput>
  }

  export type AccountCreateWithoutActivityInput = {
    id?: string
    name: string
    industry?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutAccountInput
    Contact?: ContactCreateNestedManyWithoutAccountInput
    Deal?: DealCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutActivityInput = {
    id?: string
    name: string
    industry?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    ownerId: string
    createdAt?: Date | string
    Contact?: ContactUncheckedCreateNestedManyWithoutAccountInput
    Deal?: DealUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutActivityInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutActivityInput, AccountUncheckedCreateWithoutActivityInput>
  }

  export type ContactCreateWithoutActivityInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutContactInput
    account?: AccountCreateNestedOneWithoutContactInput
    Deal?: DealCreateNestedManyWithoutContactInput
    ContactTag?: ContactTagCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutActivityInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    ownerId: string
    accountId?: string | null
    createdAt?: Date | string
    Deal?: DealUncheckedCreateNestedManyWithoutContactInput
    ContactTag?: ContactTagUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutActivityInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutActivityInput, ContactUncheckedCreateWithoutActivityInput>
  }

  export type DealCreateWithoutActivityInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    createdAt?: Date | string
    account?: AccountCreateNestedOneWithoutDealInput
    contact?: ContactCreateNestedOneWithoutDealInput
    owner: UserCreateNestedOneWithoutDealInput
    DealTag?: DealTagCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutActivityInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    accountId?: string | null
    contactId?: string | null
    ownerId: string
    createdAt?: Date | string
    DealTag?: DealTagUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutActivityInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutActivityInput, DealUncheckedCreateWithoutActivityInput>
  }

  export type ActivityCreateWithoutSubtasksInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutActivityInput
    account?: AccountCreateNestedOneWithoutActivityInput
    contact?: ContactCreateNestedOneWithoutActivityInput
    deal?: DealCreateNestedOneWithoutActivityInput
    parent?: ActivityCreateNestedOneWithoutSubtasksInput
    tags?: TagCreateNestedManyWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutSubtasksInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    ownerId: string
    accountId?: string | null
    contactId?: string | null
    dealId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutActivitiesInput
  }

  export type ActivityCreateOrConnectWithoutSubtasksInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutSubtasksInput, ActivityUncheckedCreateWithoutSubtasksInput>
  }

  export type ActivityCreateWithoutParentInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutActivityInput
    account?: AccountCreateNestedOneWithoutActivityInput
    contact?: ContactCreateNestedOneWithoutActivityInput
    deal?: DealCreateNestedOneWithoutActivityInput
    subtasks?: ActivityCreateNestedManyWithoutParentInput
    tags?: TagCreateNestedManyWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutParentInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    ownerId: string
    accountId?: string | null
    contactId?: string | null
    dealId?: string | null
    createdAt?: Date | string
    subtasks?: ActivityUncheckedCreateNestedManyWithoutParentInput
    tags?: TagUncheckedCreateNestedManyWithoutActivitiesInput
  }

  export type ActivityCreateOrConnectWithoutParentInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutParentInput, ActivityUncheckedCreateWithoutParentInput>
  }

  export type ActivityCreateManyParentInputEnvelope = {
    data: ActivityCreateManyParentInput | ActivityCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutActivitiesInput = {
    id?: string
    label: string
    color: string
    createdAt?: Date | string
    DealTags?: DealTagCreateNestedManyWithoutTagInput
    ContactTags?: ContactTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutActivitiesInput = {
    id?: string
    label: string
    color: string
    createdAt?: Date | string
    DealTags?: DealTagUncheckedCreateNestedManyWithoutTagInput
    ContactTags?: ContactTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutActivitiesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutActivitiesInput, TagUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivityInput = {
    update: XOR<UserUpdateWithoutActivityInput, UserUncheckedUpdateWithoutActivityInput>
    create: XOR<UserCreateWithoutActivityInput, UserUncheckedCreateWithoutActivityInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityInput, UserUncheckedUpdateWithoutActivityInput>
  }

  export type UserUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountUpsertWithoutActivityInput = {
    update: XOR<AccountUpdateWithoutActivityInput, AccountUncheckedUpdateWithoutActivityInput>
    create: XOR<AccountCreateWithoutActivityInput, AccountUncheckedCreateWithoutActivityInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutActivityInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutActivityInput, AccountUncheckedUpdateWithoutActivityInput>
  }

  export type AccountUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutAccountNestedInput
    Contact?: ContactUpdateManyWithoutAccountNestedInput
    Deal?: DealUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    Deal?: DealUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ContactUpsertWithoutActivityInput = {
    update: XOR<ContactUpdateWithoutActivityInput, ContactUncheckedUpdateWithoutActivityInput>
    create: XOR<ContactCreateWithoutActivityInput, ContactUncheckedCreateWithoutActivityInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutActivityInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutActivityInput, ContactUncheckedUpdateWithoutActivityInput>
  }

  export type ContactUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutContactNestedInput
    account?: AccountUpdateOneWithoutContactNestedInput
    Deal?: DealUpdateManyWithoutContactNestedInput
    ContactTag?: ContactTagUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Deal?: DealUncheckedUpdateManyWithoutContactNestedInput
    ContactTag?: ContactTagUncheckedUpdateManyWithoutContactNestedInput
  }

  export type DealUpsertWithoutActivityInput = {
    update: XOR<DealUpdateWithoutActivityInput, DealUncheckedUpdateWithoutActivityInput>
    create: XOR<DealCreateWithoutActivityInput, DealUncheckedCreateWithoutActivityInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutActivityInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutActivityInput, DealUncheckedUpdateWithoutActivityInput>
  }

  export type DealUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutDealNestedInput
    contact?: ContactUpdateOneWithoutDealNestedInput
    owner?: UserUpdateOneRequiredWithoutDealNestedInput
    DealTag?: DealTagUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DealTag?: DealTagUncheckedUpdateManyWithoutDealNestedInput
  }

  export type ActivityUpsertWithoutSubtasksInput = {
    update: XOR<ActivityUpdateWithoutSubtasksInput, ActivityUncheckedUpdateWithoutSubtasksInput>
    create: XOR<ActivityCreateWithoutSubtasksInput, ActivityUncheckedCreateWithoutSubtasksInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutSubtasksInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutSubtasksInput, ActivityUncheckedUpdateWithoutSubtasksInput>
  }

  export type ActivityUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutActivityNestedInput
    account?: AccountUpdateOneWithoutActivityNestedInput
    contact?: ContactUpdateOneWithoutActivityNestedInput
    deal?: DealUpdateOneWithoutActivityNestedInput
    parent?: ActivityUpdateOneWithoutSubtasksNestedInput
    tags?: TagUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivityUpsertWithWhereUniqueWithoutParentInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutParentInput, ActivityUncheckedUpdateWithoutParentInput>
    create: XOR<ActivityCreateWithoutParentInput, ActivityUncheckedCreateWithoutParentInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutParentInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutParentInput, ActivityUncheckedUpdateWithoutParentInput>
  }

  export type ActivityUpdateManyWithWhereWithoutParentInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutParentInput>
  }

  export type TagUpsertWithWhereUniqueWithoutActivitiesInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutActivitiesInput, TagUncheckedUpdateWithoutActivitiesInput>
    create: XOR<TagCreateWithoutActivitiesInput, TagUncheckedCreateWithoutActivitiesInput>
  }

  export type TagUpdateWithWhereUniqueWithoutActivitiesInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutActivitiesInput, TagUncheckedUpdateWithoutActivitiesInput>
  }

  export type TagUpdateManyWithWhereWithoutActivitiesInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutActivitiesInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: StringFilter<"Tag"> | string
    label?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
  }

  export type UserCreateWithoutEmailAccountInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailAccountInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailAccountInput, UserUncheckedCreateWithoutEmailAccountInput>
  }

  export type UserUpsertWithoutEmailAccountInput = {
    update: XOR<UserUpdateWithoutEmailAccountInput, UserUncheckedUpdateWithoutEmailAccountInput>
    create: XOR<UserCreateWithoutEmailAccountInput, UserUncheckedCreateWithoutEmailAccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailAccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailAccountInput, UserUncheckedUpdateWithoutEmailAccountInput>
  }

  export type UserUpdateWithoutEmailAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutEmailTemplateInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailTemplateInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailTemplateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailTemplateInput, UserUncheckedCreateWithoutEmailTemplateInput>
  }

  export type EmailMessageCreateWithoutTemplateInput = {
    id?: string
    subject: string
    to: string
    body: string
    status: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailMessageInput
  }

  export type EmailMessageUncheckedCreateWithoutTemplateInput = {
    id?: string
    subject: string
    to: string
    body: string
    status: string
    userId: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailMessageCreateOrConnectWithoutTemplateInput = {
    where: EmailMessageWhereUniqueInput
    create: XOR<EmailMessageCreateWithoutTemplateInput, EmailMessageUncheckedCreateWithoutTemplateInput>
  }

  export type EmailMessageCreateManyTemplateInputEnvelope = {
    data: EmailMessageCreateManyTemplateInput | EmailMessageCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEmailTemplateInput = {
    update: XOR<UserUpdateWithoutEmailTemplateInput, UserUncheckedUpdateWithoutEmailTemplateInput>
    create: XOR<UserCreateWithoutEmailTemplateInput, UserUncheckedCreateWithoutEmailTemplateInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailTemplateInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailTemplateInput, UserUncheckedUpdateWithoutEmailTemplateInput>
  }

  export type UserUpdateWithoutEmailTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmailMessageUpsertWithWhereUniqueWithoutTemplateInput = {
    where: EmailMessageWhereUniqueInput
    update: XOR<EmailMessageUpdateWithoutTemplateInput, EmailMessageUncheckedUpdateWithoutTemplateInput>
    create: XOR<EmailMessageCreateWithoutTemplateInput, EmailMessageUncheckedCreateWithoutTemplateInput>
  }

  export type EmailMessageUpdateWithWhereUniqueWithoutTemplateInput = {
    where: EmailMessageWhereUniqueInput
    data: XOR<EmailMessageUpdateWithoutTemplateInput, EmailMessageUncheckedUpdateWithoutTemplateInput>
  }

  export type EmailMessageUpdateManyWithWhereWithoutTemplateInput = {
    where: EmailMessageScalarWhereInput
    data: XOR<EmailMessageUpdateManyMutationInput, EmailMessageUncheckedUpdateManyWithoutTemplateInput>
  }

  export type UserCreateWithoutEmailMessageInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailMessageInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailMessageInput, UserUncheckedCreateWithoutEmailMessageInput>
  }

  export type EmailTemplateCreateWithoutEmailMessageInput = {
    id?: string
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutEmailMessageInput = {
    id?: string
    name: string
    subject: string
    body: string
    userId: string
    createdAt?: Date | string
  }

  export type EmailTemplateCreateOrConnectWithoutEmailMessageInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutEmailMessageInput, EmailTemplateUncheckedCreateWithoutEmailMessageInput>
  }

  export type UserUpsertWithoutEmailMessageInput = {
    update: XOR<UserUpdateWithoutEmailMessageInput, UserUncheckedUpdateWithoutEmailMessageInput>
    create: XOR<UserCreateWithoutEmailMessageInput, UserUncheckedCreateWithoutEmailMessageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailMessageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailMessageInput, UserUncheckedUpdateWithoutEmailMessageInput>
  }

  export type UserUpdateWithoutEmailMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmailTemplateUpsertWithoutEmailMessageInput = {
    update: XOR<EmailTemplateUpdateWithoutEmailMessageInput, EmailTemplateUncheckedUpdateWithoutEmailMessageInput>
    create: XOR<EmailTemplateCreateWithoutEmailMessageInput, EmailTemplateUncheckedCreateWithoutEmailMessageInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutEmailMessageInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutEmailMessageInput, EmailTemplateUncheckedUpdateWithoutEmailMessageInput>
  }

  export type EmailTemplateUpdateWithoutEmailMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutEmailMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutEmailInboxMessageInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailInboxMessageInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailInboxMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailInboxMessageInput, UserUncheckedCreateWithoutEmailInboxMessageInput>
  }

  export type UserUpsertWithoutEmailInboxMessageInput = {
    update: XOR<UserUpdateWithoutEmailInboxMessageInput, UserUncheckedUpdateWithoutEmailInboxMessageInput>
    create: XOR<UserCreateWithoutEmailInboxMessageInput, UserUncheckedCreateWithoutEmailInboxMessageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailInboxMessageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailInboxMessageInput, UserUncheckedUpdateWithoutEmailInboxMessageInput>
  }

  export type UserUpdateWithoutEmailInboxMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailInboxMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutEmailContactInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailContactInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailContactInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailContactInput, UserUncheckedCreateWithoutEmailContactInput>
  }

  export type UserUpsertWithoutEmailContactInput = {
    update: XOR<UserUpdateWithoutEmailContactInput, UserUncheckedUpdateWithoutEmailContactInput>
    create: XOR<UserCreateWithoutEmailContactInput, UserUncheckedCreateWithoutEmailContactInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailContactInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailContactInput, UserUncheckedUpdateWithoutEmailContactInput>
  }

  export type UserUpdateWithoutEmailContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDocumentTemplateInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentTemplateInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentTemplateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentTemplateInput, UserUncheckedCreateWithoutDocumentTemplateInput>
  }

  export type GeneratedDocumentCreateWithoutTemplateInput = {
    id?: string
    filePath: string
    format: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutGeneratedDocumentInput
  }

  export type GeneratedDocumentUncheckedCreateWithoutTemplateInput = {
    id?: string
    filePath: string
    format: string
    userId: string
    createdAt?: Date | string
  }

  export type GeneratedDocumentCreateOrConnectWithoutTemplateInput = {
    where: GeneratedDocumentWhereUniqueInput
    create: XOR<GeneratedDocumentCreateWithoutTemplateInput, GeneratedDocumentUncheckedCreateWithoutTemplateInput>
  }

  export type GeneratedDocumentCreateManyTemplateInputEnvelope = {
    data: GeneratedDocumentCreateManyTemplateInput | GeneratedDocumentCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDocumentTemplateInput = {
    update: XOR<UserUpdateWithoutDocumentTemplateInput, UserUncheckedUpdateWithoutDocumentTemplateInput>
    create: XOR<UserCreateWithoutDocumentTemplateInput, UserUncheckedCreateWithoutDocumentTemplateInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentTemplateInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentTemplateInput, UserUncheckedUpdateWithoutDocumentTemplateInput>
  }

  export type UserUpdateWithoutDocumentTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GeneratedDocumentUpsertWithWhereUniqueWithoutTemplateInput = {
    where: GeneratedDocumentWhereUniqueInput
    update: XOR<GeneratedDocumentUpdateWithoutTemplateInput, GeneratedDocumentUncheckedUpdateWithoutTemplateInput>
    create: XOR<GeneratedDocumentCreateWithoutTemplateInput, GeneratedDocumentUncheckedCreateWithoutTemplateInput>
  }

  export type GeneratedDocumentUpdateWithWhereUniqueWithoutTemplateInput = {
    where: GeneratedDocumentWhereUniqueInput
    data: XOR<GeneratedDocumentUpdateWithoutTemplateInput, GeneratedDocumentUncheckedUpdateWithoutTemplateInput>
  }

  export type GeneratedDocumentUpdateManyWithWhereWithoutTemplateInput = {
    where: GeneratedDocumentScalarWhereInput
    data: XOR<GeneratedDocumentUpdateManyMutationInput, GeneratedDocumentUncheckedUpdateManyWithoutTemplateInput>
  }

  export type DocumentTemplateCreateWithoutGeneratedDocumentInput = {
    id?: string
    name: string
    content: string
    format: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentTemplateInput
  }

  export type DocumentTemplateUncheckedCreateWithoutGeneratedDocumentInput = {
    id?: string
    name: string
    content: string
    format: string
    userId: string
    createdAt?: Date | string
  }

  export type DocumentTemplateCreateOrConnectWithoutGeneratedDocumentInput = {
    where: DocumentTemplateWhereUniqueInput
    create: XOR<DocumentTemplateCreateWithoutGeneratedDocumentInput, DocumentTemplateUncheckedCreateWithoutGeneratedDocumentInput>
  }

  export type UserCreateWithoutGeneratedDocumentInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGeneratedDocumentInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGeneratedDocumentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGeneratedDocumentInput, UserUncheckedCreateWithoutGeneratedDocumentInput>
  }

  export type DocumentTemplateUpsertWithoutGeneratedDocumentInput = {
    update: XOR<DocumentTemplateUpdateWithoutGeneratedDocumentInput, DocumentTemplateUncheckedUpdateWithoutGeneratedDocumentInput>
    create: XOR<DocumentTemplateCreateWithoutGeneratedDocumentInput, DocumentTemplateUncheckedCreateWithoutGeneratedDocumentInput>
    where?: DocumentTemplateWhereInput
  }

  export type DocumentTemplateUpdateToOneWithWhereWithoutGeneratedDocumentInput = {
    where?: DocumentTemplateWhereInput
    data: XOR<DocumentTemplateUpdateWithoutGeneratedDocumentInput, DocumentTemplateUncheckedUpdateWithoutGeneratedDocumentInput>
  }

  export type DocumentTemplateUpdateWithoutGeneratedDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentTemplateNestedInput
  }

  export type DocumentTemplateUncheckedUpdateWithoutGeneratedDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutGeneratedDocumentInput = {
    update: XOR<UserUpdateWithoutGeneratedDocumentInput, UserUncheckedUpdateWithoutGeneratedDocumentInput>
    create: XOR<UserCreateWithoutGeneratedDocumentInput, UserUncheckedCreateWithoutGeneratedDocumentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGeneratedDocumentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGeneratedDocumentInput, UserUncheckedUpdateWithoutGeneratedDocumentInput>
  }

  export type UserUpdateWithoutGeneratedDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGeneratedDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFileFolderInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFileFolderInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFileFolderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFileFolderInput, UserUncheckedCreateWithoutFileFolderInput>
  }

  export type FileCreateWithoutFolderInput = {
    id?: string
    name: string
    path: string
    size: number
    mimeType: string
    dealId?: string | null
    contactId?: string | null
    taskId?: string | null
    publicLink?: string | null
    expiresAt?: Date | string | null
    access: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFileInput
    comment?: CommentCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutFolderInput = {
    id?: string
    name: string
    path: string
    size: number
    mimeType: string
    userId: string
    dealId?: string | null
    contactId?: string | null
    taskId?: string | null
    publicLink?: string | null
    expiresAt?: Date | string | null
    access: string
    createdAt?: Date | string
    commentId?: string | null
  }

  export type FileCreateOrConnectWithoutFolderInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput>
  }

  export type FileCreateManyFolderInputEnvelope = {
    data: FileCreateManyFolderInput | FileCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFileFolderInput = {
    update: XOR<UserUpdateWithoutFileFolderInput, UserUncheckedUpdateWithoutFileFolderInput>
    create: XOR<UserCreateWithoutFileFolderInput, UserUncheckedCreateWithoutFileFolderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFileFolderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFileFolderInput, UserUncheckedUpdateWithoutFileFolderInput>
  }

  export type UserUpdateWithoutFileFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFileFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FileUpsertWithWhereUniqueWithoutFolderInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutFolderInput, FileUncheckedUpdateWithoutFolderInput>
    create: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput>
  }

  export type FileUpdateWithWhereUniqueWithoutFolderInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutFolderInput, FileUncheckedUpdateWithoutFolderInput>
  }

  export type FileUpdateManyWithWhereWithoutFolderInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutFolderInput>
  }

  export type UserCreateWithoutFileInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFileInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFileInput, UserUncheckedCreateWithoutFileInput>
  }

  export type FileFolderCreateWithoutFilesInput = {
    id?: string
    name: string
    parentId?: string | null
    access: string
    createdAt?: Date | string
    accountId?: string | null
    dealId?: string | null
    user: UserCreateNestedOneWithoutFileFolderInput
  }

  export type FileFolderUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    parentId?: string | null
    userId: string
    access: string
    createdAt?: Date | string
    accountId?: string | null
    dealId?: string | null
  }

  export type FileFolderCreateOrConnectWithoutFilesInput = {
    where: FileFolderWhereUniqueInput
    create: XOR<FileFolderCreateWithoutFilesInput, FileFolderUncheckedCreateWithoutFilesInput>
  }

  export type CommentCreateWithoutFilesInput = {
    id?: string
    entity: string
    entityId: string
    text: string
    mentions?: CommentCreatementionsInput | string[]
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutFilesInput = {
    id?: string
    entity: string
    entityId: string
    text: string
    userId: string
    mentions?: CommentCreatementionsInput | string[]
    createdAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutFilesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutFilesInput, CommentUncheckedCreateWithoutFilesInput>
  }

  export type UserUpsertWithoutFileInput = {
    update: XOR<UserUpdateWithoutFileInput, UserUncheckedUpdateWithoutFileInput>
    create: XOR<UserCreateWithoutFileInput, UserUncheckedCreateWithoutFileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFileInput, UserUncheckedUpdateWithoutFileInput>
  }

  export type UserUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FileFolderUpsertWithoutFilesInput = {
    update: XOR<FileFolderUpdateWithoutFilesInput, FileFolderUncheckedUpdateWithoutFilesInput>
    create: XOR<FileFolderCreateWithoutFilesInput, FileFolderUncheckedCreateWithoutFilesInput>
    where?: FileFolderWhereInput
  }

  export type FileFolderUpdateToOneWithWhereWithoutFilesInput = {
    where?: FileFolderWhereInput
    data: XOR<FileFolderUpdateWithoutFilesInput, FileFolderUncheckedUpdateWithoutFilesInput>
  }

  export type FileFolderUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutFileFolderNestedInput
  }

  export type FileFolderUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpsertWithoutFilesInput = {
    update: XOR<CommentUpdateWithoutFilesInput, CommentUncheckedUpdateWithoutFilesInput>
    create: XOR<CommentCreateWithoutFilesInput, CommentUncheckedCreateWithoutFilesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutFilesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutFilesInput, CommentUncheckedUpdateWithoutFilesInput>
  }

  export type CommentUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    mentions?: CommentUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mentions?: CommentUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealCreateWithoutDealTagInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    createdAt?: Date | string
    account?: AccountCreateNestedOneWithoutDealInput
    contact?: ContactCreateNestedOneWithoutDealInput
    owner: UserCreateNestedOneWithoutDealInput
    Activity?: ActivityCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutDealTagInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    accountId?: string | null
    contactId?: string | null
    ownerId: string
    createdAt?: Date | string
    Activity?: ActivityUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutDealTagInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutDealTagInput, DealUncheckedCreateWithoutDealTagInput>
  }

  export type TagCreateWithoutDealTagsInput = {
    id?: string
    label: string
    color: string
    createdAt?: Date | string
    ContactTags?: ContactTagCreateNestedManyWithoutTagInput
    activities?: ActivityCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutDealTagsInput = {
    id?: string
    label: string
    color: string
    createdAt?: Date | string
    ContactTags?: ContactTagUncheckedCreateNestedManyWithoutTagInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutDealTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutDealTagsInput, TagUncheckedCreateWithoutDealTagsInput>
  }

  export type DealUpsertWithoutDealTagInput = {
    update: XOR<DealUpdateWithoutDealTagInput, DealUncheckedUpdateWithoutDealTagInput>
    create: XOR<DealCreateWithoutDealTagInput, DealUncheckedCreateWithoutDealTagInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutDealTagInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutDealTagInput, DealUncheckedUpdateWithoutDealTagInput>
  }

  export type DealUpdateWithoutDealTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutDealNestedInput
    contact?: ContactUpdateOneWithoutDealNestedInput
    owner?: UserUpdateOneRequiredWithoutDealNestedInput
    Activity?: ActivityUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutDealTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Activity?: ActivityUncheckedUpdateManyWithoutDealNestedInput
  }

  export type TagUpsertWithoutDealTagsInput = {
    update: XOR<TagUpdateWithoutDealTagsInput, TagUncheckedUpdateWithoutDealTagsInput>
    create: XOR<TagCreateWithoutDealTagsInput, TagUncheckedCreateWithoutDealTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutDealTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutDealTagsInput, TagUncheckedUpdateWithoutDealTagsInput>
  }

  export type TagUpdateWithoutDealTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ContactTags?: ContactTagUpdateManyWithoutTagNestedInput
    activities?: ActivityUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutDealTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ContactTags?: ContactTagUncheckedUpdateManyWithoutTagNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type ContactCreateWithoutContactTagInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutContactInput
    account?: AccountCreateNestedOneWithoutContactInput
    Deal?: DealCreateNestedManyWithoutContactInput
    Activity?: ActivityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutContactTagInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    ownerId: string
    accountId?: string | null
    createdAt?: Date | string
    Deal?: DealUncheckedCreateNestedManyWithoutContactInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutContactTagInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutContactTagInput, ContactUncheckedCreateWithoutContactTagInput>
  }

  export type TagCreateWithoutContactTagsInput = {
    id?: string
    label: string
    color: string
    createdAt?: Date | string
    DealTags?: DealTagCreateNestedManyWithoutTagInput
    activities?: ActivityCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutContactTagsInput = {
    id?: string
    label: string
    color: string
    createdAt?: Date | string
    DealTags?: DealTagUncheckedCreateNestedManyWithoutTagInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutContactTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutContactTagsInput, TagUncheckedCreateWithoutContactTagsInput>
  }

  export type ContactUpsertWithoutContactTagInput = {
    update: XOR<ContactUpdateWithoutContactTagInput, ContactUncheckedUpdateWithoutContactTagInput>
    create: XOR<ContactCreateWithoutContactTagInput, ContactUncheckedCreateWithoutContactTagInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutContactTagInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutContactTagInput, ContactUncheckedUpdateWithoutContactTagInput>
  }

  export type ContactUpdateWithoutContactTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutContactNestedInput
    account?: AccountUpdateOneWithoutContactNestedInput
    Deal?: DealUpdateManyWithoutContactNestedInput
    Activity?: ActivityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutContactTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Deal?: DealUncheckedUpdateManyWithoutContactNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type TagUpsertWithoutContactTagsInput = {
    update: XOR<TagUpdateWithoutContactTagsInput, TagUncheckedUpdateWithoutContactTagsInput>
    create: XOR<TagCreateWithoutContactTagsInput, TagUncheckedCreateWithoutContactTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutContactTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutContactTagsInput, TagUncheckedUpdateWithoutContactTagsInput>
  }

  export type TagUpdateWithoutContactTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DealTags?: DealTagUpdateManyWithoutTagNestedInput
    activities?: ActivityUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutContactTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DealTags?: DealTagUncheckedUpdateManyWithoutTagNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type DealTagCreateWithoutTagInput = {
    deal: DealCreateNestedOneWithoutDealTagInput
  }

  export type DealTagUncheckedCreateWithoutTagInput = {
    dealId: string
  }

  export type DealTagCreateOrConnectWithoutTagInput = {
    where: DealTagWhereUniqueInput
    create: XOR<DealTagCreateWithoutTagInput, DealTagUncheckedCreateWithoutTagInput>
  }

  export type DealTagCreateManyTagInputEnvelope = {
    data: DealTagCreateManyTagInput | DealTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ContactTagCreateWithoutTagInput = {
    contact: ContactCreateNestedOneWithoutContactTagInput
  }

  export type ContactTagUncheckedCreateWithoutTagInput = {
    contactId: string
  }

  export type ContactTagCreateOrConnectWithoutTagInput = {
    where: ContactTagWhereUniqueInput
    create: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput>
  }

  export type ContactTagCreateManyTagInputEnvelope = {
    data: ContactTagCreateManyTagInput | ContactTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutTagsInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutActivityInput
    account?: AccountCreateNestedOneWithoutActivityInput
    contact?: ContactCreateNestedOneWithoutActivityInput
    deal?: DealCreateNestedOneWithoutActivityInput
    parent?: ActivityCreateNestedOneWithoutSubtasksInput
    subtasks?: ActivityCreateNestedManyWithoutParentInput
  }

  export type ActivityUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    ownerId: string
    accountId?: string | null
    contactId?: string | null
    dealId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    subtasks?: ActivityUncheckedCreateNestedManyWithoutParentInput
  }

  export type ActivityCreateOrConnectWithoutTagsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutTagsInput, ActivityUncheckedCreateWithoutTagsInput>
  }

  export type DealTagUpsertWithWhereUniqueWithoutTagInput = {
    where: DealTagWhereUniqueInput
    update: XOR<DealTagUpdateWithoutTagInput, DealTagUncheckedUpdateWithoutTagInput>
    create: XOR<DealTagCreateWithoutTagInput, DealTagUncheckedCreateWithoutTagInput>
  }

  export type DealTagUpdateWithWhereUniqueWithoutTagInput = {
    where: DealTagWhereUniqueInput
    data: XOR<DealTagUpdateWithoutTagInput, DealTagUncheckedUpdateWithoutTagInput>
  }

  export type DealTagUpdateManyWithWhereWithoutTagInput = {
    where: DealTagScalarWhereInput
    data: XOR<DealTagUpdateManyMutationInput, DealTagUncheckedUpdateManyWithoutTagInput>
  }

  export type ContactTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ContactTagWhereUniqueInput
    update: XOR<ContactTagUpdateWithoutTagInput, ContactTagUncheckedUpdateWithoutTagInput>
    create: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput>
  }

  export type ContactTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ContactTagWhereUniqueInput
    data: XOR<ContactTagUpdateWithoutTagInput, ContactTagUncheckedUpdateWithoutTagInput>
  }

  export type ContactTagUpdateManyWithWhereWithoutTagInput = {
    where: ContactTagScalarWhereInput
    data: XOR<ContactTagUpdateManyMutationInput, ContactTagUncheckedUpdateManyWithoutTagInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutTagsInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutTagsInput, ActivityUncheckedUpdateWithoutTagsInput>
    create: XOR<ActivityCreateWithoutTagsInput, ActivityUncheckedCreateWithoutTagsInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutTagsInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutTagsInput, ActivityUncheckedUpdateWithoutTagsInput>
  }

  export type ActivityUpdateManyWithWhereWithoutTagsInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutTagsInput>
  }

  export type UserCreateWithoutSharedAccessInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSharedAccessInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSharedAccessInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedAccessInput, UserUncheckedCreateWithoutSharedAccessInput>
  }

  export type UserUpsertWithoutSharedAccessInput = {
    update: XOR<UserUpdateWithoutSharedAccessInput, UserUncheckedUpdateWithoutSharedAccessInput>
    create: XOR<UserCreateWithoutSharedAccessInput, UserUncheckedCreateWithoutSharedAccessInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedAccessInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedAccessInput, UserUncheckedUpdateWithoutSharedAccessInput>
  }

  export type UserUpdateWithoutSharedAccessInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedAccessInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CustomFieldValueCreateWithoutFieldInput = {
    id?: string
    entity: string
    entityId: string
    value: string
    createdAt?: Date | string
  }

  export type CustomFieldValueUncheckedCreateWithoutFieldInput = {
    id?: string
    entity: string
    entityId: string
    value: string
    createdAt?: Date | string
  }

  export type CustomFieldValueCreateOrConnectWithoutFieldInput = {
    where: CustomFieldValueWhereUniqueInput
    create: XOR<CustomFieldValueCreateWithoutFieldInput, CustomFieldValueUncheckedCreateWithoutFieldInput>
  }

  export type CustomFieldValueCreateManyFieldInputEnvelope = {
    data: CustomFieldValueCreateManyFieldInput | CustomFieldValueCreateManyFieldInput[]
    skipDuplicates?: boolean
  }

  export type CustomFieldValueUpsertWithWhereUniqueWithoutFieldInput = {
    where: CustomFieldValueWhereUniqueInput
    update: XOR<CustomFieldValueUpdateWithoutFieldInput, CustomFieldValueUncheckedUpdateWithoutFieldInput>
    create: XOR<CustomFieldValueCreateWithoutFieldInput, CustomFieldValueUncheckedCreateWithoutFieldInput>
  }

  export type CustomFieldValueUpdateWithWhereUniqueWithoutFieldInput = {
    where: CustomFieldValueWhereUniqueInput
    data: XOR<CustomFieldValueUpdateWithoutFieldInput, CustomFieldValueUncheckedUpdateWithoutFieldInput>
  }

  export type CustomFieldValueUpdateManyWithWhereWithoutFieldInput = {
    where: CustomFieldValueScalarWhereInput
    data: XOR<CustomFieldValueUpdateManyMutationInput, CustomFieldValueUncheckedUpdateManyWithoutFieldInput>
  }

  export type CustomFieldValueScalarWhereInput = {
    AND?: CustomFieldValueScalarWhereInput | CustomFieldValueScalarWhereInput[]
    OR?: CustomFieldValueScalarWhereInput[]
    NOT?: CustomFieldValueScalarWhereInput | CustomFieldValueScalarWhereInput[]
    id?: StringFilter<"CustomFieldValue"> | string
    fieldId?: StringFilter<"CustomFieldValue"> | string
    entity?: StringFilter<"CustomFieldValue"> | string
    entityId?: StringFilter<"CustomFieldValue"> | string
    value?: StringFilter<"CustomFieldValue"> | string
    createdAt?: DateTimeFilter<"CustomFieldValue"> | Date | string
  }

  export type CustomFieldCreateWithoutValuesInput = {
    id?: string
    entity: string
    name: string
    label: string
    type: string
    options?: NullableJsonNullValueInput | InputJsonValue
    required?: boolean
    createdAt?: Date | string
  }

  export type CustomFieldUncheckedCreateWithoutValuesInput = {
    id?: string
    entity: string
    name: string
    label: string
    type: string
    options?: NullableJsonNullValueInput | InputJsonValue
    required?: boolean
    createdAt?: Date | string
  }

  export type CustomFieldCreateOrConnectWithoutValuesInput = {
    where: CustomFieldWhereUniqueInput
    create: XOR<CustomFieldCreateWithoutValuesInput, CustomFieldUncheckedCreateWithoutValuesInput>
  }

  export type CustomFieldUpsertWithoutValuesInput = {
    update: XOR<CustomFieldUpdateWithoutValuesInput, CustomFieldUncheckedUpdateWithoutValuesInput>
    create: XOR<CustomFieldCreateWithoutValuesInput, CustomFieldUncheckedCreateWithoutValuesInput>
    where?: CustomFieldWhereInput
  }

  export type CustomFieldUpdateToOneWithWhereWithoutValuesInput = {
    where?: CustomFieldWhereInput
    data: XOR<CustomFieldUpdateWithoutValuesInput, CustomFieldUncheckedUpdateWithoutValuesInput>
  }

  export type CustomFieldUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    required?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldUncheckedUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    required?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAuditLogInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
  }

  export type UserUpsertWithoutAuditLogInput = {
    update: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>
  }

  export type UserUpdateWithoutAuditLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCommentInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
  }

  export type FileCreateWithoutCommentInput = {
    id?: string
    name: string
    path: string
    size: number
    mimeType: string
    dealId?: string | null
    contactId?: string | null
    taskId?: string | null
    publicLink?: string | null
    expiresAt?: Date | string | null
    access: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFileInput
    folder?: FileFolderCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutCommentInput = {
    id?: string
    name: string
    path: string
    size: number
    mimeType: string
    userId: string
    folderId?: string | null
    dealId?: string | null
    contactId?: string | null
    taskId?: string | null
    publicLink?: string | null
    expiresAt?: Date | string | null
    access: string
    createdAt?: Date | string
  }

  export type FileCreateOrConnectWithoutCommentInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutCommentInput, FileUncheckedCreateWithoutCommentInput>
  }

  export type FileCreateManyCommentInputEnvelope = {
    data: FileCreateManyCommentInput | FileCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCommentInput = {
    update: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
  }

  export type UserUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FileUpsertWithWhereUniqueWithoutCommentInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutCommentInput, FileUncheckedUpdateWithoutCommentInput>
    create: XOR<FileCreateWithoutCommentInput, FileUncheckedCreateWithoutCommentInput>
  }

  export type FileUpdateWithWhereUniqueWithoutCommentInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutCommentInput, FileUncheckedUpdateWithoutCommentInput>
  }

  export type FileUpdateManyWithWhereWithoutCommentInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutCommentInput>
  }

  export type UserCreateWithoutNotificationInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    team?: TeamCreateNestedOneWithoutUsersInput
    Account?: AccountCreateNestedManyWithoutOwnerInput
    Contact?: ContactCreateNestedManyWithoutOwnerInput
    Deal?: DealCreateNestedManyWithoutOwnerInput
    Activity?: ActivityCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderCreateNestedManyWithoutUserInput
    File?: FileCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
    teamId?: string | null
    Account?: AccountUncheckedCreateNestedManyWithoutOwnerInput
    Contact?: ContactUncheckedCreateNestedManyWithoutOwnerInput
    Deal?: DealUncheckedCreateNestedManyWithoutOwnerInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    EmailAccount?: EmailAccountUncheckedCreateNestedManyWithoutUserInput
    EmailTemplate?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    EmailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    EmailInboxMessage?: EmailInboxMessageUncheckedCreateNestedManyWithoutUserInput
    EmailContact?: EmailContactUncheckedCreateNestedManyWithoutUserInput
    DocumentTemplate?: DocumentTemplateUncheckedCreateNestedManyWithoutUserInput
    GeneratedDocument?: GeneratedDocumentUncheckedCreateNestedManyWithoutUserInput
    FileFolder?: FileFolderUncheckedCreateNestedManyWithoutUserInput
    File?: FileUncheckedCreateNestedManyWithoutUserInput
    SharedAccess?: SharedAccessUncheckedCreateNestedManyWithoutUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateManyOwnerInput = {
    id?: string
    name: string
    industry?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    createdAt?: Date | string
  }

  export type ContactCreateManyOwnerInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    accountId?: string | null
    createdAt?: Date | string
  }

  export type DealCreateManyOwnerInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    accountId?: string | null
    contactId?: string | null
    createdAt?: Date | string
  }

  export type ActivityCreateManyOwnerInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    accountId?: string | null
    contactId?: string | null
    dealId?: string | null
    parentId?: string | null
    createdAt?: Date | string
  }

  export type EmailAccountCreateManyUserInput = {
    id?: string
    smtpHost: string
    smtpPort: number
    smtpSecure: boolean
    email: string
    password: string
    createdAt?: Date | string
  }

  export type EmailTemplateCreateManyUserInput = {
    id?: string
    name: string
    subject: string
    body: string
    createdAt?: Date | string
  }

  export type EmailMessageCreateManyUserInput = {
    id?: string
    subject: string
    to: string
    body: string
    status: string
    templateId?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailInboxMessageCreateManyUserInput = {
    id?: string
    from: string
    to: string
    subject: string
    text?: string | null
    html?: string | null
    date: Date | string
    folder: string
    messageId: string
    seen?: boolean
    flagged?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailContactCreateManyUserInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    company?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type DocumentTemplateCreateManyUserInput = {
    id?: string
    name: string
    content: string
    format: string
    createdAt?: Date | string
  }

  export type GeneratedDocumentCreateManyUserInput = {
    id?: string
    filePath: string
    format: string
    templateId: string
    createdAt?: Date | string
  }

  export type FileFolderCreateManyUserInput = {
    id?: string
    name: string
    parentId?: string | null
    access: string
    createdAt?: Date | string
    accountId?: string | null
    dealId?: string | null
  }

  export type FileCreateManyUserInput = {
    id?: string
    name: string
    path: string
    size: number
    mimeType: string
    folderId?: string | null
    dealId?: string | null
    contactId?: string | null
    taskId?: string | null
    publicLink?: string | null
    expiresAt?: Date | string | null
    access: string
    createdAt?: Date | string
    commentId?: string | null
  }

  export type SharedAccessCreateManyUserInput = {
    id?: string
    entityId: string
    entity: string
    canEdit?: boolean
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    entity: string
    entityId: string
    text: string
    mentions?: CommentCreatementionsInput | string[]
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type AccountUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: ContactUpdateManyWithoutAccountNestedInput
    Deal?: DealUpdateManyWithoutAccountNestedInput
    Activity?: ActivityUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: ContactUncheckedUpdateManyWithoutAccountNestedInput
    Deal?: DealUncheckedUpdateManyWithoutAccountNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutContactNestedInput
    Deal?: DealUpdateManyWithoutContactNestedInput
    Activity?: ActivityUpdateManyWithoutContactNestedInput
    ContactTag?: ContactTagUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Deal?: DealUncheckedUpdateManyWithoutContactNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutContactNestedInput
    ContactTag?: ContactTagUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutDealNestedInput
    contact?: ContactUpdateOneWithoutDealNestedInput
    Activity?: ActivityUpdateManyWithoutDealNestedInput
    DealTag?: DealTagUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Activity?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    DealTag?: DealTagUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutActivityNestedInput
    contact?: ContactUpdateOneWithoutActivityNestedInput
    deal?: DealUpdateOneWithoutActivityNestedInput
    parent?: ActivityUpdateOneWithoutSubtasksNestedInput
    subtasks?: ActivityUpdateManyWithoutParentNestedInput
    tags?: TagUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtasks?: ActivityUncheckedUpdateManyWithoutParentNestedInput
    tags?: TagUncheckedUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    smtpHost?: StringFieldUpdateOperationsInput | string
    smtpPort?: IntFieldUpdateOperationsInput | number
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    smtpHost?: StringFieldUpdateOperationsInput | string
    smtpPort?: IntFieldUpdateOperationsInput | number
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    smtpHost?: StringFieldUpdateOperationsInput | string
    smtpPort?: IntFieldUpdateOperationsInput | number
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EmailMessage?: EmailMessageUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: EmailTemplateUpdateOneWithoutEmailMessageNestedInput
  }

  export type EmailMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailInboxMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailInboxMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailInboxMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    html?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentTemplateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutTemplateNestedInput
  }

  export type DocumentTemplateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type DocumentTemplateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedDocumentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: DocumentTemplateUpdateOneRequiredWithoutGeneratedDocumentNestedInput
  }

  export type GeneratedDocumentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedDocumentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileFolderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    publicLink?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FileFolderUpdateOneWithoutFilesNestedInput
    comment?: CommentUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    publicLink?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    publicLink?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SharedAccessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedAccessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedAccessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    mentions?: CommentUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    mentions?: CommentUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    mentions?: CommentUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyRoleInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    createdAt?: Date | string
    teamId?: string | null
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyTeamInput = {
    id?: string
    email: string
    password: string
    name: string
    telegramId?: string | null
    notificationsEnabled?: boolean
    roleId: string
    createdAt?: Date | string
  }

  export type UserUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Account?: AccountUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUpdateManyWithoutOwnerNestedInput
    Deal?: DealUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUpdateManyWithoutUserNestedInput
    File?: FileUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Account?: AccountUncheckedUpdateManyWithoutOwnerNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutOwnerNestedInput
    Deal?: DealUncheckedUpdateManyWithoutOwnerNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    EmailAccount?: EmailAccountUncheckedUpdateManyWithoutUserNestedInput
    EmailTemplate?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    EmailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailInboxMessage?: EmailInboxMessageUncheckedUpdateManyWithoutUserNestedInput
    EmailContact?: EmailContactUncheckedUpdateManyWithoutUserNestedInput
    DocumentTemplate?: DocumentTemplateUncheckedUpdateManyWithoutUserNestedInput
    GeneratedDocument?: GeneratedDocumentUncheckedUpdateManyWithoutUserNestedInput
    FileFolder?: FileFolderUncheckedUpdateManyWithoutUserNestedInput
    File?: FileUncheckedUpdateManyWithoutUserNestedInput
    SharedAccess?: SharedAccessUncheckedUpdateManyWithoutUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateManyAccountInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    ownerId: string
    createdAt?: Date | string
  }

  export type DealCreateManyAccountInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    contactId?: string | null
    ownerId: string
    createdAt?: Date | string
  }

  export type ActivityCreateManyAccountInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    ownerId: string
    contactId?: string | null
    dealId?: string | null
    parentId?: string | null
    createdAt?: Date | string
  }

  export type ContactUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutContactNestedInput
    Deal?: DealUpdateManyWithoutContactNestedInput
    Activity?: ActivityUpdateManyWithoutContactNestedInput
    ContactTag?: ContactTagUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Deal?: DealUncheckedUpdateManyWithoutContactNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutContactNestedInput
    ContactTag?: ContactTagUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneWithoutDealNestedInput
    owner?: UserUpdateOneRequiredWithoutDealNestedInput
    Activity?: ActivityUpdateManyWithoutDealNestedInput
    DealTag?: DealTagUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Activity?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    DealTag?: DealTagUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutActivityNestedInput
    contact?: ContactUpdateOneWithoutActivityNestedInput
    deal?: DealUpdateOneWithoutActivityNestedInput
    parent?: ActivityUpdateOneWithoutSubtasksNestedInput
    subtasks?: ActivityUpdateManyWithoutParentNestedInput
    tags?: TagUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtasks?: ActivityUncheckedUpdateManyWithoutParentNestedInput
    tags?: TagUncheckedUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealCreateManyContactInput = {
    id?: string
    title: string
    amount: number
    stage: string
    probability: number
    closeDate: Date | string
    accountId?: string | null
    ownerId: string
    createdAt?: Date | string
  }

  export type ActivityCreateManyContactInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    ownerId: string
    accountId?: string | null
    dealId?: string | null
    parentId?: string | null
    createdAt?: Date | string
  }

  export type ContactTagCreateManyContactInput = {
    tagId: string
  }

  export type DealUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutDealNestedInput
    owner?: UserUpdateOneRequiredWithoutDealNestedInput
    Activity?: ActivityUpdateManyWithoutDealNestedInput
    DealTag?: DealTagUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Activity?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    DealTag?: DealTagUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    closeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutActivityNestedInput
    account?: AccountUpdateOneWithoutActivityNestedInput
    deal?: DealUpdateOneWithoutActivityNestedInput
    parent?: ActivityUpdateOneWithoutSubtasksNestedInput
    subtasks?: ActivityUpdateManyWithoutParentNestedInput
    tags?: TagUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtasks?: ActivityUncheckedUpdateManyWithoutParentNestedInput
    tags?: TagUncheckedUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTagUpdateWithoutContactInput = {
    tag?: TagUpdateOneRequiredWithoutContactTagsNestedInput
  }

  export type ContactTagUncheckedUpdateWithoutContactInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagUncheckedUpdateManyWithoutContactInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityCreateManyDealInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    ownerId: string
    accountId?: string | null
    contactId?: string | null
    parentId?: string | null
    createdAt?: Date | string
  }

  export type DealTagCreateManyDealInput = {
    tagId: string
  }

  export type ActivityUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutActivityNestedInput
    account?: AccountUpdateOneWithoutActivityNestedInput
    contact?: ContactUpdateOneWithoutActivityNestedInput
    parent?: ActivityUpdateOneWithoutSubtasksNestedInput
    subtasks?: ActivityUpdateManyWithoutParentNestedInput
    tags?: TagUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtasks?: ActivityUncheckedUpdateManyWithoutParentNestedInput
    tags?: TagUncheckedUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealTagUpdateWithoutDealInput = {
    tag?: TagUpdateOneRequiredWithoutDealTagsNestedInput
  }

  export type DealTagUncheckedUpdateWithoutDealInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type DealTagUncheckedUpdateManyWithoutDealInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityCreateManyParentInput = {
    id?: string
    title: string
    type: string
    status: string
    description?: string | null
    date: Date | string
    ownerId: string
    accountId?: string | null
    contactId?: string | null
    dealId?: string | null
    createdAt?: Date | string
  }

  export type ActivityUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutActivityNestedInput
    account?: AccountUpdateOneWithoutActivityNestedInput
    contact?: ContactUpdateOneWithoutActivityNestedInput
    deal?: DealUpdateOneWithoutActivityNestedInput
    subtasks?: ActivityUpdateManyWithoutParentNestedInput
    tags?: TagUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtasks?: ActivityUncheckedUpdateManyWithoutParentNestedInput
    tags?: TagUncheckedUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DealTags?: DealTagUpdateManyWithoutTagNestedInput
    ContactTags?: ContactTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DealTags?: DealTagUncheckedUpdateManyWithoutTagNestedInput
    ContactTags?: ContactTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateManyWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageCreateManyTemplateInput = {
    id?: string
    subject: string
    to: string
    body: string
    status: string
    userId: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailMessageUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailMessageNestedInput
  }

  export type EmailMessageUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedDocumentCreateManyTemplateInput = {
    id?: string
    filePath: string
    format: string
    userId: string
    createdAt?: Date | string
  }

  export type GeneratedDocumentUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGeneratedDocumentNestedInput
  }

  export type GeneratedDocumentUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedDocumentUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateManyFolderInput = {
    id?: string
    name: string
    path: string
    size: number
    mimeType: string
    userId: string
    dealId?: string | null
    contactId?: string | null
    taskId?: string | null
    publicLink?: string | null
    expiresAt?: Date | string | null
    access: string
    createdAt?: Date | string
    commentId?: string | null
  }

  export type FileUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    publicLink?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFileNestedInput
    comment?: CommentUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    publicLink?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    publicLink?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DealTagCreateManyTagInput = {
    dealId: string
  }

  export type ContactTagCreateManyTagInput = {
    contactId: string
  }

  export type DealTagUpdateWithoutTagInput = {
    deal?: DealUpdateOneRequiredWithoutDealTagNestedInput
  }

  export type DealTagUncheckedUpdateWithoutTagInput = {
    dealId?: StringFieldUpdateOperationsInput | string
  }

  export type DealTagUncheckedUpdateManyWithoutTagInput = {
    dealId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagUpdateWithoutTagInput = {
    contact?: ContactUpdateOneRequiredWithoutContactTagNestedInput
  }

  export type ContactTagUncheckedUpdateWithoutTagInput = {
    contactId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagUncheckedUpdateManyWithoutTagInput = {
    contactId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutActivityNestedInput
    account?: AccountUpdateOneWithoutActivityNestedInput
    contact?: ContactUpdateOneWithoutActivityNestedInput
    deal?: DealUpdateOneWithoutActivityNestedInput
    parent?: ActivityUpdateOneWithoutSubtasksNestedInput
    subtasks?: ActivityUpdateManyWithoutParentNestedInput
  }

  export type ActivityUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtasks?: ActivityUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldValueCreateManyFieldInput = {
    id?: string
    entity: string
    entityId: string
    value: string
    createdAt?: Date | string
  }

  export type CustomFieldValueUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldValueUncheckedUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldValueUncheckedUpdateManyWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateManyCommentInput = {
    id?: string
    name: string
    path: string
    size: number
    mimeType: string
    userId: string
    folderId?: string | null
    dealId?: string | null
    contactId?: string | null
    taskId?: string | null
    publicLink?: string | null
    expiresAt?: Date | string | null
    access: string
    createdAt?: Date | string
  }

  export type FileUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    publicLink?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFileNestedInput
    folder?: FileFolderUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    publicLink?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    publicLink?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    access?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}